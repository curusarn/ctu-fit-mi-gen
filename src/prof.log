SCRIPT  /usr/share/vim/vim80/syntax/cpp.vim
Sourced 1 time
Total time:   0.001641
 Self time:   0.000255

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	C++
                            " Current Maintainer:	vim-jp (https://github.com/vim-jp/vim-cpp)
                            " Previous Maintainer:	Ken Shan <ccshan@post.harvard.edu>
                            " Last Change:	2017 Jun 05
                            
                            " quit when a syntax file was already loaded
    1              0.000003 if exists("b:current_syntax")
                              finish
                            endif
                            
                            " Read the C syntax to start with
    1   0.001483   0.000097 runtime! syntax/c.vim
    1              0.000001 unlet b:current_syntax
                            
                            " C++ extensions
    1              0.000004 syn keyword cppStatement	new delete this friend using
    1              0.000002 syn keyword cppAccess		public protected private
    1              0.000003 syn keyword cppModifier		inline virtual explicit export
    1              0.000002 syn keyword cppType		bool wchar_t
    1              0.000003 syn keyword cppExceptions	throw try catch
    1              0.000002 syn keyword cppOperator		operator typeid
    1              0.000002 syn keyword cppOperator		and bitor or xor compl bitand and_eq or_eq xor_eq not not_eq
    1              0.000006 syn match cppCast		"\<\(const\|static\|dynamic\|reinterpret\)_cast\s*<"me=e-1
    1              0.000004 syn match cppCast		"\<\(const\|static\|dynamic\|reinterpret\)_cast\s*$"
    1              0.000004 syn keyword cppStorageClass	mutable
    1              0.000002 syn keyword cppStructure	class typename template namespace
    1              0.000003 syn keyword cppBoolean		true false
    1              0.000002 syn keyword cppConstant		__cplusplus
                            
                            " C++ 11 extensions
    1              0.000003 if !exists("cpp_no_cpp11")
    1              0.000001   syn keyword cppModifier	override final
    1              0.000002   syn keyword cppType		nullptr_t auto
    1              0.000001   syn keyword cppExceptions	noexcept
    1              0.000001   syn keyword cppStorageClass	constexpr decltype thread_local
    1              0.000001   syn keyword cppConstant	nullptr
    1              0.000002   syn keyword cppConstant	ATOMIC_FLAG_INIT ATOMIC_VAR_INIT
    1              0.000001   syn keyword cppConstant	ATOMIC_BOOL_LOCK_FREE ATOMIC_CHAR_LOCK_FREE
    1              0.000001   syn keyword cppConstant	ATOMIC_CHAR16_T_LOCK_FREE ATOMIC_CHAR32_T_LOCK_FREE
    1              0.000001   syn keyword cppConstant	ATOMIC_WCHAR_T_LOCK_FREE ATOMIC_SHORT_LOCK_FREE
    1              0.000002   syn keyword cppConstant	ATOMIC_INT_LOCK_FREE ATOMIC_LONG_LOCK_FREE
    1              0.000001   syn keyword cppConstant	ATOMIC_LLONG_LOCK_FREE ATOMIC_POINTER_LOCK_FREE
    1              0.000030   syn region cppRawString	matchgroup=cppRawStringDelimiter start=+\%(u8\|[uLU]\)\=R"\z([[:alnum:]_{}[\]#<>%:;.?*\+\-/\^&|~!=,"']\{,16}\)(+ end=+)\z1"+ contains=@Spell
    1              0.000000 endif
                            
                            " C++ 14 extensions
    1              0.000002 if !exists("cpp_no_cpp14")
    1              0.000001   syn case ignore
    1              0.000006   syn match cppNumber		display "\<0b[01]\('\=[01]\+\)*\(u\=l\{0,2}\|ll\=u\)\>"
    1              0.000005   syn match cppNumber		display "\<[1-9]\('\=\d\+\)*\(u\=l\{0,2}\|ll\=u\)\>" contains=cFloat
    1              0.000010   syn match cppNumber		display "\<0x\x\('\=\x\+\)*\(u\=l\{0,2}\|ll\=u\)\>"
    1              0.000001   syn case match
    1              0.000001 endif
                            
                            " The minimum and maximum operators in GNU C++
    1              0.000003 syn match cppMinMax "[<>]?"
                            
                            " Default highlighting
    1              0.000001 hi def link cppAccess		cppStatement
    1              0.000000 hi def link cppCast		cppStatement
    1              0.000001 hi def link cppExceptions		Exception
    1              0.000002 hi def link cppOperator		Operator
    1              0.000001 hi def link cppStatement		Statement
    1              0.000001 hi def link cppModifier		Type
    1              0.000002 hi def link cppType		Type
    1              0.000001 hi def link cppStorageClass	StorageClass
    1              0.000002 hi def link cppStructure		Structure
    1              0.000001 hi def link cppBoolean		Boolean
    1              0.000002 hi def link cppConstant		Constant
    1              0.000002 hi def link cppRawStringDelimiter	Delimiter
    1              0.000001 hi def link cppRawString		String
    1              0.000002 hi def link cppNumber		Number
                            
    1              0.000002 let b:current_syntax = "cpp"
                            
                            " vim: ts=8

SCRIPT  /usr/share/vim/vim80/syntax/c.vim
Sourced 1 time
Total time:   0.001378
 Self time:   0.001378

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	C
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2017 Apr 30
                            
                            " Quit when a (custom) syntax file was already loaded
    1              0.000002 if exists("b:current_syntax")
                              finish
                            endif
                            
    1              0.000006 let s:cpo_save = &cpo
    1              0.000011 set cpo&vim
                            
    1              0.000014 let s:ft = matchstr(&ft, '^\([^.]\)\+')
                            
                            " Optional embedded Autodoc parsing
                            " To enable it add: let g:c_autodoc = 1
                            " to your .vimrc
    1              0.000002 if exists("c_autodoc")
                              syn include @cAutodoc <sfile>:p:h/autodoc.vim
                              unlet b:current_syntax
                            endif
                            
                            " A bunch of useful C keywords
    1              0.000007 syn keyword	cStatement	goto break return continue asm
    1              0.000003 syn keyword	cLabel		case default
    1              0.000002 syn keyword	cConditional	if else switch
    1              0.000002 syn keyword	cRepeat		while for do
                            
    1              0.000003 syn keyword	cTodo		contained TODO FIXME XXX
                            
                            " It's easy to accidentally add a space after a backslash that was intended
                            " for line continuation.  Some compilers allow it, which makes it
                            " unpredictable and should be avoided.
    1              0.000004 syn match	cBadContinuation contained "\\\s\+$"
                            
                            " cCommentGroup allows adding matches for special things in comments
    1              0.000004 syn cluster	cCommentGroup	contains=cTodo,cBadContinuation
                            
                            " String and Character constants
                            " Highlight special characters (those which have a backslash) differently
    1              0.000005 syn match	cSpecial	display contained "\\\(x\x\+\|\o\{1,3}\|.\|$\)"
    1              0.000002 if !exists("c_no_utf")
    1              0.000004   syn match	cSpecial	display contained "\\\(u\x\{4}\|U\x\{8}\)"
    1              0.000001 endif
                            
    1              0.000002 if !exists("c_no_cformat")
                              " Highlight % items in strings.
    1              0.000002   if !exists("c_no_c99") " ISO C99
    1              0.000010     syn match	cFormat		display "%\(\d\+\$\)\=[-+' #0*]*\(\d*\|\*\|\*\d\+\$\)\(\.\(\d*\|\*\|\*\d\+\$\)\)\=\([hlLjzt]\|ll\|hh\)\=\([aAbdiuoxXDOUfFeEgGcCsSpn]\|\[\^\=.[^]]*\]\)" contained
    1              0.000000   else
                                syn match	cFormat		display "%\(\d\+\$\)\=[-+' #0*]*\(\d*\|\*\|\*\d\+\$\)\(\.\(\d*\|\*\|\*\d\+\$\)\)\=\([hlL]\|ll\)\=\([bdiuoxXDOUfeEgGcCsSpn]\|\[\^\=.[^]]*\]\)" contained
                              endif
    1              0.000003   syn match	cFormat		display "%%" contained
    1              0.000000 endif
                            
                            " cCppString: same as cString, but ends at end of line
    1              0.000004 if s:ft ==# "cpp" && !exists("cpp_no_cpp11") && !exists("c_no_cformat")
                              " ISO C++11
    1              0.000012   syn region	cString		start=+\(L\|u\|u8\|U\|R\|LR\|u8R\|uR\|UR\)\="+ skip=+\\\\\|\\"+ end=+"+ contains=cSpecial,cFormat,@Spell extend
    1              0.000010   syn region 	cCppString	start=+\(L\|u\|u8\|U\|R\|LR\|u8R\|uR\|UR\)\="+ skip=+\\\\\|\\"\|\\$+ excludenl end=+"+ end='$' contains=cSpecial,cFormat,@Spell
    1              0.000002 elseif s:ft ==# "c" && !exists("c_no_c11") && !exists("c_no_cformat")
                              " ISO C99
                              syn region	cString		start=+\%(L\|U\|u8\)\="+ skip=+\\\\\|\\"+ end=+"+ contains=cSpecial,cFormat,@Spell extend
                              syn region	cCppString	start=+\%(L\|U\|u8\)\="+ skip=+\\\\\|\\"\|\\$+ excludenl end=+"+ end='$' contains=cSpecial,cFormat,@Spell
                            else
                              " older C or C++
                              syn match	cFormat		display "%%" contained
                              syn region	cString		start=+L\="+ skip=+\\\\\|\\"+ end=+"+ contains=cSpecial,cFormat,@Spell extend
                              syn region	cCppString	start=+L\="+ skip=+\\\\\|\\"\|\\$+ excludenl end=+"+ end='$' contains=cSpecial,cFormat,@Spell
                            endif
                            
    1              0.000011 syn region	cCppSkip	contained start="^\s*\(%:\|#\)\s*\(if\>\|ifdef\>\|ifndef\>\)" skip="\\$" end="^\s*\(%:\|#\)\s*endif\>" contains=cSpaceError,cCppSkip
                            
    1              0.000002 syn cluster	cStringGroup	contains=cCppString,cCppSkip
                            
    1              0.000003 syn match	cCharacter	"L\='[^\\]'"
    1              0.000003 syn match	cCharacter	"L'[^']*'" contains=cSpecial
    1              0.000002 if exists("c_gnu")
                              syn match	cSpecialError	"L\='\\[^'\"?\\abefnrtv]'"
                              syn match	cSpecialCharacter "L\='\\['\"?\\abefnrtv]'"
                            else
    1              0.000003   syn match	cSpecialError	"L\='\\[^'\"?\\abfnrtv]'"
    1              0.000004   syn match	cSpecialCharacter "L\='\\['\"?\\abfnrtv]'"
    1              0.000001 endif
    1              0.000002 syn match	cSpecialCharacter display "L\='\\\o\{1,3}'"
    1              0.000002 syn match	cSpecialCharacter display "'\\x\x\{1,2}'"
    1              0.000004 syn match	cSpecialCharacter display "L'\\x\x\+'"
                            
    1              0.000004 if (s:ft ==# "c" && !exists("c_no_c11")) || (s:ft ==# "cpp" && !exists("cpp_no_cpp11"))
                              " ISO C11 or ISO C++ 11
    1              0.000001   if exists("c_no_cformat")
                                syn region	cString		start=+\%(U\|u8\=\)"+ skip=+\\\\\|\\"+ end=+"+ contains=cSpecial,@Spell extend
                              else
    1              0.000006     syn region	cString		start=+\%(U\|u8\=\)"+ skip=+\\\\\|\\"+ end=+"+ contains=cSpecial,cFormat,@Spell extend
    1              0.000000   endif
    1              0.000003   syn match	cCharacter	"[Uu]'[^\\]'"
    1              0.000002   syn match	cCharacter	"[Uu]'[^']*'" contains=cSpecial
    1              0.000003   if exists("c_gnu")
                                syn match	cSpecialError	"[Uu]'\\[^'\"?\\abefnrtv]'"
                                syn match	cSpecialCharacter "[Uu]'\\['\"?\\abefnrtv]'"
                              else
    1              0.000002     syn match	cSpecialError	"[Uu]'\\[^'\"?\\abfnrtv]'"
    1              0.000003     syn match	cSpecialCharacter "[Uu]'\\['\"?\\abfnrtv]'"
    1              0.000000   endif
    1              0.000002   syn match	cSpecialCharacter display "[Uu]'\\\o\{1,3}'"
    1              0.000002   syn match	cSpecialCharacter display "[Uu]'\\x\x\+'"
    1              0.000001 endif
                            
                            "when wanted, highlight trailing white space
    1              0.000002 if exists("c_space_errors")
                              if !exists("c_no_trail_space_error")
                                syn match	cSpaceError	display excludenl "\s\+$"
                              endif
                              if !exists("c_no_tab_space_error")
                                syn match	cSpaceError	display " \+\t"me=e-1
                              endif
                            endif
                            
                            " This should be before cErrInParen to avoid problems with #define ({ xxx })
    1              0.000002 if exists("c_curly_error")
                              syn match cCurlyError "}"
                              syn region	cBlock		start="{" end="}" contains=ALLBUT,cBadBlock,cCurlyError,@cParenGroup,cErrInParen,cCppParen,cErrInBracket,cCppBracket,@cStringGroup,@Spell fold
                            else
    1              0.000004   syn region	cBlock		start="{" end="}" transparent fold
    1              0.000000 endif
                            
                            " Catch errors caused by wrong parenthesis and brackets.
                            " Also accept <% for {, %> for }, <: for [ and :> for ] (C99)
                            " But avoid matching <::.
    1              0.000031 syn cluster	cParenGroup	contains=cParenError,cIncluded,cSpecial,cCommentSkip,cCommentString,cComment2String,@cCommentGroup,cCommentStartError,cUserLabel,cBitField,cOctalZero,@cCppOutInGroup,cFormat,cNumber,cFloat,cOctal,cOctalError,cNumbersCom
    1              0.000002 if exists("c_no_curly_error")
                              if s:ft ==# 'cpp' && !exists("cpp_no_cpp11")
                                syn region	cParen		transparent start='(' end=')' contains=ALLBUT,@cParenGroup,cCppParen,@cStringGroup,@Spell
                                " cCppParen: same as cParen but ends at end-of-line; used in cDefine
                                syn region	cCppParen	transparent start='(' skip='\\$' excludenl end=')' end='$' contained contains=ALLBUT,@cParenGroup,cParen,cString,@Spell
                                syn match	cParenError	display ")"
                                syn match	cErrInParen	display contained "^^<%\|^%>"
                              else
                                syn region	cParen		transparent start='(' end=')' end='}'me=s-1 contains=ALLBUT,cBlock,@cParenGroup,cCppParen,@cStringGroup,@Spell
                                " cCppParen: same as cParen but ends at end-of-line; used in cDefine
                                syn region	cCppParen	transparent start='(' skip='\\$' excludenl end=')' end='$' contained contains=ALLBUT,@cParenGroup,cParen,cString,@Spell
                                syn match	cParenError	display ")"
                                syn match	cErrInParen	display contained "^[{}]\|^<%\|^%>"
                              endif
                            elseif exists("c_no_bracket_error")
                              if s:ft ==# 'cpp' && !exists("cpp_no_cpp11")
                                syn region	cParen		transparent start='(' end=')' contains=ALLBUT,@cParenGroup,cCppParen,@cStringGroup,@Spell
                                " cCppParen: same as cParen but ends at end-of-line; used in cDefine
                                syn region	cCppParen	transparent start='(' skip='\\$' excludenl end=')' end='$' contained contains=ALLBUT,@cParenGroup,cParen,cString,@Spell
                                syn match	cParenError	display ")"
                                syn match	cErrInParen	display contained "<%\|%>"
                              else
                                syn region	cParen		transparent start='(' end=')' end='}'me=s-1 contains=ALLBUT,cBlock,@cParenGroup,cCppParen,@cStringGroup,@Spell
                                " cCppParen: same as cParen but ends at end-of-line; used in cDefine
                                syn region	cCppParen	transparent start='(' skip='\\$' excludenl end=')' end='$' contained contains=ALLBUT,@cParenGroup,cParen,cString,@Spell
                                syn match	cParenError	display ")"
                                syn match	cErrInParen	display contained "[{}]\|<%\|%>"
                              endif
                            else
    1              0.000002   if s:ft ==# 'cpp' && !exists("cpp_no_cpp11")
    1              0.000005     syn region	cParen		transparent start='(' end=')' contains=ALLBUT,@cParenGroup,cCppParen,cErrInBracket,cCppBracket,@cStringGroup,@Spell
                                " cCppParen: same as cParen but ends at end-of-line; used in cDefine
    1              0.000010     syn region	cCppParen	transparent start='(' skip='\\$' excludenl end=')' end='$' contained contains=ALLBUT,@cParenGroup,cErrInBracket,cParen,cBracket,cString,@Spell
    1              0.000003     syn match	cParenError	display "[\])]"
    1              0.000001     syn match	cErrInParen	display contained "<%\|%>"
    1              0.000007     syn region	cBracket	transparent start='\[\|<::\@!' end=']\|:>' contains=ALLBUT,@cParenGroup,cErrInParen,cCppParen,cCppBracket,@cStringGroup,@Spell
    1              0.000002   else
                                syn region	cParen		transparent start='(' end=')' end='}'me=s-1 contains=ALLBUT,cBlock,@cParenGroup,cCppParen,cErrInBracket,cCppBracket,@cStringGroup,@Spell
                                " cCppParen: same as cParen but ends at end-of-line; used in cDefine
                                syn region	cCppParen	transparent start='(' skip='\\$' excludenl end=')' end='$' contained contains=ALLBUT,@cParenGroup,cErrInBracket,cParen,cBracket,cString,@Spell
                                syn match	cParenError	display "[\])]"
                                syn match	cErrInParen	display contained "[\]{}]\|<%\|%>"
                                syn region	cBracket	transparent start='\[\|<::\@!' end=']\|:>' end='}'me=s-1 contains=ALLBUT,cBlock,@cParenGroup,cErrInParen,cCppParen,cCppBracket,@cStringGroup,@Spell
                              endif
                              " cCppBracket: same as cParen but ends at end-of-line; used in cDefine
    1              0.000007   syn region	cCppBracket	transparent start='\[\|<::\@!' skip='\\$' excludenl end=']\|:>' end='$' contained contains=ALLBUT,@cParenGroup,cErrInParen,cParen,cBracket,cString,@Spell
    1              0.000002   syn match	cErrInBracket	display contained "[);{}]\|<%\|%>"
    1              0.000000 endif
                            
    1              0.000003 if s:ft ==# 'c' || exists("cpp_no_cpp11")
                              syn region	cBadBlock	keepend start="{" end="}" contained containedin=cParen,cBracket,cBadBlock transparent fold
                            endif
                            
                            "integer number, or floating point number without a dot and with "f".
    1              0.000001 syn case ignore
    1              0.000006 syn match	cNumbers	display transparent "\<\d\|\.\d" contains=cNumber,cFloat,cOctalError,cOctal
                            " Same, but without octal error (for comments)
    1              0.000004 syn match	cNumbersCom	display contained transparent "\<\d\|\.\d" contains=cNumber,cFloat,cOctal
    1              0.000003 syn match	cNumber		display contained "\d\+\(u\=l\{0,2}\|ll\=u\)\>"
                            "hex number
    1              0.000003 syn match	cNumber		display contained "0x\x\+\(u\=l\{0,2}\|ll\=u\)\>"
                            " Flag the first zero of an octal number as something special
    1              0.000004 syn match	cOctal		display contained "0\o\+\(u\=l\{0,2}\|ll\=u\)\>" contains=cOctalZero
    1              0.000002 syn match	cOctalZero	display contained "\<0"
    1              0.000001 syn match	cFloat		display contained "\d\+f"
                            "floating point number, with dot, optional exponent
    1              0.000003 syn match	cFloat		display contained "\d\+\.\d*\(e[-+]\=\d\+\)\=[fl]\="
                            "floating point number, starting with a dot, optional exponent
    1              0.000002 syn match	cFloat		display contained "\.\d\+\(e[-+]\=\d\+\)\=[fl]\=\>"
                            "floating point number, without dot, with exponent
    1              0.000004 syn match	cFloat		display contained "\d\+e[-+]\=\d\+[fl]\=\>"
    1              0.000002 if !exists("c_no_c99")
                              "hexadecimal floating point number, optional leading digits, with dot, with exponent
    1              0.000003   syn match	cFloat		display contained "0x\x*\.\x\+p[-+]\=\d\+[fl]\=\>"
                              "hexadecimal floating point number, with leading digits, optional dot, with exponent
    1              0.000003   syn match	cFloat		display contained "0x\x\+\.\=p[-+]\=\d\+[fl]\=\>"
    1              0.000000 endif
                            
                            " flag an octal number with wrong digits
    1              0.000002 syn match	cOctalError	display contained "0\o*[89]\d*"
    1              0.000001 syn case match
                            
    1              0.000002 if exists("c_comment_strings")
                              " A comment can contain cString, cCharacter and cNumber.
                              " But a "*/" inside a cString in a cComment DOES end the comment!  So we
                              " need to use a special type of cString: cCommentString, which also ends on
                              " "*/", and sees a "*" at the start of the line as comment again.
                              " Unfortunately this doesn't very well work for // type of comments :-(
                              syn match	cCommentSkip	contained "^\s*\*\($\|\s\+\)"
                              syn region cCommentString	contained start=+L\=\\\@<!"+ skip=+\\\\\|\\"+ end=+"+ end=+\*/+me=s-1 contains=cSpecial,cCommentSkip
                              syn region cComment2String	contained start=+L\=\\\@<!"+ skip=+\\\\\|\\"+ end=+"+ end="$" contains=cSpecial
                              syn region  cCommentL	start="//" skip="\\$" end="$" keepend contains=@cCommentGroup,cComment2String,cCharacter,cNumbersCom,cSpaceError,@Spell
                              if exists("c_no_comment_fold")
                                " Use "extend" here to have preprocessor lines not terminate halfway a
                                " comment.
                                syn region cComment	matchgroup=cCommentStart start="/\*" end="\*/" contains=@cCommentGroup,cCommentStartError,cCommentString,cCharacter,cNumbersCom,cSpaceError,@Spell extend
                              else
                                syn region cComment	matchgroup=cCommentStart start="/\*" end="\*/" contains=@cCommentGroup,cCommentStartError,cCommentString,cCharacter,cNumbersCom,cSpaceError,@Spell fold extend
                              endif
                            else
    1              0.000009   syn region	cCommentL	start="//" skip="\\$" end="$" keepend contains=@cCommentGroup,cSpaceError,@Spell
    1              0.000004   if exists("c_no_comment_fold")
                                syn region	cComment	matchgroup=cCommentStart start="/\*" end="\*/" contains=@cCommentGroup,cCommentStartError,cSpaceError,@Spell extend
                              else
    1              0.000007     syn region	cComment	matchgroup=cCommentStart start="/\*" end="\*/" contains=@cCommentGroup,cCommentStartError,cSpaceError,@Spell fold extend
    1              0.000001   endif
    1              0.000000 endif
                            " keep a // comment separately, it terminates a preproc. conditional
    1              0.000003 syn match	cCommentError	display "\*/"
    1              0.000002 syn match	cCommentStartError display "/\*"me=e-1 contained
                            
    1              0.000002 syn keyword	cOperator	sizeof
    1              0.000001 if exists("c_gnu")
                              syn keyword	cStatement	__asm__
                              syn keyword	cOperator	typeof __real__ __imag__
                            endif
    1              0.000004 syn keyword	cType		int long short char void
    1              0.000001 syn keyword	cType		signed unsigned float double
    1              0.000003 if !exists("c_no_ansi") || exists("c_ansi_typedefs")
    1              0.000002   syn keyword   cType		size_t ssize_t off_t wchar_t ptrdiff_t sig_atomic_t fpos_t
    1              0.000002   syn keyword   cType		clock_t time_t va_list jmp_buf FILE DIR div_t ldiv_t
    1              0.000004   syn keyword   cType		mbstate_t wctrans_t wint_t wctype_t
    1              0.000000 endif
    1              0.000002 if !exists("c_no_c99") " ISO C99
    1              0.000005   syn keyword	cType		_Bool bool _Complex complex _Imaginary imaginary
    1              0.000001   syn keyword	cType		int8_t int16_t int32_t int64_t
    1              0.000001   syn keyword	cType		uint8_t uint16_t uint32_t uint64_t
    1              0.000002   if !exists("c_no_bsd")
                                " These are BSD specific.
    1              0.000001     syn keyword	cType		u_int8_t u_int16_t u_int32_t u_int64_t
    1              0.000001   endif
    1              0.000001   syn keyword	cType		int_least8_t int_least16_t int_least32_t int_least64_t
    1              0.000002   syn keyword	cType		uint_least8_t uint_least16_t uint_least32_t uint_least64_t
    1              0.000001   syn keyword	cType		int_fast8_t int_fast16_t int_fast32_t int_fast64_t
    1              0.000001   syn keyword	cType		uint_fast8_t uint_fast16_t uint_fast32_t uint_fast64_t
    1              0.000001   syn keyword	cType		intptr_t uintptr_t
    1              0.000001   syn keyword	cType		intmax_t uintmax_t
    1              0.000001 endif
    1              0.000001 if exists("c_gnu")
                              syn keyword	cType		__label__ __complex__ __volatile__
                            endif
                            
    1              0.000002 syn keyword	cStructure	struct union enum typedef
    1              0.000003 syn keyword	cStorageClass	static register auto volatile extern const
    1              0.000001 if exists("c_gnu")
                              syn keyword	cStorageClass	inline __attribute__
                            endif
    1              0.000002 if !exists("c_no_c99") && s:ft !=# 'cpp'
                              syn keyword	cStorageClass	inline restrict
                            endif
    1              0.000002 if !exists("c_no_c11")
    1              0.000001   syn keyword	cStorageClass	_Alignas alignas
    1              0.000001   syn keyword	cOperator	_Alignof alignof
    1              0.000001   syn keyword	cStorageClass	_Atomic
    1              0.000001   syn keyword	cOperator	_Generic
    1              0.000001   syn keyword	cStorageClass	_Noreturn noreturn
    1              0.000001   syn keyword	cOperator	_Static_assert static_assert
    1              0.000001   syn keyword	cStorageClass	_Thread_local thread_local
    1              0.000001   syn keyword   cType		char16_t char32_t
    1              0.000001 endif
                            
    1              0.000002 if !exists("c_no_ansi") || exists("c_ansi_constants") || exists("c_gnu")
    1              0.000002   if exists("c_gnu")
                                syn keyword cConstant __GNUC__ __FUNCTION__ __PRETTY_FUNCTION__ __func__
                              endif
    1              0.000015   syn keyword cConstant __LINE__ __FILE__ __DATE__ __TIME__ __STDC__
    1              0.000001   syn keyword cConstant __STDC_VERSION__
    1              0.000002   syn keyword cConstant CHAR_BIT MB_LEN_MAX MB_CUR_MAX
    1              0.000001   syn keyword cConstant UCHAR_MAX UINT_MAX ULONG_MAX USHRT_MAX
    1              0.000001   syn keyword cConstant CHAR_MIN INT_MIN LONG_MIN SHRT_MIN
    1              0.000001   syn keyword cConstant CHAR_MAX INT_MAX LONG_MAX SHRT_MAX
    1              0.000002   syn keyword cConstant SCHAR_MIN SINT_MIN SLONG_MIN SSHRT_MIN
    1              0.000001   syn keyword cConstant SCHAR_MAX SINT_MAX SLONG_MAX SSHRT_MAX
    1              0.000002   if !exists("c_no_c99")
    1              0.000001     syn keyword cConstant __func__ __VA_ARGS__
    1              0.000001     syn keyword cConstant LLONG_MIN LLONG_MAX ULLONG_MAX
    1              0.000001     syn keyword cConstant INT8_MIN INT16_MIN INT32_MIN INT64_MIN
    1              0.000001     syn keyword cConstant INT8_MAX INT16_MAX INT32_MAX INT64_MAX
    1              0.000001     syn keyword cConstant UINT8_MAX UINT16_MAX UINT32_MAX UINT64_MAX
    1              0.000001     syn keyword cConstant INT_LEAST8_MIN INT_LEAST16_MIN INT_LEAST32_MIN INT_LEAST64_MIN
    1              0.000002     syn keyword cConstant INT_LEAST8_MAX INT_LEAST16_MAX INT_LEAST32_MAX INT_LEAST64_MAX
    1              0.000002     syn keyword cConstant UINT_LEAST8_MAX UINT_LEAST16_MAX UINT_LEAST32_MAX UINT_LEAST64_MAX
    1              0.000002     syn keyword cConstant INT_FAST8_MIN INT_FAST16_MIN INT_FAST32_MIN INT_FAST64_MIN
    1              0.000014     syn keyword cConstant INT_FAST8_MAX INT_FAST16_MAX INT_FAST32_MAX INT_FAST64_MAX
    1              0.000012     syn keyword cConstant UINT_FAST8_MAX UINT_FAST16_MAX UINT_FAST32_MAX UINT_FAST64_MAX
    1              0.000009     syn keyword cConstant INTPTR_MIN INTPTR_MAX UINTPTR_MAX
    1              0.000010     syn keyword cConstant INTMAX_MIN INTMAX_MAX UINTMAX_MAX
    1              0.000011     syn keyword cConstant PTRDIFF_MIN PTRDIFF_MAX SIG_ATOMIC_MIN SIG_ATOMIC_MAX
    1              0.000014     syn keyword cConstant SIZE_MAX WCHAR_MIN WCHAR_MAX WINT_MIN WINT_MAX
    1              0.000000   endif
    1              0.000021   syn keyword cConstant FLT_RADIX FLT_ROUNDS FLT_DIG FLT_MANT_DIG FLT_EPSILON DBL_DIG DBL_MANT_DIG DBL_EPSILON
    1              0.000012   syn keyword cConstant LDBL_DIG LDBL_MANT_DIG LDBL_EPSILON FLT_MIN FLT_MAX FLT_MIN_EXP FLT_MAX_EXP FLT_MIN_10_EXP FLT_MAX_10_EXP
    1              0.000003   syn keyword cConstant DBL_MIN DBL_MAX DBL_MIN_EXP DBL_MAX_EXP DBL_MIN_10_EXP DBL_MAX_10_EXP LDBL_MIN LDBL_MAX LDBL_MIN_EXP LDBL_MAX_EXP
    1              0.000002   syn keyword cConstant LDBL_MIN_10_EXP LDBL_MAX_10_EXP HUGE_VAL CLOCKS_PER_SEC NULL LC_ALL LC_COLLATE LC_CTYPE LC_MONETARY
    1              0.000003   syn keyword cConstant LC_NUMERIC LC_TIME SIG_DFL SIG_ERR SIG_IGN SIGABRT SIGFPE SIGILL SIGHUP SIGINT SIGSEGV SIGTERM
                              " Add POSIX signals as well...
    1              0.000004   syn keyword cConstant SIGABRT SIGALRM SIGCHLD SIGCONT SIGFPE SIGHUP SIGILL SIGINT SIGKILL SIGPIPE SIGQUIT SIGSEGV
    1              0.000002   syn keyword cConstant SIGSTOP SIGTERM SIGTRAP SIGTSTP SIGTTIN SIGTTOU SIGUSR1 SIGUSR2
    1              0.000003   syn keyword cConstant _IOFBF _IOLBF _IONBF BUFSIZ EOF WEOF FOPEN_MAX FILENAME_MAX L_tmpnam
    1              0.000003   syn keyword cConstant SEEK_CUR SEEK_END SEEK_SET TMP_MAX stderr stdin stdout EXIT_FAILURE EXIT_SUCCESS RAND_MAX
                              " POSIX 2001
    1              0.000003   syn keyword cConstant SIGBUS SIGPOLL SIGPROF SIGSYS SIGURG SIGVTALRM SIGXCPU SIGXFSZ
                              " non-POSIX signals
    1              0.000001   syn keyword cConstant SIGWINCH SIGINFO
                              " Add POSIX errors as well.  List comes from:
                              " http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/errno.h.html
    1              0.000003   syn keyword cConstant E2BIG EACCES EADDRINUSE EADDRNOTAVAIL EAFNOSUPPORT EAGAIN EALREADY EBADF
    1              0.000003   syn keyword cConstant EBADMSG EBUSY ECANCELED ECHILD ECONNABORTED ECONNREFUSED ECONNRESET EDEADLK
    1              0.000003   syn keyword cConstant EDESTADDRREQ EDOM EDQUOT EEXIST EFAULT EFBIG EHOSTUNREACH EIDRM EILSEQ
    1              0.000004   syn keyword cConstant EINPROGRESS EINTR EINVAL EIO EISCONN EISDIR ELOOP EMFILE EMLINK EMSGSIZE
    1              0.000003   syn keyword cConstant EMULTIHOP ENAMETOOLONG ENETDOWN ENETRESET ENETUNREACH ENFILE ENOBUFS ENODATA
    1              0.000003   syn keyword cConstant ENODEV ENOENT ENOEXEC ENOLCK ENOLINK ENOMEM ENOMSG ENOPROTOOPT ENOSPC ENOSR
    1              0.000006   syn keyword cConstant ENOSTR ENOSYS ENOTCONN ENOTDIR ENOTEMPTY ENOTRECOVERABLE ENOTSOCK ENOTSUP
    1              0.000003   syn keyword cConstant ENOTTY ENXIO EOPNOTSUPP EOVERFLOW EOWNERDEAD EPERM EPIPE EPROTO
    1              0.000003   syn keyword cConstant EPROTONOSUPPORT EPROTOTYPE ERANGE EROFS ESPIPE ESRCH ESTALE ETIME ETIMEDOUT
    1              0.000002   syn keyword cConstant ETXTBSY EWOULDBLOCK EXDEV
                              " math.h
    1              0.000003   syn keyword cConstant M_E M_LOG2E M_LOG10E M_LN2 M_LN10 M_PI M_PI_2 M_PI_4
    1              0.000002   syn keyword cConstant M_1_PI M_2_PI M_2_SQRTPI M_SQRT2 M_SQRT1_2
    1              0.000001 endif
    1              0.000002 if !exists("c_no_c99") " ISO C99
    1              0.000002   syn keyword cConstant true false
    1              0.000001 endif
                            
                            " Accept %: for # (C99)
    1              0.000020 syn region	cPreCondit	start="^\s*\zs\(%:\|#\)\s*\(if\|ifdef\|ifndef\|elif\)\>" skip="\\$" end="$" keepend contains=cComment,cCommentL,cCppString,cCharacter,cCppParen,cParenError,cNumbers,cCommentError,cSpaceError
    1              0.000008 syn match	cPreConditMatch	display "^\s*\zs\(%:\|#\)\s*\(else\|endif\)\>"
    1              0.000003 if !exists("c_no_if0")
    1              0.000031   syn cluster	cCppOutInGroup	contains=cCppInIf,cCppInElse,cCppInElse2,cCppOutIf,cCppOutIf2,cCppOutElse,cCppInSkip,cCppOutSkip
    1              0.000013   syn region	cCppOutWrapper	start="^\s*\zs\(%:\|#\)\s*if\s\+0\+\s*\($\|//\|/\*\|&\)" end=".\@=\|$" contains=cCppOutIf,cCppOutElse,@NoSpell fold
    1              0.000008   syn region	cCppOutIf	contained start="0\+" matchgroup=cCppOutWrapper end="^\s*\(%:\|#\)\s*endif\>" contains=cCppOutIf2,cCppOutElse
    1              0.000003   if !exists("c_no_if0_fold")
    1              0.000013     syn region	cCppOutIf2	contained matchgroup=cCppOutWrapper start="0\+" end="^\s*\(%:\|#\)\s*\(else\>\|elif\s\+\(0\+\s*\($\|//\|/\*\|&\)\)\@!\|endif\>\)"me=s-1 contains=cSpaceError,cCppOutSkip,@Spell fold
    1              0.000001   else
                                syn region	cCppOutIf2	contained matchgroup=cCppOutWrapper start="0\+" end="^\s*\(%:\|#\)\s*\(else\>\|elif\s\+\(0\+\s*\($\|//\|/\*\|&\)\)\@!\|endif\>\)"me=s-1 contains=cSpaceError,cCppOutSkip,@Spell
                              endif
    1              0.000010   syn region	cCppOutElse	contained matchgroup=cCppOutWrapper start="^\s*\(%:\|#\)\s*\(else\|elif\)" end="^\s*\(%:\|#\)\s*endif\>"me=s-1 contains=TOP,cPreCondit
    1              0.000013   syn region	cCppInWrapper	start="^\s*\zs\(%:\|#\)\s*if\s\+0*[1-9]\d*\s*\($\|//\|/\*\||\)" end=".\@=\|$" contains=cCppInIf,cCppInElse fold
    1              0.000007   syn region	cCppInIf	contained matchgroup=cCppInWrapper start="\d\+" end="^\s*\(%:\|#\)\s*endif\>" contains=TOP,cPreCondit
    1              0.000003   if !exists("c_no_if0_fold")
    1              0.000011     syn region	cCppInElse	contained start="^\s*\(%:\|#\)\s*\(else\>\|elif\s\+\(0*[1-9]\d*\s*\($\|//\|/\*\||\)\)\@!\)" end=".\@=\|$" containedin=cCppInIf contains=cCppInElse2 fold
    1              0.000001   else
                                syn region	cCppInElse	contained start="^\s*\(%:\|#\)\s*\(else\>\|elif\s\+\(0*[1-9]\d*\s*\($\|//\|/\*\||\)\)\@!\)" end=".\@=\|$" containedin=cCppInIf contains=cCppInElse2
                              endif
    1              0.000012   syn region	cCppInElse2	contained matchgroup=cCppInWrapper start="^\s*\(%:\|#\)\s*\(else\|elif\)\([^/]\|/[^/*]\)*" end="^\s*\(%:\|#\)\s*endif\>"me=s-1 contains=cSpaceError,cCppOutSkip,@Spell
    1              0.000013   syn region	cCppOutSkip	contained start="^\s*\(%:\|#\)\s*\(if\>\|ifdef\>\|ifndef\>\)" skip="\\$" end="^\s*\(%:\|#\)\s*endif\>" contains=cSpaceError,cCppOutSkip
    1              0.000016   syn region	cCppInSkip	contained matchgroup=cCppInWrapper start="^\s*\(%:\|#\)\s*\(if\s\+\(\d\+\s*\($\|//\|/\*\||\|&\)\)\@!\|ifdef\>\|ifndef\>\)" skip="\\$" end="^\s*\(%:\|#\)\s*endif\>" containedin=cCppOutElse,cCppInIf,cCppInSkip contains=TOP,cPreProc
    1              0.000001 endif
    1              0.000007 syn region	cIncluded	display contained start=+"+ skip=+\\\\\|\\"+ end=+"+
    1              0.000003 syn match	cIncluded	display contained "<[^>]*>"
    1              0.000015 syn match	cInclude	display "^\s*\zs\(%:\|#\)\s*include\>\s*["<]" contains=cIncluded
                            "syn match cLineSkip	"\\$"
    1              0.000024 syn cluster	cPreProcGroup	contains=cPreCondit,cIncluded,cInclude,cDefine,cErrInParen,cErrInBracket,cUserLabel,cSpecial,cOctalZero,cCppOutWrapper,cCppInWrapper,@cCppOutInGroup,cFormat,cNumber,cFloat,cOctal,cOctalError,cNumbersCom,cString,cCommentSkip,cCommentString,cComment2String,@cCommentGroup,cCommentStartError,cParen,cBracket,cMulti,cBadBlock
    1              0.000008 syn region	cDefine		start="^\s*\zs\(%:\|#\)\s*\(define\|undef\)\>" skip="\\$" end="$" keepend contains=ALLBUT,@cPreProcGroup,@Spell
    1              0.000007 syn region	cPreProc	start="^\s*\zs\(%:\|#\)\s*\(pragma\>\|line\>\|warning\>\|warn\>\|error\>\)" skip="\\$" end="$" keepend contains=ALLBUT,@cPreProcGroup,@Spell
                            
                            " Optional embedded Autodoc parsing
    1              0.000002 if exists("c_autodoc")
                              syn match cAutodocReal display contained "\%(//\|[/ \t\v]\*\|^\*\)\@2<=!.*" contains=@cAutodoc containedin=cComment,cCommentL
                              syn cluster cCommentGroup add=cAutodocReal
                              syn cluster cPreProcGroup add=cAutodocReal
                            endif
                            
                            " Highlight User Labels
    1              0.000014 syn cluster	cMultiGroup	contains=cIncluded,cSpecial,cCommentSkip,cCommentString,cComment2String,@cCommentGroup,cCommentStartError,cUserCont,cUserLabel,cBitField,cOctalZero,cCppOutWrapper,cCppInWrapper,@cCppOutInGroup,cFormat,cNumber,cFloat,cOctal,cOctalError,cNumbersCom,cCppParen,cCppBracket,cCppString
    1              0.000003 if s:ft ==# 'c' || exists("cpp_no_cpp11")
                              syn region	cMulti		transparent start='?' skip='::' end=':' contains=ALLBUT,@cMultiGroup,@Spell,@cStringGroup
                            endif
                            " Avoid matching foo::bar() in C++ by requiring that the next char is not ':'
    1              0.000001 syn cluster	cLabelGroup	contains=cUserLabel
    1              0.000003 syn match	cUserCont	display "^\s*\zs\I\i*\s*:$" contains=@cLabelGroup
    1              0.000003 syn match	cUserCont	display ";\s*\zs\I\i*\s*:$" contains=@cLabelGroup
    1              0.000001 if s:ft ==# 'cpp'
    1              0.000005   syn match	cUserCont	display "^\s*\zs\%(class\|struct\|enum\)\@!\I\i*\s*:[^:]"me=e-1 contains=@cLabelGroup
    1              0.000010   syn match	cUserCont	display ";\s*\zs\%(class\|struct\|enum\)\@!\I\i*\s*:[^:]"me=e-1 contains=@cLabelGroup
    1              0.000001 else
                              syn match	cUserCont	display "^\s*\zs\I\i*\s*:[^:]"me=e-1 contains=@cLabelGroup
                              syn match	cUserCont	display ";\s*\zs\I\i*\s*:[^:]"me=e-1 contains=@cLabelGroup
                            endif
                            
    1              0.000002 syn match	cUserLabel	display "\I\i*" contained
                            
                            " Avoid recognizing most bitfields as labels
    1              0.000004 syn match	cBitField	display "^\s*\zs\I\i*\s*:\s*[1-9]"me=e-1 contains=cType
    1              0.000003 syn match	cBitField	display ";\s*\zs\I\i*\s*:\s*[1-9]"me=e-1 contains=cType
                            
    1              0.000002 if exists("c_minlines")
                              let b:c_minlines = c_minlines
                            else
    1              0.000001   if !exists("c_no_if0")
    1              0.000002     let b:c_minlines = 50	" #if 0 constructs can be long
    1              0.000001   else
                                let b:c_minlines = 15	" mostly for () constructs
                              endif
    1              0.000000 endif
    1              0.000002 if exists("c_curly_error")
                              syn sync fromstart
                            else
    1              0.000005   exec "syn sync ccomment cComment minlines=" . b:c_minlines
    1              0.000000 endif
                            
                            " Define the default highlighting.
                            " Only used when an item doesn't have highlighting yet
    1              0.000002 hi def link cFormat		cSpecial
    1              0.000001 hi def link cCppString		cString
    1              0.000001 hi def link cCommentL		cComment
    1              0.000001 hi def link cCommentStart	cComment
    1              0.000002 hi def link cLabel		Label
    1              0.000003 hi def link cUserLabel		Label
    1              0.000002 hi def link cConditional	Conditional
    1              0.000001 hi def link cRepeat		Repeat
    1              0.000002 hi def link cCharacter		Character
    1              0.000001 hi def link cSpecialCharacter	cSpecial
    1              0.000001 hi def link cNumber		Number
    1              0.000002 hi def link cOctal		Number
    1              0.000001 hi def link cOctalZero		PreProc	 " link this to Error if you want
    1              0.000002 hi def link cFloat		Float
    1              0.000002 hi def link cOctalError		cError
    1              0.000001 hi def link cParenError		cError
    1              0.000001 hi def link cErrInParen		cError
    1              0.000001 hi def link cErrInBracket	cError
    1              0.000001 hi def link cCommentError	cError
    1              0.000001 hi def link cCommentStartError	cError
    1              0.000001 hi def link cSpaceError		cError
    1              0.000001 hi def link cSpecialError	cError
    1              0.000000 hi def link cCurlyError		cError
    1              0.000002 hi def link cOperator		Operator
    1              0.000001 hi def link cStructure		Structure
    1              0.000002 hi def link cStorageClass	StorageClass
    1              0.000002 hi def link cInclude		Include
    1              0.000001 hi def link cPreProc		PreProc
    1              0.000002 hi def link cDefine		Macro
    1              0.000001 hi def link cIncluded		cString
    1              0.000001 hi def link cError		Error
    1              0.000002 hi def link cStatement		Statement
    1              0.000001 hi def link cCppInWrapper	cCppOutWrapper
    1              0.000001 hi def link cCppOutWrapper	cPreCondit
    1              0.000001 hi def link cPreConditMatch	cPreCondit
    1              0.000001 hi def link cPreCondit		PreCondit
    1              0.000002 hi def link cType		Type
    1              0.000002 hi def link cConstant		Constant
    1              0.000002 hi def link cCommentString	cString
    1              0.000001 hi def link cComment2String	cString
    1              0.000001 hi def link cCommentSkip	cComment
    1              0.000001 hi def link cString		String
    1              0.000002 hi def link cComment		Comment
    1              0.000001 hi def link cSpecial		SpecialChar
    1              0.000001 hi def link cTodo		Todo
    1              0.000002 hi def link cBadContinuation	Error
    1              0.000001 hi def link cCppOutSkip		cCppOutIf2
    1              0.000001 hi def link cCppInElse2		cCppOutIf2
    1              0.000002 hi def link cCppOutIf2		cCppOut
    1              0.000001 hi def link cCppOut		Comment
                            
    1              0.000001 let b:current_syntax = "c"
                            
    1              0.000002 unlet s:ft
                            
    1              0.000012 let &cpo = s:cpo_save
    1              0.000001 unlet s:cpo_save
                            " vim: ts=8

SCRIPT  /usr/share/vim/vim80/ftplugin/cpp.vim
Sourced 1 time
Total time:   0.000563
 Self time:   0.000470

count  total (s)   self (s)
                            " Vim filetype plugin file
                            " Language:	C++
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2001 Jan 15
                            
                            " Only do this when not done yet for this buffer
    1              0.000003 if exists("b:did_ftplugin")
                              finish
                            endif
                            
                            " Behaves just like C
    1   0.000553   0.000460 runtime! ftplugin/c.vim ftplugin/c_*.vim ftplugin/c/*.vim

SCRIPT  /usr/share/vim/vim80/ftplugin/c.vim
Sourced 1 time
Total time:   0.000086
 Self time:   0.000086

count  total (s)   self (s)
                            " Vim filetype plugin file
                            " Language:	C
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2017 Sep 28
                            
                            " Only do this when not done yet for this buffer
    1              0.000003 if exists("b:did_ftplugin")
                              finish
                            endif
                            
                            " Don't load another plugin for this buffer
    1              0.000002 let b:did_ftplugin = 1
                            
                            " Using line continuation here.
    1              0.000005 let s:cpo_save = &cpo
    1              0.000008 set cpo-=C
                            
    1              0.000002 let b:undo_ftplugin = "setl fo< com< ofu< | if has('vms') | setl isk< | endif"
                            
                            " Set 'formatoptions' to break comment lines but not other lines,
                            " and insert the comment leader when hitting <CR> or using "o".
    1              0.000010 setlocal fo-=t fo+=croql
                            
                            " Set completion with CTRL-X CTRL-O to autoloaded function.
    1              0.000003 if exists('&ofu')
    1              0.000004   setlocal ofu=ccomplete#Complete
    1              0.000001 endif
                            
                            " Set 'comments' to format dashed lists in comments.
    1              0.000003 setlocal comments=sO:*\ -,mO:*\ \ ,exO:*/,s1:/*,mb:*,ex:*/,://
                            
                            " In VMS C keywords contain '$' characters.
    1              0.000004 if has("vms")
                              setlocal iskeyword+=$
                            endif
                            
                            " When the matchit plugin is loaded, this makes the % command skip parens and
                            " braces in comments properly.
    1              0.000002 let b:match_words = '^\s*#\s*if\(\|def\|ndef\)\>:^\s*#\s*elif\>:^\s*#\s*else\>:^\s*#\s*endif\>'
    1              0.000001 let b:match_skip = 's:comment\|string\|character\|special'
                            
                            " Win32 can filter files in the browse dialog
    1              0.000004 if (has("gui_win32") || has("gui_gtk")) && !exists("b:browsefilter")
                              if &ft == "cpp"
                                let b:browsefilter = "C++ Source Files (*.cpp *.c++)\t*.cpp;*.c++\n" .
                            	  \ "C Header Files (*.h)\t*.h\n" .
                            	  \ "C Source Files (*.c)\t*.c\n" .
                            	  \ "All Files (*.*)\t*.*\n"
                              elseif &ft == "ch"
                                let b:browsefilter = "Ch Source Files (*.ch *.chf)\t*.ch;*.chf\n" .
                            	  \ "C Header Files (*.h)\t*.h\n" .
                            	  \ "C Source Files (*.c)\t*.c\n" .
                            	  \ "All Files (*.*)\t*.*\n"
                              else
                                let b:browsefilter = "C Source Files (*.c)\t*.c\n" .
                            	  \ "C Header Files (*.h)\t*.h\n" .
                            	  \ "Ch Source Files (*.ch *.chf)\t*.ch;*.chf\n" .
                            	  \ "C++ Source Files (*.cpp *.c++)\t*.cpp;*.c++\n" .
                            	  \ "All Files (*.*)\t*.*\n"
                              endif
                            endif
                            
    1              0.000011 let &cpo = s:cpo_save
    1              0.000001 unlet s:cpo_save

SCRIPT  /usr/share/vim/vim80/indent/cpp.vim
Sourced 1 time
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
                            " Vim indent file
                            " Language:	C++
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2008 Nov 29
                            
                            " Only load this indent file when no other was loaded.
    1              0.000003 if exists("b:did_indent")
                               finish
                            endif
    1              0.000002 let b:did_indent = 1
                            
                            " C++ indenting is built-in, thus this is very simple
    1              0.000004 setlocal cindent
                            
    1              0.000002 let b:undo_indent = "setl cin<"

SCRIPT  /home/curusarn/.vim/bundle/vim-gitgutter/autoload/gitgutter/diff.vim
Sourced 1 time
Total time:   0.003757
 Self time:   0.000289

count  total (s)   self (s)
    1              0.000004 if exists('g:gitgutter_grep_command')
                              let s:grep_available = 1
                              let s:grep_command = g:gitgutter_grep_command
                            else
    1              0.000011   let s:grep_available = executable('grep')
    1              0.000001   if s:grep_available
    1              0.000001     let s:grep_command = 'grep'
    1              0.000004     if $GREP_OPTIONS =~# '--color=always'
                                  let s:grep_command .= ' --color=never'
                                endif
    1              0.000000   endif
    1              0.000001 endif
    1              0.000002 let s:hunk_re = '^@@ -\(\d\+\),\?\(\d*\) +\(\d\+\),\?\(\d*\) @@'
                            
    1   0.003485   0.000017 let s:c_flag = gitgutter#utility#git_supports_command_line_config_override()
                            
    1              0.000007 let s:temp_index = tempname()
    1              0.000002 let s:temp_buffer = tempname()
                            
                            " Returns a diff of the buffer.
                            "
                            " The way to get the diff depends on whether the buffer is saved or unsaved.
                            "
                            " * Saved: the buffer contents is the same as the file on disk in the working
                            "   tree so we simply do:
                            "
                            "       git diff myfile
                            "
                            " * Unsaved: the buffer contents is not the same as the file on disk so we
                            "   need to pass two instances of the file to git-diff:
                            "
                            "       git diff myfileA myfileB
                            "
                            "   The first instance is the file in the index which we obtain with:
                            "
                            "       git show :myfile > myfileA
                            "
                            "   The second instance is the buffer contents.  Ideally we would pass this to
                            "   git-diff on stdin via the second argument to vim's system() function.
                            "   Unfortunately git-diff does not do CRLF conversion for input received on
                            "   stdin, and git-show never performs CRLF conversion, so repos with CRLF
                            "   conversion report that every line is modified due to mismatching EOLs.
                            "
                            "   Instead, we write the buffer contents to a temporary file - myfileB in this
                            "   example.  Note the file extension must be preserved for the CRLF
                            "   conversion to work.
                            "
                            " Before diffing a buffer for the first time, we check whether git knows about
                            " the file:
                            "
                            "     git ls-files --error-unmatch myfile
                            "
                            " After running the diff we pass it through grep where available to reduce
                            " subsequent processing by the plugin.  If grep is not available the plugin
                            " does the filtering instead.
    1              0.000008 function! gitgutter#diff#run_diff(realtime, preserve_full_diff) abort
                              " Wrap compound commands in parentheses to make Windows happy.
                              " bash doesn't mind the parentheses.
                              let cmd = '('
                            
                              let bufnr = gitgutter#utility#bufnr()
                              let tracked = gitgutter#utility#getbufvar(bufnr, 'tracked', 0)  " i.e. tracked by git
                              if !tracked
                                " Don't bother trying to realtime-diff an untracked file.
                                " NOTE: perhaps we should pull this guard up to the caller?
                                if a:realtime
                                  throw 'diff failed'
                                else
                                  let cmd .= g:gitgutter_git_executable.' ls-files --error-unmatch '.gitgutter#utility#shellescape(gitgutter#utility#filename()).' && ('
                                endif
                              endif
                            
                              if a:realtime
                                let blob_name = g:gitgutter_diff_base.':'.gitgutter#utility#shellescape(gitgutter#utility#file_relative_to_repo_root())
                                let blob_file = s:temp_index
                                let buff_file = s:temp_buffer
                                let extension = gitgutter#utility#extension()
                                if !empty(extension)
                                  let blob_file .= '.'.extension
                                  let buff_file .= '.'.extension
                                endif
                                let cmd .= g:gitgutter_git_executable.' show '.blob_name.' > '.blob_file.' && '
                            
                                " Writing the whole buffer resets the '[ and '] marks and also the
                                " 'modified' flag (if &cpoptions includes '+').  These are unwanted
                                " side-effects so we save and restore the values ourselves.
                                let modified      = getbufvar(bufnr, "&mod")
                                let op_mark_start = getpos("'[")
                                let op_mark_end   = getpos("']")
                            
                                let current_buffer = bufnr('')
                                execute 'buffer '.bufnr
                                execute 'keepalt noautocmd silent write!' buff_file
                                execute 'buffer '.current_buffer
                            
                                call setbufvar(bufnr, "&mod", modified)
                                call setpos("'[", op_mark_start)
                                call setpos("']", op_mark_end)
                              endif
                            
                              let cmd .= g:gitgutter_git_executable
                              if s:c_flag
                                let cmd .= ' -c "diff.autorefreshindex=0"'
                                let cmd .= ' -c "diff.noprefix=false"'
                              endif
                              let cmd .= ' diff --no-ext-diff --no-color -U0 '.g:gitgutter_diff_args.' '
                            
                              if a:realtime
                                let cmd .= ' -- '.blob_file.' '.buff_file
                              else
                                let cmd .= g:gitgutter_diff_base.' -- '.gitgutter#utility#shellescape(gitgutter#utility#filename())
                              endif
                            
                              if !a:preserve_full_diff && s:grep_available
                                let cmd .= ' | '.s:grep_command.' '.gitgutter#utility#shellescape('^@@ ')
                              endif
                            
                              if (!a:preserve_full_diff && s:grep_available) || a:realtime
                                " grep exits with 1 when no matches are found; diff exits with 1 when
                                " differences are found.  However we want to treat non-matches and
                                " differences as non-erroneous behaviour; so we OR the command with one
                                " which always exits with success (0).
                                let cmd .= ' || exit 0'
                              endif
                            
                              let cmd .= ')'
                            
                              if !tracked
                                let cmd .= ')'
                              endif
                            
                              let cmd = gitgutter#utility#command_in_directory_of_file(cmd)
                            
                              if g:gitgutter_async && gitgutter#async#available() && !a:preserve_full_diff
                                call gitgutter#async#execute(cmd)
                                return 'async'
                            
                              else
                                let diff = gitgutter#utility#system(cmd)
                            
                                if gitgutter#utility#shell_error()
                                  " A shell error indicates the file is not tracked by git (unless something bizarre is going on).
                                  throw 'diff failed'
                                endif
                            
                                return diff
                              endif
                            endfunction
                            
    1              0.000002 function! gitgutter#diff#parse_diff(diff) abort
                              let hunks = []
                              for line in split(a:diff, '\n')
                                let hunk_info = gitgutter#diff#parse_hunk(line)
                                if len(hunk_info) == 4
                                  call add(hunks, hunk_info)
                                endif
                              endfor
                              return hunks
                            endfunction
                            
    1              0.000001 function! gitgutter#diff#parse_hunk(line) abort
                              let matches = matchlist(a:line, s:hunk_re)
                              if len(matches) > 0
                                let from_line  = str2nr(matches[1])
                                let from_count = (matches[2] == '') ? 1 : str2nr(matches[2])
                                let to_line    = str2nr(matches[3])
                                let to_count   = (matches[4] == '') ? 1 : str2nr(matches[4])
                                return [from_line, from_count, to_line, to_count]
                              else
                                return []
                              end
                            endfunction
                            
    1              0.000001 function! gitgutter#diff#process_hunks(hunks) abort
                              let modified_lines = []
                              for hunk in a:hunks
                                call extend(modified_lines, gitgutter#diff#process_hunk(hunk))
                              endfor
                              return modified_lines
                            endfunction
                            
                            " Returns [ [<line_number (number)>, <name (string)>], ...]
    1              0.000001 function! gitgutter#diff#process_hunk(hunk) abort
                              let modifications = []
                              let from_line  = a:hunk[0]
                              let from_count = a:hunk[1]
                              let to_line    = a:hunk[2]
                              let to_count   = a:hunk[3]
                            
                              if gitgutter#diff#is_added(from_count, to_count)
                                call gitgutter#diff#process_added(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_added(to_count)
                            
                              elseif gitgutter#diff#is_removed(from_count, to_count)
                                call gitgutter#diff#process_removed(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_removed(from_count)
                            
                              elseif gitgutter#diff#is_modified(from_count, to_count)
                                call gitgutter#diff#process_modified(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_modified(to_count)
                            
                              elseif gitgutter#diff#is_modified_and_added(from_count, to_count)
                                call gitgutter#diff#process_modified_and_added(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_added(to_count - from_count)
                                call gitgutter#hunk#increment_lines_modified(from_count)
                            
                              elseif gitgutter#diff#is_modified_and_removed(from_count, to_count)
                                call gitgutter#diff#process_modified_and_removed(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_modified(to_count)
                                call gitgutter#hunk#increment_lines_removed(from_count - to_count)
                            
                              endif
                              return modifications
                            endfunction
                            
    1              0.000002 function! gitgutter#diff#is_added(from_count, to_count) abort
                              return a:from_count == 0 && a:to_count > 0
                            endfunction
                            
    1              0.000002 function! gitgutter#diff#is_removed(from_count, to_count) abort
                              return a:from_count > 0 && a:to_count == 0
                            endfunction
                            
    1              0.000001 function! gitgutter#diff#is_modified(from_count, to_count) abort
                              return a:from_count > 0 && a:to_count > 0 && a:from_count == a:to_count
                            endfunction
                            
    1              0.000001 function! gitgutter#diff#is_modified_and_added(from_count, to_count) abort
                              return a:from_count > 0 && a:to_count > 0 && a:from_count < a:to_count
                            endfunction
                            
    1              0.000002 function! gitgutter#diff#is_modified_and_removed(from_count, to_count) abort
                              return a:from_count > 0 && a:to_count > 0 && a:from_count > a:to_count
                            endfunction
                            
    1              0.000002 function! gitgutter#diff#process_added(modifications, from_count, to_count, to_line) abort
                              let offset = 0
                              while offset < a:to_count
                                let line_number = a:to_line + offset
                                call add(a:modifications, [line_number, 'added'])
                                let offset += 1
                              endwhile
                            endfunction
                            
    1              0.000002 function! gitgutter#diff#process_removed(modifications, from_count, to_count, to_line) abort
                              if a:to_line == 0
                                call add(a:modifications, [1, 'removed_first_line'])
                              else
                                call add(a:modifications, [a:to_line, 'removed'])
                              endif
                            endfunction
                            
    1              0.000001 function! gitgutter#diff#process_modified(modifications, from_count, to_count, to_line) abort
                              let offset = 0
                              while offset < a:to_count
                                let line_number = a:to_line + offset
                                call add(a:modifications, [line_number, 'modified'])
                                let offset += 1
                              endwhile
                            endfunction
                            
    1              0.000002 function! gitgutter#diff#process_modified_and_added(modifications, from_count, to_count, to_line) abort
                              let offset = 0
                              while offset < a:from_count
                                let line_number = a:to_line + offset
                                call add(a:modifications, [line_number, 'modified'])
                                let offset += 1
                              endwhile
                              while offset < a:to_count
                                let line_number = a:to_line + offset
                                call add(a:modifications, [line_number, 'added'])
                                let offset += 1
                              endwhile
                            endfunction
                            
    1              0.000001 function! gitgutter#diff#process_modified_and_removed(modifications, from_count, to_count, to_line) abort
                              let offset = 0
                              while offset < a:to_count
                                let line_number = a:to_line + offset
                                call add(a:modifications, [line_number, 'modified'])
                                let offset += 1
                              endwhile
                              let a:modifications[-1] = [a:to_line + offset - 1, 'modified_removed']
                            endfunction
                            
                            " Generates a zero-context diff for the current hunk.
                            "
                            " diff - the full diff for the buffer
                            " type - stage | undo | preview
    1              0.000002 function! gitgutter#diff#generate_diff_for_hunk(diff, type) abort
                              let diff_for_hunk = gitgutter#diff#discard_hunks(a:diff, a:type == 'stage' || a:type == 'undo')
                            
                              if a:type == 'stage' || a:type == 'undo'
                                let diff_for_hunk = gitgutter#diff#adjust_hunk_summary(diff_for_hunk, a:type == 'stage')
                              endif
                            
                              return diff_for_hunk
                            endfunction
                            
                            " Returns the diff with all hunks discarded except the current.
                            "
                            " diff        - the diff to process
                            " keep_header - truthy to keep the diff header and hunk summary, falsy to discard it
    1              0.000002 function! gitgutter#diff#discard_hunks(diff, keep_header) abort
                              let modified_diff = []
                              let keep_line = a:keep_header
                              for line in split(a:diff, '\n')
                                let hunk_info = gitgutter#diff#parse_hunk(line)
                                if len(hunk_info) == 4  " start of new hunk
                                  let keep_line = gitgutter#hunk#cursor_in_hunk(hunk_info)
                                endif
                                if keep_line
                                  call add(modified_diff, line)
                                endif
                              endfor
                            
                              if a:keep_header
                                return gitgutter#utility#stringify(modified_diff)
                              else
                                " Discard hunk summary too.
                                return gitgutter#utility#stringify(modified_diff[1:])
                              endif
                            endfunction
                            
                            " Adjust hunk summary (from's / to's line number) to ignore changes above/before this one.
                            "
                            " diff_for_hunk - a diff containing only the hunk of interest
                            " staging       - truthy if the hunk is to be staged, falsy if it is to be undone
                            "
                            " TODO: push this down to #discard_hunks?
    1              0.000002 function! gitgutter#diff#adjust_hunk_summary(diff_for_hunk, staging) abort
                              let line_adjustment = gitgutter#hunk#line_adjustment_for_current_hunk()
                              let adj_diff = []
                              for line in split(a:diff_for_hunk, '\n')
                                if match(line, s:hunk_re) != -1
                                  if a:staging
                                    " increment 'to' line number
                                    let line = substitute(line, '+\@<=\(\d\+\)', '\=submatch(1)+line_adjustment', '')
                                  else
                                    " decrement 'from' line number
                                    let line = substitute(line, '-\@<=\(\d\+\)', '\=submatch(1)-line_adjustment', '')
                                  endif
                                endif
                                call add(adj_diff, line)
                              endfor
                              return gitgutter#utility#stringify(adj_diff)
                            endfunction
                            

SCRIPT  /home/curusarn/.vim/bundle/vim-gitgutter/autoload/gitgutter/async.vim
Sourced 1 time
Total time:   0.000072
 Self time:   0.000072

count  total (s)   self (s)
    1              0.000012 let s:available = has('nvim') || (
                                  \   has('job') && (
                                  \     (has('patch-7-4-1826') && !has('gui_running')) ||
                                  \     (has('patch-7-4-1850') &&  has('gui_running')) ||
                                  \     (has('patch-7-4-1832') &&  has('gui_macvim'))
                                  \   )
                                  \ )
                            
    1              0.000001 function! gitgutter#async#available()
                              return s:available
                            endfunction
                            
                            
    1              0.000001 function! gitgutter#async#execute(cmd) abort
                              let options = {
                                    \   'stdoutbuffer': [],
                                    \   'buffer': gitgutter#utility#bufnr()
                                    \ }
                              let command = s:build_command(a:cmd)
                            
                              if has('nvim')
                                call jobstart(command, extend(options, {
                                      \   'on_stdout': function('s:on_stdout_nvim'),
                                      \   'on_stderr': function('s:on_stderr_nvim'),
                                      \   'on_exit':   function('s:on_exit_nvim')
                                      \ }))
                              else
                                call job_start(command, {
                                      \   'out_cb':   function('s:on_stdout_vim', options),
                                      \   'err_cb':   function('s:on_stderr_vim', options),
                                      \   'close_cb': function('s:on_exit_vim', options)
                                      \ })
                              endif
                            endfunction
                            
                            
    1              0.000002 function! s:build_command(cmd)
                              if has('unix')
                                return ['sh', '-c', a:cmd]
                              endif
                            
                              if has('win32')
                                return has('nvim') ? ['cmd.exe', '/c', a:cmd] : 'cmd.exe /c '.a:cmd
                              endif
                            
                              throw 'unknown os'
                            endfunction
                            
                            
    1              0.000002 function! s:on_stdout_nvim(_job_id, data, _event) dict abort
                              if empty(self.stdoutbuffer)
                                let self.stdoutbuffer = a:data
                              else
                                let self.stdoutbuffer = self.stdoutbuffer[:-2] +
                                      \ [self.stdoutbuffer[-1] . a:data[0]] +
                                      \ a:data[1:]
                              endif
                            endfunction
                            
    1              0.000001 function! s:on_stderr_nvim(_job_id, _data, _event) dict abort
                              " Backward compatibility for nvim < 0.2.0
                              if !has('nvim-0.2.0')
                                let current_buffer = gitgutter#utility#bufnr()
                                call gitgutter#utility#set_buffer(self.buffer)
                                if gitgutter#utility#is_active()
                                  call gitgutter#hunk#reset()
                                endif
                                call gitgutter#utility#set_buffer(current_buffer)
                                return
                              endif
                            
                              call s:buffer_exec(self.buffer, function('gitgutter#hunk#reset'))
                            endfunction
                            
    1              0.000001 function! s:on_exit_nvim(_job_id, _data, _event) dict abort
                              " Backward compatibility for nvim < 0.2.0
                              if !has('nvim-0.2.0')
                                let current_buffer = gitgutter#utility#bufnr()
                                call gitgutter#utility#set_buffer(self.buffer)
                                if gitgutter#utility#is_active()
                                  call gitgutter#handle_diff(gitgutter#utility#stringify(self.stdoutbuffer))
                                endif
                                call gitgutter#utility#set_buffer(current_buffer)
                                return
                              endif
                            
                              call s:buffer_exec(self.buffer, function('gitgutter#handle_diff', [gitgutter#utility#stringify(self.stdoutbuffer)]))
                            endfunction
                            
                            
    1              0.000002 function! s:on_stdout_vim(_channel, data) dict abort
                              call add(self.stdoutbuffer, a:data)
                            endfunction
                            
    1              0.000001 function! s:on_stderr_vim(_channel, _data) dict abort
                              call s:buffer_exec(self.buffer, function('gitgutter#hunk#reset'))
                            endfunction
                            
    1              0.000002 function! s:on_exit_vim(_channel) dict abort
                              call s:buffer_exec(self.buffer, function('gitgutter#handle_diff', [gitgutter#utility#stringify(self.stdoutbuffer)]))
                            endfunction
                            
                            
    1              0.000001 function! s:buffer_exec(buffer, fn)
                              let current_buffer = gitgutter#utility#bufnr()
                              call gitgutter#utility#set_buffer(a:buffer)
                            
                              if gitgutter#utility#is_active()
                                call a:fn()
                              endif
                            
                              call gitgutter#utility#set_buffer(current_buffer)
                            endfunction

SCRIPT  /home/curusarn/.vim/bundle/syntastic/syntax_checkers/cpp/avrgcc.vim
Sourced 1 time
Total time:   0.003097
 Self time:   0.000027

count  total (s)   self (s)
                            "============================================================================
                            "File:        avrgcc.vim
                            "Description: Syntax checking plugin for syntastic
                            "Maintainer:  Sawek Piotrowski <sentinel at atteo dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "
                            "============================================================================
                            
    1              0.000004 if exists('g:loaded_syntastic_cpp_avrgcc_checker')
                                finish
                            endif
    1              0.000002 let g:loaded_syntastic_cpp_avrgcc_checker = 1
                            
    1   0.003079   0.000009 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'cpp',
                                \ 'name': 'avrgcc',
                                \ 'exec': 'avr-g++',
                                \ 'redirect': 'c/avrgcc'})
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/curusarn/.vim/bundle/syntastic/syntax_checkers/c/avrgcc.vim
Sourced 8 times
Total time:   0.000263
 Self time:   0.000152

count  total (s)   self (s)
                            "============================================================================
                            "File:        avrgcc.vim
                            "Description: Syntax checking plugin for syntastic
                            "Maintainer:  Karel <karelishere at gmail dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "
                            "============================================================================
                            
    8              0.000026 if exists('g:loaded_syntastic_c_avrgcc_checker')
    7              0.000007     finish
                            endif
    1              0.000002 let g:loaded_syntastic_c_avrgcc_checker = 1
                            
    1              0.000002 if !exists('g:syntastic_avrgcc_config_file')
    1              0.000002     let g:syntastic_avrgcc_config_file = '.syntastic_avrgcc_config'
    1              0.000001 endif
                            
    1              0.000010 let s:save_cpo = &cpo
    1              0.000014 set cpo&vim
                            
    1              0.000002 let s:opt_x = { 'c': 'c', 'cpp': 'c++' }
                            
    1              0.000003 function! SyntaxCheckers_c_avrgcc_GetLocList() dict
                                let makeprg = self.makeprgBuild({
                                    \ 'args_before': syntastic#c#ReadConfig(g:syntastic_avrgcc_config_file),
                                    \ 'args_after': '-x ' . get(s:opt_x, self.getFiletype(), '')  . ' -fsyntax-only' })
                            
                                let errorformat =
                                    \ '%-G%f:%s:,' .
                                    \ '%-G%f:%l: %#error: %#(Each undeclared identifier is reported only%.%#,' .
                                    \ '%-G%f:%l: %#error: %#for each function it appears%.%#,' .
                                    \ '%-GIn file included%.%#,' .
                                    \ '%-G %#from %f:%l\,,' .
                                    \ '%f:%l:%c: %trror: %m,' .
                                    \ '%f:%l:%c: %tarning: %m,' .
                                    \ '%f:%l:%c: %m,' .
                                    \ '%f:%l: %trror: %m,' .
                                    \ '%f:%l: %tarning: %m,'.
                                    \ '%f:%l: %m'
                            
                                return SyntasticMake({
                                    \ 'makeprg': makeprg,
                                    \ 'errorformat': errorformat,
                                    \ 'postprocess': ['compressWhitespace'] })
                            endfunction
                            
    1   0.000116   0.000005 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'c',
                                \ 'name': 'avrgcc',
                                \ 'exec': 'avr-gcc'})
                            
    1              0.000011 let &cpo = s:save_cpo
    1              0.000002 unlet s:save_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/curusarn/.vim/bundle/syntastic/syntax_checkers/c/checkpatch.vim
Sourced 8 times
Total time:   0.000205
 Self time:   0.000114

count  total (s)   self (s)
                            "============================================================================
                            "File:        checkpatch.vim
                            "Description: Syntax checking plugin for syntastic using checkpatch.pl
                            "Maintainer:  Daniel Walker <dwalker at fifo99 dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "============================================================================
                            
    8              0.000022 if exists('g:loaded_syntastic_c_checkpatch_checker')
    7              0.000006     finish
                            endif
    1              0.000002 let g:loaded_syntastic_c_checkpatch_checker = 1
                            
    1              0.000006 let s:save_cpo = &cpo
    1              0.000006 set cpo&vim
                            
    1              0.000002 function! SyntaxCheckers_c_checkpatch_IsAvailable() dict
                                call syntastic#log#deprecationWarn('c_checker_checkpatch_location', 'c_checkpatch_exec')
                            
                                if !exists('g:syntastic_c_checkpatch_exec') && !executable(self.getExec())
                                    if executable('checkpatch')
                                        let g:syntastic_c_checkpatch_exec = 'checkpatch'
                                    elseif executable('./scripts/checkpatch.pl')
                                        let g:syntastic_c_checkpatch_exec = fnamemodify('./scripts/checkpatch.pl', ':p')
                                    elseif executable('./scripts/checkpatch')
                                        let g:syntastic_c_checkpatch_exec = fnamemodify('./scripts/checkpatch', ':p')
                                    endif
                                endif
                            
                                call self.log('exec =', self.getExec())
                            
                                return executable(self.getExec())
                            endfunction
                            
    1              0.000001 function! SyntaxCheckers_c_checkpatch_GetLocList() dict
                                let makeprg = self.makeprgBuild({ 'args_after': '--no-summary --no-tree --terse --file' })
                            
                                let errorformat =
                                    \ '%f:%l: %tARNING: %m,' .
                                    \ '%f:%l: %tRROR: %m'
                            
                                return SyntasticMake({
                                    \ 'makeprg': makeprg,
                                    \ 'errorformat': errorformat,
                                    \ 'returns': [0, 1],
                                    \ 'subtype': 'Style' })
                            endfunction
                            
    1   0.000097   0.000006 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'c',
                                \ 'name': 'checkpatch',
                                \ 'exec': 'checkpatch.pl'})
                            
    1              0.000006 let &cpo = s:save_cpo
    1              0.000001 unlet s:save_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/curusarn/.vim/bundle/syntastic/syntax_checkers/c/clang_check.vim
Sourced 8 times
Total time:   0.000274
 Self time:   0.000130

count  total (s)   self (s)
                            "============================================================================
                            "File:        clang_check.vim
                            "Description: Syntax checking plugin for syntastic
                            "Maintainer:  Benjamin Bannier <bbannier at gmail dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "============================================================================
                            
    8              0.000021 if exists('g:loaded_syntastic_c_clang_check_checker')
    7              0.000006     finish
                            endif
    1              0.000002 let g:loaded_syntastic_c_clang_check_checker = 1
                            
    1              0.000002 if !exists('g:syntastic_clang_check_config_file')
    1              0.000002     let g:syntastic_clang_check_config_file = '.syntastic_clang_check_config'
    1              0.000001 endif
                            
    1              0.000002 if !exists('g:syntastic_c_clang_check_sort')
    1              0.000001     let g:syntastic_c_clang_check_sort = 1
    1              0.000001 endif
                            
    1              0.000008 let s:save_cpo = &cpo
    1              0.000010 set cpo&vim
                            
    1              0.000002 function! SyntaxCheckers_c_clang_check_GetLocList() dict
                                let makeprg = self.makeprgBuild({
                                    \ 'post_args':
                                    \   '-- ' .
                                    \   syntastic#c#ReadConfig(g:syntastic_clang_check_config_file) . ' ' .
                                    \   '-fshow-column ' .
                                    \   '-fshow-source-location ' .
                                    \   '-fno-caret-diagnostics ' .
                                    \   '-fno-color-diagnostics ' .
                                    \   '-fdiagnostics-format=clang' })
                            
                                let errorformat =
                                    \ '%E%f:%l:%c: fatal error: %m,' .
                                    \ '%E%f:%l:%c: error: %m,' .
                                    \ '%W%f:%l:%c: warning: %m,' .
                                    \ '%-G%\m%\%%(LLVM ERROR:%\|No compilation database found%\)%\@!%.%#,' .
                                    \ '%E%m'
                            
                                let env = syntastic#util#isRunningWindows() ? {} : { 'TERM': 'dumb' }
                            
                                return SyntasticMake({
                                    \ 'makeprg': makeprg,
                                    \ 'errorformat': errorformat,
                                    \ 'env': env,
                                    \ 'defaults': {'bufnr': bufnr('')},
                                    \ 'returns': [0, 1] })
                            endfunction
                            
    1   0.000149   0.000005 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'c',
                                \ 'name': 'clang_check',
                                \ 'exec': 'clang-check'})
                            
    1              0.000014 let &cpo = s:save_cpo
    1              0.000002 unlet s:save_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/curusarn/.vim/bundle/syntastic/syntax_checkers/c/clang_tidy.vim
Sourced 8 times
Total time:   0.000287
 Self time:   0.000139

count  total (s)   self (s)
                            "============================================================================
                            "File:        clang_tidy.vim
                            "Description: Syntax checking plugin for syntastic
                            "Maintainer:  Benjamin Bannier <bbannier at gmail dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "============================================================================
                            
    8              0.000025 if exists('g:loaded_syntastic_c_clang_tidy_checker')
    7              0.000005     finish
                            endif
    1              0.000003 let g:loaded_syntastic_c_clang_tidy_checker = 1
                            
    1              0.000004 if !exists('g:syntastic_clang_tidy_config_file')
    1              0.000003     let g:syntastic_clang_tidy_config_file = '.syntastic_clang_tidy_config'
    1              0.000001 endif
                            
    1              0.000003 if !exists('g:syntastic_c_clang_tidy_sort')
    1              0.000002     let g:syntastic_c_clang_tidy_sort = 1
    1              0.000001 endif
                            
    1              0.000007 let s:save_cpo = &cpo
    1              0.000009 set cpo&vim
                            
    1              0.000003 function! SyntaxCheckers_c_clang_tidy_GetLocList() dict
                                let makeprg = self.makeprgBuild({
                                    \ 'post_args':
                                    \   '-- ' .
                                    \   syntastic#c#ReadConfig(g:syntastic_clang_tidy_config_file) . ' ' .
                                    \   '-fshow-column ' .
                                    \   '-fshow-source-location ' .
                                    \   '-fno-caret-diagnostics ' .
                                    \   '-fno-color-diagnostics ' .
                                    \   '-fdiagnostics-format=clang' })
                            
                                let errorformat =
                                    \ '%E%f:%l:%c: fatal error: %m,' .
                                    \ '%E%f:%l:%c: error: %m,' .
                                    \ '%W%f:%l:%c: warning: %m,' .
                                    \ '%-G%\m%\%%(LLVM ERROR:%\|No compilation database found%\)%\@!%.%#,' .
                                    \ '%E%m'
                            
                                let env = syntastic#util#isRunningWindows() ? {} : { 'TERM': 'dumb' }
                            
                                return SyntasticMake({
                                    \ 'makeprg': makeprg,
                                    \ 'errorformat': errorformat,
                                    \ 'env': env,
                                    \ 'defaults': {'bufnr': bufnr('')},
                                    \ 'returns': [0, 1] })
                            endfunction
                            
    1   0.000155   0.000007 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'c',
                                \ 'name': 'clang_tidy',
                                \ 'exec': 'clang-tidy'})
                            
    1              0.000008 let &cpo = s:save_cpo
    1              0.000001 unlet s:save_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/curusarn/.vim/bundle/syntastic/syntax_checkers/c/cppcheck.vim
Sourced 8 times
Total time:   0.000217
 Self time:   0.000124

count  total (s)   self (s)
                            "============================================================================
                            "File:        cppcheck.vim
                            "Description: Syntax checking plugin for syntastic using cppcheck.pl
                            "Maintainer:  LCD 47 <lcd047 at gmail dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "============================================================================
                            
    8              0.000023 if exists('g:loaded_syntastic_c_cppcheck_checker')
    7              0.000006     finish
                            endif
    1              0.000003 let g:loaded_syntastic_c_cppcheck_checker = 1
                            
    1              0.000002 if !exists('g:syntastic_cppcheck_config_file')
    1              0.000002     let g:syntastic_cppcheck_config_file = '.syntastic_cppcheck_config'
    1              0.000000 endif
                            
    1              0.000010 let s:save_cpo = &cpo
    1              0.000010 set cpo&vim
                            
    1              0.000002 function! SyntaxCheckers_c_cppcheck_GetLocList() dict
                                let makeprg = self.makeprgBuild({
                                    \ 'args': syntastic#c#ReadConfig(g:syntastic_cppcheck_config_file),
                                    \ 'args_after': '-q --enable=style' })
                            
                                let errorformat =
                                    \ '[%f:%l]: (%trror) %m,' .
                                    \ '[%f:%l]: (%tarning) %m,' .
                                    \ '[%f:%l]: (%ttyle) %m,' .
                                    \ '[%f:%l]: (%terformance) %m,' .
                                    \ '[%f:%l]: (%tortability) %m,' .
                                    \ '[%f:%l]: (%tnformation) %m,' .
                                    \ '[%f:%l]: (%tnconclusive) %m,' .
                                    \ '%-G%.%#'
                            
                                let loclist = SyntasticMake({
                                    \ 'makeprg': makeprg,
                                    \ 'errorformat': errorformat,
                                    \ 'preprocess': 'cppcheck',
                                    \ 'returns': [0] })
                            
                                for e in loclist
                                    if e['type'] =~? '\m^[SPI]'
                                        let e['type'] = 'w'
                                        let e['subtype'] = 'Style'
                                    endif
                                endfor
                            
                                return loclist
                            endfunction
                            
    1   0.000097   0.000004 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'c',
                                \ 'name': 'cppcheck'})
                            
    1              0.000010 let &cpo = s:save_cpo
    1              0.000001 unlet s:save_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/curusarn/.vim/bundle/syntastic/syntax_checkers/c/cppclean.vim
Sourced 8 times
Total time:   0.000200
 Self time:   0.000113

count  total (s)   self (s)
                            "============================================================================
                            "File:        cppclean.vim
                            "Description: Syntax checking plugin for syntastic
                            "Maintainer:  LCD 47 <lcd047 at gmail dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "
                            "============================================================================
                            
    8              0.000020 if exists('g:loaded_syntastic_c_cppclean_checker')
    7              0.000005     finish
                            endif
    1              0.000002 let g:loaded_syntastic_c_cppclean_checker = 1
                            
    1              0.000005 let s:save_cpo = &cpo
    1              0.000010 set cpo&vim
                            
    1              0.000002 function! SyntaxCheckers_c_cppclean_GetLocList() dict
                                let makeprg = self.makeprgBuild({})
                            
                                let errorformat = '%f:%l: %m'
                            
                                return SyntasticMake({
                                    \ 'makeprg': makeprg,
                                    \ 'errorformat': errorformat,
                                    \ 'subtype': 'Style',
                                    \ 'returns': [0, 1] })
                            endfunction
                            
    1   0.000092   0.000005 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'c',
                                \ 'name': 'cppclean' })
                            
    1              0.000010 let &cpo = s:save_cpo
    1              0.000001 unlet s:save_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/curusarn/.vim/bundle/syntastic/syntax_checkers/c/flawfinder.vim
Sourced 8 times
Total time:   0.000217
 Self time:   0.000127

count  total (s)   self (s)
                            "============================================================================
                            "File:        flawfinder.vim
                            "Description: Syntax checking plugin for syntastic
                            "Maintainer:  LCD 47 <lcd047 at gmail dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "
                            "============================================================================
                            
    8              0.000022 if exists('g:loaded_syntastic_c_flawfinder_checker')
    7              0.000005     finish
                            endif
    1              0.000001 let g:loaded_syntastic_c_flawfinder_checker = 1
                            
    1              0.000002 if !exists('g:syntastic_c_flawfinder_sort')
    1              0.000001     let g:syntastic_c_flawfinder_sort = 1
    1              0.000001 endif
                            
    1              0.000001 if !exists('g:syntastic_c_flawfinder_thres')
    1              0.000002     let g:syntastic_c_flawfinder_thres = 3
    1              0.000000 endif
                            
    1              0.000006 let s:save_cpo = &cpo
    1              0.000009 set cpo&vim
                            
    1              0.000002 function! SyntaxCheckers_c_flawfinder_GetHighlightRegex(item)
                                let term = matchstr(a:item['text'], '\m^(\S\+)\s\+\zs\S\+\ze:')
                                return term !=# '' ? '\V\<' . escape(term, '\') . '\>' : ''
                            endfunction
                            
    1              0.000001 function! SyntaxCheckers_c_flawfinder_GetLocList() dict
                                let makeprg = self.makeprgBuild({
                                    \ 'args_after': '--columns --dataonly --singleline --quiet' })
                            
                                let errorformat = '%f:%l:%c:  [%n] %m'
                            
                                let loclist = SyntasticMake({
                                    \ 'makeprg': makeprg,
                                    \ 'errorformat': errorformat,
                                    \ 'subtype': 'Style',
                                    \ 'returns': [0] })
                            
                                for e in loclist
                                    let e['type'] = e['nr'] < g:syntastic_{self.getFiletype()}_flawfinder_thres ? 'W' : 'E'
                                    let e['nr'] = 0
                                endfor
                            
                                return loclist
                            endfunction
                            
    1   0.000094   0.000004 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'c',
                                \ 'name': 'flawfinder' })
                            
    1              0.000010 let &cpo = s:save_cpo
    1              0.000001 unlet s:save_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/curusarn/.vim/bundle/syntastic/syntax_checkers/c/gcc.vim
Sourced 8 times
Total time:   0.000241
 Self time:   0.000134

count  total (s)   self (s)
                            "============================================================================
                            "File:        c.vim
                            "Description: Syntax checking plugin for syntastic
                            "Maintainer:  Gregor Uhlenheuer <kongo2002 at gmail dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "
                            "============================================================================
                            
    8              0.000021 if exists('g:loaded_syntastic_c_gcc_checker')
    7              0.000006     finish
                            endif
    1              0.000002 let g:loaded_syntastic_c_gcc_checker = 1
                            
    1              0.000002 if !exists('g:syntastic_c_compiler_options')
    1              0.000001     let g:syntastic_c_compiler_options = '-std=gnu99'
    1              0.000002 endif
                            
    1              0.000005 let s:save_cpo = &cpo
    1              0.000010 set cpo&vim
                            
    1              0.000002 function! SyntaxCheckers_c_gcc_IsAvailable() dict
                                if !exists('g:syntastic_c_compiler')
                                    let g:syntastic_c_compiler = executable(self.getExec()) ? self.getExec() : 'clang'
                                endif
                                call self.log('g:syntastic_c_compiler =', g:syntastic_c_compiler)
                                return executable(expand(g:syntastic_c_compiler, 1))
                            endfunction
                            
    1              0.000001 function! SyntaxCheckers_c_gcc_GetLocList() dict
                                return syntastic#c#GetLocList('c', 'gcc', {
                                    \ 'errorformat':
                                    \     '%-G%f:%s:,' .
                                    \     '%-G%f:%l: %#error: %#(Each undeclared identifier is reported only%.%#,' .
                                    \     '%-G%f:%l: %#error: %#for each function it appears%.%#,' .
                                    \     '%-GIn file included%.%#,' .
                                    \     '%-G %#from %f:%l\,,' .
                                    \     '%f:%l:%c: %trror: %m,' .
                                    \     '%f:%l:%c: %tarning: %m,' .
                                    \     '%f:%l:%c: %m,' .
                                    \     '%f:%l: %trror: %m,' .
                                    \     '%f:%l: %tarning: %m,'.
                                    \     '%f:%l: %m',
                                    \ 'main_flags': '-x c -fsyntax-only',
                                    \ 'header_flags': '-x c',
                                    \ 'header_names': '\m\.h$' })
                            endfunction
                            
    1   0.000116   0.000009 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'c',
                                \ 'name': 'gcc' })
                            
    1              0.000013 let &cpo = s:save_cpo
    1              0.000002 unlet s:save_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/curusarn/.vim/bundle/syntastic/syntax_checkers/c/make.vim
Sourced 8 times
Total time:   0.000211
 Self time:   0.000120

count  total (s)   self (s)
                            "============================================================================
                            "File:        make.vim
                            "Description: Syntax checking plugin for syntastic
                            "Maintainer:  Gregor Uhlenheuer <kongo2002 at gmail dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "
                            "============================================================================
                            
    8              0.000022 if exists('g:loaded_syntastic_c_make_checker')
    7              0.000004     finish
                            endif
    1              0.000002 let g:loaded_syntastic_c_make_checker = 1
                            
    1              0.000006 let s:save_cpo = &cpo
    1              0.000009 set cpo&vim
                            
    1              0.000002 function! SyntaxCheckers_c_make_GetLocList() dict
                                let makeprg = self.makeprgBuild({ 'args': '-sk', 'fname': '' })
                            
                                let errorformat =
                                    \ '%-G%f:%s:,' .
                                    \ '%-G%f:%l: %#error: %#(Each undeclared identifier is reported only%.%#,' .
                                    \ '%-G%f:%l: %#error: %#for each function it appears%.%#,' .
                                    \ '%-GIn file included%.%#,' .
                                    \ '%-G %#from %f:%l\,,' .
                                    \ '%f:%l:%c: %trror: %m,' .
                                    \ '%f:%l:%c: %tarning: %m,' .
                                    \ '%f:%l:%c: %m,' .
                                    \ '%f:%l: %trror: %m,' .
                                    \ '%f:%l: %tarning: %m,'.
                                    \ '%f:%l: %m'
                            
                                if exists('g:syntastic_c_errorformat')
                                    let errorformat = g:syntastic_c_errorformat
                                endif
                            
                                " process makeprg
                                let errors = SyntasticMake({
                                    \ 'makeprg': makeprg,
                                    \ 'errorformat': errorformat })
                            
                                " filter the processed errors if desired
                                if exists('g:syntastic_c_remove_include_errors') && g:syntastic_c_remove_include_errors != 0
                                    return filter(errors, 'has_key(v:val, "bufnr") && v:val["bufnr"] == ' . bufnr(''))
                                else
                                    return errors
                                endif
                            endfunction
                            
    1   0.000095   0.000004 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'c',
                                \ 'name': 'make'})
                            
    1              0.000010 let &cpo = s:save_cpo
    1              0.000001 unlet s:save_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/curusarn/.vim/bundle/syntastic/syntax_checkers/c/oclint.vim
Sourced 8 times
Total time:   0.000220
 Self time:   0.000119

count  total (s)   self (s)
                            "============================================================================
                            "File:        oclint.vim
                            "Description: Syntax checking plugin for syntastic
                            "Maintainer:  "UnCO" Lin <undercooled aT lavabit com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "============================================================================
                            
    8              0.000022 if exists('g:loaded_syntastic_c_oclint_checker')
    7              0.000004     finish
                            endif
    1              0.000002 let g:loaded_syntastic_c_oclint_checker = 1
                            
    1              0.000002 if !exists('g:syntastic_oclint_config_file')
    1              0.000002     let g:syntastic_oclint_config_file = '.syntastic_oclint_config'
    1              0.000000 endif
                            
    1              0.000001 if !exists('g:syntastic_c_oclint_sort')
    1              0.000002     let g:syntastic_c_oclint_sort = 1
    1              0.000000 endif
                            
    1              0.000006 let s:save_cpo = &cpo
    1              0.000006 set cpo&vim
                            
    1              0.000002 function! SyntaxCheckers_c_oclint_GetLocList() dict
                                let makeprg = self.makeprgBuild({
                                    \ 'post_args': '-- -c ' . syntastic#c#ReadConfig(g:syntastic_oclint_config_file) })
                            
                                let errorformat =
                                    \ '%E%f:%l:%c: fatal error: %m,' .
                                    \ '%E%f:%l:%c: error: %m,' .
                                    \ '%W%f:%l:%c: warning: %m,' .
                                    \ '%E%f:%l:%c: %m,' .
                                    \ '%-G%.%#'
                            
                                let loclist = SyntasticMake({
                                    \ 'makeprg': makeprg,
                                    \ 'errorformat': errorformat,
                                    \ 'subtype': 'Style',
                                    \ 'postprocess': ['compressWhitespace'],
                                    \ 'returns': [0, 3, 5] })
                            
                                for e in loclist
                                    if e['text'] =~# '\v P3( |$)'
                                        let e['type'] = 'W'
                                    endif
                            
                                    let e['text'] = substitute(e['text'], '\m\C P[1-3]$', '', '')
                                    let e['text'] = substitute(e['text'], '\m\C P[1-3] ', ': ', '')
                                endfor
                            
                                return loclist
                            endfunction
                            
    1   0.000105   0.000004 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'c',
                                \ 'name': 'oclint'})
                            
    1              0.000006 let &cpo = s:save_cpo
    1              0.000003 unlet s:save_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/curusarn/.vim/bundle/syntastic/syntax_checkers/c/pc_lint.vim
Sourced 8 times
Total time:   0.000213
 Self time:   0.000124

count  total (s)   self (s)
                            "============================================================================
                            "File:        pc_lint.vim
                            "Description: Syntax checking plugin for syntastic
                            "Maintainer:  Steve Bragg <steve at empresseffects dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "
                            "============================================================================
                            
    8              0.000024 if exists('g:loaded_syntastic_c_pc_lint_checker')
    7              0.000003     finish
                            endif
    1              0.000002 let g:loaded_syntastic_c_pc_lint_checker = 1
                            
    1              0.000009 let s:save_cpo = &cpo
    1              0.000006 set cpo&vim
                            
    1              0.000003 if !exists('g:syntastic_pc_lint_config_file')
    1              0.000001     let g:syntastic_pc_lint_config_file = 'options.lnt'
    1              0.000001 endif
                            
    1              0.000002 function! SyntaxCheckers_c_pc_lint_GetLocList() dict
                                let buf = bufnr('')
                                let config = syntastic#util#findFileInParent(g:syntastic_pc_lint_config_file, fnamemodify(bufname(buf), ':p:h'))
                                call self.log('config =', config)
                            
                                " -hFs1         - show filename, add space after messages, try to make message 1 line
                                " -width(0,0)   - make sure there are no line breaks
                                " -t            - set tab size
                                " -v            - turn off verbosity
                                let makeprg = self.makeprgBuild({
                                    \ 'args': (filereadable(config) ? syntastic#util#shescape(fnamemodify(config, ':p')) : ''),
                                    \ 'args_after': ['-hFs1', '-width(0,0)', '-t' . &tabstop, '-format=%f:%l:%C:%t:%n:%m'] })
                            
                                let errorformat =
                                    \ '%E%f:%l:%v:Error:%n:%m,' .
                                    \ '%W%f:%l:%v:Warning:%n:%m,' .
                                    \ '%I%f:%l:%v:Info:%n:%m,' .
                                    \ '%-G%.%#'
                            
                                let loclist = SyntasticMake({
                                    \ 'makeprg': makeprg,
                                    \ 'errorformat': errorformat,
                                    \ 'postprocess': ['cygwinRemoveCR'] })
                            
                                for e in loclist
                                    if e['type'] ==? 'I'
                                        let e['type'] = 'W'
                                        let e['subtype'] = 'Style'
                                    endif
                                endfor
                            
                                return loclist
                            endfunction
                            
    1   0.000094   0.000005 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'c',
                                \ 'name': 'pc_lint',
                                \ 'exec': 'lint-nt'})
                            
    1              0.000006 let &cpo = s:save_cpo
    1              0.000001 unlet s:save_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/curusarn/.vim/bundle/syntastic/syntax_checkers/c/sparse.vim
Sourced 8 times
Total time:   0.000199
 Self time:   0.000113

count  total (s)   self (s)
                            "============================================================================
                            "File:        sparse.vim
                            "Description: Syntax checking plugin for syntastic using sparse.pl
                            "Maintainer:  Daniel Walker <dwalker at fifo99 dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "============================================================================
                            
    8              0.000022 if exists('g:loaded_syntastic_c_sparse_checker')
    7              0.000004     finish
                            endif
    1              0.000002 let g:loaded_syntastic_c_sparse_checker = 1
                            
    1              0.000002 if !exists('g:syntastic_sparse_config_file')
    1              0.000002     let g:syntastic_sparse_config_file = '.syntastic_sparse_config'
    1              0.000000 endif
                            
    1              0.000005 let s:save_cpo = &cpo
    1              0.000010 set cpo&vim
                            
    1              0.000002 function! SyntaxCheckers_c_sparse_GetLocList() dict
                                let makeprg = self.makeprgBuild({
                                    \ 'args': syntastic#c#ReadConfig(g:syntastic_sparse_config_file),
                                    \ 'args_after': '-ftabstop=' . &ts })
                            
                                let errorformat =
                                    \ '%f:%l:%v: %trror: %m,' .
                                    \ '%f:%l:%v: %tarning: %m,'
                            
                                let loclist = SyntasticMake({
                                    \ 'makeprg': makeprg,
                                    \ 'errorformat': errorformat,
                                    \ 'defaults': {'bufnr': bufnr('')},
                                    \ 'returns': [0, 1] })
                                return loclist
                            endfunction
                            
    1   0.000091   0.000005 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'c',
                                \ 'name': 'sparse'})
                            
    1              0.000010 let &cpo = s:save_cpo
    1              0.000002 unlet s:save_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/curusarn/.vim/bundle/syntastic/syntax_checkers/c/splint.vim
Sourced 8 times
Total time:   0.000190
 Self time:   0.000105

count  total (s)   self (s)
                            "============================================================================
                            "File:        splint.vim
                            "Description: Syntax checking plugin for syntastic
                            "Maintainer:  LCD 47 <lcd047 at gmail dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "============================================================================
                            
    8              0.000019 if exists('g:loaded_syntastic_c_splint_checker')
    7              0.000006     finish
                            endif
    1              0.000002 let g:loaded_syntastic_c_splint_checker = 1
                            
    1              0.000002 if !exists('g:syntastic_splint_config_file')
    1              0.000002     let g:syntastic_splint_config_file = '.syntastic_splint_config'
    1              0.000000 endif
                            
    1              0.000005 let s:save_cpo = &cpo
    1              0.000005 set cpo&vim
                            
    1              0.000001 function! SyntaxCheckers_c_splint_GetLocList() dict
                                let makeprg = self.makeprgBuild({
                                    \ 'args': syntastic#c#ReadConfig(g:syntastic_splint_config_file),
                                    \ 'args_after': '-showfunc -hints +quiet' })
                            
                                let errorformat =
                                    \ '%-G%f:%l:%v: %[%#]%[%#]%[%#] Internal Bug %.%#,' .
                                    \ '%-G%f(%l\,%v): %[%#]%[%#]%[%#] Internal Bug %.%#,' .
                                    \ '%W%f:%l:%v: %m,' .
                                    \ '%W%f(%l\,%v): %m,' .
                                    \ '%W%f:%l: %m,' .
                                    \ '%W%f(%l): %m,' .
                                    \ '%-C %\+In file included from %.%#,' .
                                    \ '%-C %\+from %.%#,' .
                                    \ '%+C %.%#'
                            
                                return SyntasticMake({
                                    \ 'makeprg': makeprg,
                                    \ 'errorformat': errorformat,
                                    \ 'subtype': 'Style',
                                    \ 'postprocess': ['compressWhitespace'],
                                    \ 'defaults': {'type': 'W'} })
                            endfunction
                            
    1   0.000090   0.000005 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'c',
                                \ 'name': 'splint'})
                            
    1              0.000006 let &cpo = s:save_cpo
    1              0.000001 unlet s:save_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/curusarn/.vim/bundle/syntastic/syntax_checkers/cpp/clang_check.vim
Sourced 1 time
Total time:   0.000806
 Self time:   0.000028

count  total (s)   self (s)
                            "============================================================================
                            "File:        clang_check.vim
                            "Description: Syntax checking plugin for syntastic
                            "Maintainer:  Benjamin Bannier <bbannier at gmail dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "============================================================================
                            
    1              0.000005 if exists('g:loaded_syntastic_cpp_clang_check_checker')
                                finish
                            endif
    1              0.000003 let g:loaded_syntastic_cpp_clang_check_checker = 1
                            
    1   0.000787   0.000009 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'cpp',
                                \ 'name': 'clang_check',
                                \ 'redirect': 'c/clang_check'})
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/curusarn/.vim/bundle/syntastic/syntax_checkers/cpp/clang_tidy.vim
Sourced 1 time
Total time:   0.000755
 Self time:   0.000019

count  total (s)   self (s)
                            "============================================================================
                            "File:        clang_tidy.vim
                            "Description: Syntax checking plugin for syntastic
                            "Maintainer:  Benjamin Bannier <bbannier at gmail dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "============================================================================
                            
    1              0.000003 if exists('g:loaded_syntastic_cpp_clang_tidy_checker')
                                finish
                            endif
    1              0.000002 let g:loaded_syntastic_cpp_clang_tidy_checker = 1
                            
    1   0.000742   0.000006 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'cpp',
                                \ 'name': 'clang_tidy',
                                \ 'redirect': 'c/clang_tidy'})
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/curusarn/.vim/bundle/syntastic/syntax_checkers/cpp/cppcheck.vim
Sourced 1 time
Total time:   0.000659
 Self time:   0.000020

count  total (s)   self (s)
                            "============================================================================
                            "File:        cppcheck.vim
                            "Description: Syntax checking plugin for syntastic using cppcheck.pl
                            "Maintainer:  LCD 47 <lcd047 at gmail dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "============================================================================
                            
    1              0.000003 if exists('g:loaded_syntastic_cpp_cppcheck_checker')
                                finish
                            endif
    1              0.000002 let g:loaded_syntastic_cpp_cppcheck_checker = 1
                            
    1   0.000645   0.000006 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'cpp',
                                \ 'name': 'cppcheck',
                                \ 'redirect': 'c/cppcheck'})
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/curusarn/.vim/bundle/syntastic/syntax_checkers/cpp/cppclean.vim
Sourced 1 time
Total time:   0.000941
 Self time:   0.000022

count  total (s)   self (s)
                            "============================================================================
                            "File:        cppclean.vim
                            "Description: Syntax checking plugin for syntastic
                            "Maintainer:  Benjamin Bannier <bbannier at gmail dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "============================================================================
                            
    1              0.000003 if exists('g:loaded_syntastic_cpp_cppclean_checker')
                                finish
                            endif
    1              0.000002 let g:loaded_syntastic_cpp_cppclean_checker = 1
                            
    1   0.000924   0.000005 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'cpp',
                                \ 'name': 'cppclean',
                                \ 'redirect': 'c/cppclean'})
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/curusarn/.vim/bundle/syntastic/syntax_checkers/cpp/cpplint.vim
Sourced 1 time
Total time:   0.000190
 Self time:   0.000095

count  total (s)   self (s)
                            "============================================================================
                            "File:        cpplint.vim
                            "Description: Syntax checking plugin for syntastic
                            "Maintainer:  LCD 47 <lcd047 at gmail dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "
                            "============================================================================
                            
    1              0.000005 if exists('g:loaded_syntastic_cpp_cpplint_checker')
                                finish
                            endif
    1              0.000003 let g:loaded_syntastic_cpp_cpplint_checker = 1
                            
    1              0.000003 if !exists('g:syntastic_cpp_cpplint_thres')
    1              0.000002     let g:syntastic_cpp_cpplint_thres = 5
    1              0.000001 endif
                            
    1              0.000010 let s:save_cpo = &cpo
    1              0.000016 set cpo&vim
                            
    1              0.000003 function! SyntaxCheckers_cpp_cpplint_GetLocList() dict
                                let makeprg = self.makeprgBuild({ 'args': '--verbose=3' })
                            
                                let errorformat = '%A%f:%l:  %m [%t],%-G%.%#'
                            
                                let loclist = SyntasticMake({
                                    \ 'makeprg': makeprg,
                                    \ 'errorformat': errorformat,
                                    \ 'subtype': 'Style',
                                    \ 'returns': [0, 1] })
                            
                                " change error types according to the prescribed threshold
                                for e in loclist
                                    let e['type'] = e['type'] < g:syntastic_cpp_cpplint_thres ? 'W' : 'E'
                                endfor
                            
                                return loclist
                            endfunction
                            
    1   0.000104   0.000009 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'cpp',
                                \ 'name': 'cpplint',
                                \ 'exec': 'cpplint.py'})
                            
    1              0.000012 let &cpo = s:save_cpo
    1              0.000002 unlet s:save_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/curusarn/.vim/bundle/syntastic/syntax_checkers/cpp/flawfinder.vim
Sourced 1 time
Total time:   0.000770
 Self time:   0.000025

count  total (s)   self (s)
                            "============================================================================
                            "File:        flawfinder.vim
                            "Description: Syntax checking plugin for syntastic
                            "Maintainer:  Benjamin Bannier <bbannier at gmail dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "============================================================================
                            
    1              0.000004 if exists('g:loaded_syntastic_cpp_flawfinder_checker')
                                finish
                            endif
    1              0.000002 let g:loaded_syntastic_cpp_flawfinder_checker = 1
                            
    1              0.000002 if !exists('g:syntastic_cpp_flawfinder_thres')
    1              0.000002     let g:syntastic_cpp_flawfinder_thres = 3
    1              0.000000 endif
                            
    1   0.000749   0.000004 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'cpp',
                                \ 'name': 'flawfinder',
                                \ 'redirect': 'c/flawfinder'})
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/curusarn/.vim/bundle/syntastic/syntax_checkers/cpp/gcc.vim
Sourced 1 time
Total time:   0.000152
 Self time:   0.000064

count  total (s)   self (s)
                            "============================================================================
                            "File:        cpp.vim
                            "Description: Syntax checking plugin for syntastic
                            "Maintainer:  Gregor Uhlenheuer <kongo2002 at gmail dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "
                            "============================================================================
                            
    1              0.000003 if exists('g:loaded_syntastic_cpp_gcc_checker')
                                finish
                            endif
    1              0.000002 let g:loaded_syntastic_cpp_gcc_checker = 1
                            
    1              0.000002 if !exists('g:syntastic_cpp_compiler_options')
    1              0.000002     let g:syntastic_cpp_compiler_options = ''
    1              0.000000 endif
                            
    1              0.000007 let s:save_cpo = &cpo
    1              0.000010 set cpo&vim
                            
    1              0.000002 function! SyntaxCheckers_cpp_gcc_IsAvailable() dict
                                if !exists('g:syntastic_cpp_compiler')
                                    let g:syntastic_cpp_compiler = executable(self.getExec()) ? self.getExec() : 'clang++'
                                endif
                                call self.log('g:syntastic_cpp_compiler =', g:syntastic_cpp_compiler)
                                return executable(expand(g:syntastic_cpp_compiler, 1))
                            endfunction
                            
    1              0.000001 function! SyntaxCheckers_cpp_gcc_GetLocList() dict
                                return syntastic#c#GetLocList('cpp', 'gcc', {
                                    \ 'errorformat':
                                    \     '%-G%f:%s:,' .
                                    \     '%f:%l:%c: %trror: %m,' .
                                    \     '%f:%l:%c: %tarning: %m,' .
                                    \     '%f:%l:%c: %m,'.
                                    \     '%f:%l: %trror: %m,'.
                                    \     '%f:%l: %tarning: %m,'.
                                    \     '%f:%l: %m',
                                    \ 'main_flags': '-x c++ -fsyntax-only',
                                    \ 'header_flags': '-x c++',
                                    \ 'header_names': '\m\.\(h\|hpp\|hh\)$' })
                            endfunction
                            
    1   0.000093   0.000005 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'cpp',
                                \ 'name': 'gcc',
                                \ 'exec': 'g++' })
                            
    1              0.000010 let &cpo = s:save_cpo
    1              0.000002 unlet s:save_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/curusarn/.vim/bundle/syntastic/syntax_checkers/cpp/oclint.vim
Sourced 1 time
Total time:   0.000660
 Self time:   0.000021

count  total (s)   self (s)
                            "============================================================================
                            "File:        oclint.vim
                            "Description: Syntax checking plugin for syntastic
                            "Maintainer:  "UnCO" Lin <undercooled aT lavabit com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "============================================================================
                            
    1              0.000004 if exists('g:loaded_syntastic_cpp_oclint_checker')
                                finish
                            endif
    1              0.000002 let g:loaded_syntastic_cpp_oclint_checker = 1
                            
    1   0.000645   0.000006 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'cpp',
                                \ 'name': 'oclint',
                                \ 'redirect': 'c/oclint'})
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/curusarn/.vim/bundle/syntastic/syntax_checkers/cpp/pc_lint.vim
Sourced 1 time
Total time:   0.000664
 Self time:   0.000020

count  total (s)   self (s)
                            "============================================================================
                            "File:        pc_lint.vim
                            "Description: Syntax checking plugin for syntastic
                            "Maintainer:  Steve Bragg <steve at empresseffects dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "
                            "============================================================================
                            
    1              0.000003 if exists('g:loaded_syntastic_cpp_pc_lint_checker')
                                finish
                            endif
    1              0.000002 let g:loaded_syntastic_cpp_pc_lint_checker = 1
                            
    1   0.000650   0.000006 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'cpp',
                                \ 'name': 'pc_lint',
                                \ 'redirect': 'c/pc_lint'})
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/curusarn/.vim/bundle/syntastic/syntax_checkers/cpp/verapp.vim
Sourced 1 time
Total time:   0.000151
 Self time:   0.000063

count  total (s)   self (s)
                            "============================================================================
                            "File:        verapp.vim
                            "Description: Syntax checking plugin for syntastic
                            "Maintainer:  Lucas Verney <phyks@phyks.me>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "
                            " Tested with Vera++ 1.3.0
                            "============================================================================
                            
    1              0.000003 if exists('g:loaded_syntastic_cpp_verapp_checker')
                                finish
                            endif
    1              0.000001 let g:loaded_syntastic_cpp_verapp_checker = 1
                            
    1              0.000002 if !exists('g:syntastic_verapp_config_file')
    1              0.000001     let g:syntastic_verapp_config_file = '.syntastic_verapp_config'
    1              0.000001 endif
                            
    1              0.000006 let s:save_cpo = &cpo
    1              0.000010 set cpo&vim
                            
    1              0.000001 function! SyntaxCheckers_cpp_verapp_GetLocList() dict
                                let makeprg = self.makeprgBuild({
                                    \ 'args': syntastic#c#ReadConfig(g:syntastic_verapp_config_file),
                                    \ 'args_after': '--show-rule --no-duplicate -S -c -' })
                            
                                let errorformat = '%f:%t:%l:%c:%m'
                            
                                return SyntasticMake({
                                    \ 'makeprg': makeprg,
                                    \ 'errorformat': errorformat,
                                    \ 'preprocess': 'checkstyle',
                                    \ 'subtype': 'Style' })
                            endfunction
                            
    1   0.000093   0.000005 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'cpp',
                                \ 'name': 'verapp',
                                \ 'exec': 'vera++'})
                            
    1              0.000010 let &cpo = s:save_cpo
    1              0.000002 unlet s:save_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/curusarn/.vim/bundle/syntastic/autoload/syntastic/c.vim
Sourced 1 time
Total time:   0.000393
 Self time:   0.000243

count  total (s)   self (s)
    1              0.000005 if exists('g:loaded_syntastic_c_autoload') || !exists('g:loaded_syntastic_plugin')
                                finish
                            endif
    1              0.000002 let g:loaded_syntastic_c_autoload = 1
                            
    1              0.000005 let s:save_cpo = &cpo
    1              0.000011 set cpo&vim
                            
                            " Public functions {{{1
                            
                            " convenience function to determine the 'null device' parameter
                            " based on the current operating system
    1              0.000002 function! syntastic#c#NullOutput() abort " {{{2
                                let known_os = has('unix') || has('mac') || syntastic#util#isRunningWindows()
                                return known_os ? '-o ' . syntastic#util#DevNull() : ''
                            endfunction " }}}2
                            
                            " read additional compiler flags from the given configuration file
                            " the file format and its parsing mechanism is inspired by clang_complete
    1              0.000001 function! syntastic#c#ReadConfig(file) abort " {{{2
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, 'ReadConfig: looking for', a:file)
                            
                                " search upwards from the current file's directory
                                let config = syntastic#util#findFileInParent(a:file, expand('%:p:h', 1))
                                if config ==# ''
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, 'ReadConfig: file not found')
                                    return ''
                                endif
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, 'ReadConfig: config file:', config)
                                if !filereadable(config)
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, 'ReadConfig: file unreadable')
                                    return ''
                                endif
                            
                                " convert filename into absolute path
                                let filepath = fnamemodify(config, ':p:h')
                            
                                " try to read config file
                                try
                                    let lines = readfile(config)
                                catch /\m^Vim\%((\a\+)\)\=:E48[45]/
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, 'ReadConfig: error reading file')
                                    return ''
                                endtry
                            
                                " filter out empty lines and comments
                                call filter(lines, 'v:val !~# ''\v^(\s*#|$)''')
                            
                                " remove leading and trailing spaces
                                call map(lines, 'substitute(v:val, ''\m^\s\+'', "", "")')
                                call map(lines, 'substitute(v:val, ''\m\s\+$'', "", "")')
                            
                                let parameters = []
                                for line in lines
                                    let matches = matchstr(line, '\m\C^\s*-I\s*\zs.\+')
                                    if matches !=# ''
                                        " this one looks like an absolute path
                                        if match(matches, '\m^\%(/\|\a:\)') != -1
                                            call add(parameters, '-I' . matches)
                                        else
                                            call add(parameters, '-I' . filepath . syntastic#util#Slash() . matches)
                                        endif
                                    else
                                        call add(parameters, line)
                                    endif
                                endfor
                            
                                return join(map(parameters, 'syntastic#util#shescape(v:val)'))
                            endfunction " }}}2
                            
                            " GetLocList() for C-like compilers
    1              0.000001 function! syntastic#c#GetLocList(filetype, subchecker, options) abort " {{{2
                                try
                                    let flags = s:_get_cflags(a:filetype, a:subchecker, a:options)
                                catch /\m\C^Syntastic: skip checks$/
                                    return []
                                endtry
                            
                                let makeprg = syntastic#util#shexpand(g:syntastic_{a:filetype}_compiler) .
                                    \ ' ' . flags . ' ' . syntastic#util#shexpand('%')
                            
                                let errorformat = s:_get_checker_var('g', a:filetype, a:subchecker, 'errorformat', a:options['errorformat'])
                            
                                let postprocess = s:_get_checker_var('g', a:filetype, a:subchecker, 'remove_include_errors', 0) ?
                                    \ ['filterForeignErrors'] : []
                            
                                " process makeprg
                                return SyntasticMake({
                                    \ 'makeprg': makeprg,
                                    \ 'errorformat': errorformat,
                                    \ 'postprocess': postprocess })
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " Private functions {{{1
                            
                            " initialize c/cpp syntax checker handlers
    1              0.000001 function! s:_init() abort " {{{2
                                let s:handlers = []
                                let s:cflags = {}
                            
                                call s:_registerHandler('\m\<cairo',       's:_checkPackage', ['cairo', 'cairo'])
                                call s:_registerHandler('\m\<freetype',    's:_checkPackage', ['freetype', 'freetype2', 'freetype'])
                                call s:_registerHandler('\m\<glade',       's:_checkPackage', ['glade', 'libglade-2.0', 'libglade'])
                                call s:_registerHandler('\m\<glib',        's:_checkPackage', ['glib', 'glib-2.0', 'glib'])
                                call s:_registerHandler('\m\<gtk',         's:_checkPackage', ['gtk', 'gtk+-2.0', 'gtk+', 'glib-2.0', 'glib'])
                                call s:_registerHandler('\m\<libsoup',     's:_checkPackage', ['libsoup', 'libsoup-2.4', 'libsoup-2.2'])
                                call s:_registerHandler('\m\<libxml',      's:_checkPackage', ['libxml', 'libxml-2.0', 'libxml'])
                                call s:_registerHandler('\m\<pango',       's:_checkPackage', ['pango', 'pango'])
                                call s:_registerHandler('\m\<SDL',         's:_checkPackage', ['sdl', 'sdl'])
                                call s:_registerHandler('\m\<opengl',      's:_checkPackage', ['opengl', 'gl'])
                                call s:_registerHandler('\m\<webkit',      's:_checkPackage', ['webkit', 'webkit-1.0'])
                            
                                call s:_registerHandler('\m\<php\.h\>',    's:_checkPhp',    [])
                                call s:_registerHandler('\m\<Python\.h\>', 's:_checkPython', [])
                                call s:_registerHandler('\m\<ruby',        's:_checkRuby',   [])
                            endfunction " }}}2
                            
                            " register a handler dictionary object
    1              0.000002 function! s:_registerHandler(regex, function, args) abort " {{{2
                                let handler = {}
                                let handler['regex'] = a:regex
                                let handler['func'] = function(a:function)
                                let handler['args'] = a:args
                                call add(s:handlers, handler)
                            endfunction " }}}2
                            
                            " try to find library with 'pkg-config'
                            " search possible libraries from first to last given
                            " argument until one is found
    1              0.000001 function! s:_checkPackage(name, ...) abort " {{{2
                                if executable('pkg-config')
                                    if !has_key(s:cflags, a:name)
                                        for pkg in a:000
                                            let pkg_flags = syntastic#util#system('pkg-config --cflags ' . pkg)
                                            " since we cannot necessarily trust the pkg-config exit code
                                            " we have to check for an error output as well
                                            if v:shell_error == 0 && pkg_flags !~? 'not found'
                                                let pkg_flags = ' ' . substitute(pkg_flags, "\n", '', '')
                                                let s:cflags[a:name] = pkg_flags
                                                return pkg_flags
                                            endif
                                        endfor
                                    else
                                        return s:cflags[a:name]
                                    endif
                                endif
                                return ''
                            endfunction " }}}2
                            
                            " try to find PHP includes with 'php-config'
    1              0.000001 function! s:_checkPhp() abort " {{{2
                                if executable('php-config')
                                    if !has_key(s:cflags, 'php')
                                        let s:cflags['php'] = syntastic#util#system('php-config --includes')
                                        let s:cflags['php'] = ' ' . substitute(s:cflags['php'], "\n", '', '')
                                    endif
                                    return s:cflags['php']
                                endif
                                return ''
                            endfunction " }}}2
                            
                            " try to find the python headers with distutils
    1              0.000001 function! s:_checkPython() abort " {{{2
                                if executable('python')
                                    if !has_key(s:cflags, 'python')
                                        let s:cflags['python'] = syntastic#util#system('python -c ''from distutils import ' .
                                            \ 'sysconfig; import sys; sys.stdout.write(sysconfig.get_python_inc())''')
                                        let s:cflags['python'] = substitute(s:cflags['python'], "\n", '', '')
                                        let s:cflags['python'] = ' -I' . s:cflags['python']
                                    endif
                                    return s:cflags['python']
                                endif
                                return ''
                            endfunction " }}}2
                            
                            " try to find the ruby headers with 'rbconfig'
    1              0.000001 function! s:_checkRuby() abort " {{{2
                                if executable('ruby')
                                    if !has_key(s:cflags, 'ruby')
                                        let s:cflags['ruby'] = syntastic#util#system('ruby -r rbconfig -e ' .
                                            \ '''puts RbConfig::CONFIG["rubyhdrdir"] || RbConfig::CONFIG["archdir"]''')
                                        let s:cflags['ruby'] = substitute(s:cflags['ruby'], "\n", '', '')
                                        let s:cflags['ruby'] = ' -I' . s:cflags['ruby']
                                    endif
                                    return s:cflags['ruby']
                                endif
                                return ''
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " Utilities {{{1
                            
                            " resolve checker-related user variables
    1              0.000002 function! s:_get_checker_var(scope, filetype, subchecker, name, default) abort " {{{2
                                let prefix = a:scope . ':' . 'syntastic_'
                                if exists(prefix . a:filetype . '_' . a:subchecker . '_' . a:name)
                                    return {a:scope}:syntastic_{a:filetype}_{a:subchecker}_{a:name}
                                elseif exists(prefix . a:filetype . '_' . a:name)
                                    return {a:scope}:syntastic_{a:filetype}_{a:name}
                                else
                                    return a:default
                                endif
                            endfunction " }}}2
                            
                            " resolve user CFLAGS
    1              0.000003 function! s:_get_cflags(ft, ck, opts) abort " {{{2
                                " determine whether to parse header files as well
                                if has_key(a:opts, 'header_names') && expand('%', 1) =~? a:opts['header_names']
                                    if s:_get_checker_var('g', a:ft, a:ck, 'check_header', 0)
                                        let flags = get(a:opts, 'header_flags', '') . ' -c ' . syntastic#c#NullOutput()
                                    else
                                        " checking headers when check_header is unset: bail out
                                        throw 'Syntastic: skip checks'
                                    endif
                                else
                                    let flags = get(a:opts, 'main_flags', '')
                                endif
                            
                                let flags .= ' ' . s:_get_checker_var('g', a:ft, a:ck, 'compiler_options', '') . ' ' . s:_get_include_dirs(a:ft)
                            
                                " check if the user manually set some cflags
                                let b_cflags = s:_get_checker_var('b', a:ft, a:ck, 'cflags', '')
                                if b_cflags !=# ''
                                    let flags .= ' ' . b_cflags
                                endif
                            
                                " add optional config file parameters
                                let config_file = s:_get_checker_var('g', a:ft, a:ck, 'config_file', '.syntastic_' . a:ft . '_config')
                                let flags .= ' ' . syntastic#c#ReadConfig(config_file)
                            
                                if b_cflags ==# '' && (a:ft ==# 'c' || a:ft ==# 'cpp') && !s:_get_checker_var('g', a:ft, a:ck, 'no_include_search', 0)
                                    " refresh the include file search if desired
                                    if s:_get_checker_var('g', a:ft, a:ck, 'auto_refresh_includes', 0)
                                        let flags .= ' ' . s:_search_headers()
                                    else
                                        " search for header includes if not cached already
                                        if !exists('b:syntastic_' . a:ft . '_includes')
                                            let b:syntastic_{a:ft}_includes = s:_search_headers()
                                        endif
                                        let flags .= ' ' . b:syntastic_{a:ft}_includes
                                    endif
                                endif
                            
                                return flags
                            endfunction " }}}2
                            
                            " get the gcc include directory argument depending on the default
                            " includes and the optional user-defined 'g:syntastic_c_include_dirs'
    1              0.000002 function! s:_get_include_dirs(filetype) abort " {{{2
                                let include_dirs = []
                            
                                if a:filetype =~# '\v^%(c|cpp|objc|objcpp)$' &&
                                            \ (!exists('g:syntastic_'.a:filetype.'_no_default_include_dirs') ||
                                            \ !g:syntastic_{a:filetype}_no_default_include_dirs)
                                    let include_dirs = copy(s:default_includes)
                                endif
                            
                                if exists('g:syntastic_'.a:filetype.'_include_dirs')
                                    call extend(include_dirs, g:syntastic_{a:filetype}_include_dirs)
                                endif
                            
                                return join(map(syntastic#util#unique(include_dirs), 'syntastic#util#shescape("-I" . v:val)'))
                            endfunction " }}}2
                            
                            " search the first 100 lines for include statements that are
                            " given in the handlers dictionary
    1              0.000002 function! s:_search_headers() abort " {{{2
                                let includes = ''
                                let files = []
                                let found = []
                                let lines = filter(getline(1, 100), 'v:val =~# ''\m^\s*#\s*include''')
                            
                                " search current buffer
                                for line in lines
                                    let file = matchstr(line, '\m"\zs\S\+\ze"')
                                    if file !=# ''
                                        call add(files, file)
                                        continue
                                    endif
                            
                                    for handler in s:handlers
                                        if line =~# handler['regex']
                                            let includes .= call(handler['func'], handler['args'])
                                            call add(found, handler['regex'])
                                            break
                                        endif
                                    endfor
                                endfor
                            
                                " search included headers
                                for hfile in files
                                    if hfile !=# ''
                                        let filename = expand('%:p:h', 1) . syntastic#util#Slash() . hfile
                            
                                        try
                                            let lines = readfile(filename, '', 100)
                                        catch /\m^Vim\%((\a\+)\)\=:E484/
                                            continue
                                        endtry
                            
                                        call filter(lines, 'v:val =~# ''\m^\s*#\s*include''')
                            
                                        for handler in s:handlers
                                            if index(found, handler['regex']) != -1
                                                continue
                                            endif
                            
                                            for line in lines
                                                if line =~# handler['regex']
                                                    let includes .= call(handler['func'], handler['args'])
                                                    call add(found, handler['regex'])
                                                    break
                                                endif
                                            endfor
                                        endfor
                                    endif
                                endfor
                            
                                return includes
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " default include directories
    1   0.000024   0.000018 let s:default_includes = [
                                \ '.',
                                \ '..',
                                \ 'include',
                                \ 'includes',
                                \ '..' . syntastic#util#Slash() . 'include',
                                \ '..' . syntastic#util#Slash() . 'includes' ]
                            
    1   0.000149   0.000005 call s:_init()
                            
    1              0.000034 let &cpo = s:save_cpo
    1              0.000001 unlet s:save_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/curusarn/.vim/bundle/vim-gitgutter/autoload/gitgutter/debug.vim
Sourced 1 time
Total time:   0.000074
 Self time:   0.000074

count  total (s)   self (s)
    1              0.000007 let s:plugin_dir  = expand('<sfile>:p:h:h:h').'/'
    1              0.000002 let s:log_file    = s:plugin_dir.'gitgutter.log'
    1              0.000002 let s:channel_log = s:plugin_dir.'channel.log'
    1              0.000001 let s:new_log_session = 1
                            
                            
    1              0.000002 function! gitgutter#debug#debug()
                              " Open a scratch buffer
                              vsplit __GitGutter_Debug__
                              normal! ggdG
                              setlocal buftype=nofile
                              setlocal bufhidden=delete
                              setlocal noswapfile
                            
                              call gitgutter#debug#vim_version()
                              call gitgutter#debug#separator()
                            
                              call gitgutter#debug#git_version()
                              call gitgutter#debug#separator()
                            
                              call gitgutter#debug#grep_version()
                              call gitgutter#debug#separator()
                            
                              call gitgutter#debug#option('updatetime')
                              call gitgutter#debug#option('shell')
                              call gitgutter#debug#option('shellcmdflag')
                              call gitgutter#debug#option('shellpipe')
                              call gitgutter#debug#option('shellquote')
                              call gitgutter#debug#option('shellredir')
                              call gitgutter#debug#option('shellslash')
                              call gitgutter#debug#option('shelltemp')
                              call gitgutter#debug#option('shelltype')
                              call gitgutter#debug#option('shellxescape')
                              call gitgutter#debug#option('shellxquote')
                            endfunction
                            
                            
    1              0.000001 function! gitgutter#debug#separator()
                              call gitgutter#debug#output('')
                            endfunction
                            
    1              0.000001 function! gitgutter#debug#vim_version()
                              redir => version_info
                                silent execute 'version'
                              redir END
                              call gitgutter#debug#output(split(version_info, '\n')[0:2])
                            endfunction
                            
    1              0.000001 function! gitgutter#debug#git_version()
                              let v = system(g:gitgutter_git_executable.' --version')
                              call gitgutter#debug#output( substitute(v, '\n$', '', '') )
                            endfunction
                            
    1              0.000001 function! gitgutter#debug#grep_version()
                              let v = system('grep --version')
                              call gitgutter#debug#output( substitute(v, '\n$', '', '') )
                            
                              let v = system('grep --help')
                              call gitgutter#debug#output( substitute(v, '\%x00', '', 'g') )
                            endfunction
                            
    1              0.000001 function! gitgutter#debug#option(name)
                              if exists('+' . a:name)
                                let v = eval('&' . a:name)
                                call gitgutter#debug#output(a:name . '=' . v)
                                " redir => output
                                "   silent execute "verbose set " . a:name . "?"
                                " redir END
                                " call gitgutter#debug#output(a:name . '=' . output)
                              else
                                call gitgutter#debug#output(a:name . ' [n/a]')
                              end
                            endfunction
                            
    1              0.000001 function! gitgutter#debug#output(text)
                              call append(line('$'), a:text)
                            endfunction
                            
                            " assumes optional args are calling function's optional args
    1              0.000002 function! gitgutter#debug#log(message, ...) abort
                              if g:gitgutter_log
                                if s:new_log_session && gitgutter#async#available()
                                  if exists('*ch_logfile')
                                    call ch_logfile(s:channel_log, 'w')
                                  endif
                                endif
                            
                                execute 'redir >> '.s:log_file
                                  if s:new_log_session
                                    let s:start = reltime()
                                    silent echo "\n==== start log session ===="
                                  endif
                            
                                  let elapsed = reltimestr(reltime(s:start)).' '
                                  silent echo ''
                                  " callers excluding this function
                                  silent echo elapsed.expand('<sfile>')[:-22].':'
                                  silent echo elapsed.s:format_for_log(a:message)
                                  if a:0 && !empty(a:1)
                                    for msg in a:000
                                      silent echo elapsed.s:format_for_log(msg)
                                    endfor
                                  endif
                                redir END
                            
                                let s:new_log_session = 0
                              endif
                            endfunction
                            
    1              0.000002 function! s:format_for_log(data) abort
                              if type(a:data) == 1
                                return join(split(a:data,'\n'),"\n")
                              elseif type(a:data) == 3
                                return '['.join(a:data,"\n").']'
                              else
                                return a:data
                              endif
                            endfunction
                            

SCRIPT  /home/curusarn/.vim/bundle/vim-gitgutter/autoload/gitgutter/sign.vim
Sourced 1 time
Total time:   0.000098
 Self time:   0.000098

count  total (s)   self (s)
                            " Vim doesn't namespace sign ids so every plugin shares the same
                            " namespace.  Sign ids are simply integers so to avoid clashes with other
                            " signs we guess at a clear run.
                            "
                            " Note also we currently never reset s:next_sign_id.
    1              0.000003 let s:first_sign_id = 3000
    1              0.000001 let s:next_sign_id  = s:first_sign_id
    1              0.000003 let s:dummy_sign_id = s:first_sign_id - 1
                            " Remove-all-signs optimisation requires Vim 7.3.596+.
    1              0.000003 let s:supports_star = v:version > 703 || (v:version == 703 && has("patch596"))
                            
                            
                            " Removes gitgutter's signs (excluding dummy sign) from the buffer being processed.
    1              0.000001 function! gitgutter#sign#clear_signs() abort
                              let bufnr = gitgutter#utility#bufnr()
                              call gitgutter#sign#find_current_signs()
                            
                              let sign_ids = map(values(gitgutter#utility#getbufvar(bufnr, 'gitgutter_signs')), 'v:val.id')
                              call gitgutter#sign#remove_signs(sign_ids, 1)
                              call gitgutter#utility#setbufvar(bufnr, 'gitgutter_signs', {})
                            endfunction
                            
                            
                            " Updates gitgutter's signs in the buffer being processed.
                            "
                            " modified_lines: list of [<line_number (number)>, <name (string)>]
                            " where name = 'added|removed|modified|modified_removed'
    1              0.000001 function! gitgutter#sign#update_signs(modified_lines) abort
                              call gitgutter#sign#find_current_signs()
                            
                              let new_gitgutter_signs_line_numbers = map(copy(a:modified_lines), 'v:val[0]')
                              let obsolete_signs = gitgutter#sign#obsolete_gitgutter_signs_to_remove(new_gitgutter_signs_line_numbers)
                            
                              let flicker_possible = s:remove_all_old_signs && !empty(a:modified_lines)
                              if flicker_possible
                                call gitgutter#sign#add_dummy_sign()
                              endif
                            
                              call gitgutter#sign#remove_signs(obsolete_signs, s:remove_all_old_signs)
                              call gitgutter#sign#upsert_new_gitgutter_signs(a:modified_lines)
                            
                              if flicker_possible
                                call gitgutter#sign#remove_dummy_sign(0)
                              endif
                            endfunction
                            
                            
    1              0.000001 function! gitgutter#sign#add_dummy_sign() abort
                              let bufnr = gitgutter#utility#bufnr()
                              if !gitgutter#utility#getbufvar(bufnr, 'dummy_sign')
                                execute "sign place" s:dummy_sign_id "line=" . 9999 "name=GitGutterDummy buffer=" . bufnr
                                call gitgutter#utility#setbufvar(bufnr, 'dummy_sign', 1)
                              endif
                            endfunction
                            
    1              0.000002 function! gitgutter#sign#remove_dummy_sign(force) abort
                              let bufnr = gitgutter#utility#bufnr()
                              if gitgutter#utility#getbufvar(bufnr, 'dummy_sign') && (a:force || !g:gitgutter_sign_column_always)
                                execute "sign unplace" s:dummy_sign_id "buffer=" . bufnr
                                call gitgutter#utility#setbufvar(bufnr, 'dummy_sign', 0)
                              endif
                            endfunction
                            
                            
                            "
                            " Internal functions
                            "
                            
                            
    1              0.000001 function! gitgutter#sign#find_current_signs() abort
                              let bufnr = gitgutter#utility#bufnr()
                              let gitgutter_signs = {}  " <line_number (string)>: {'id': <id (number)>, 'name': <name (string)>}
                              let other_signs = []      " [<line_number (number),...]
                              let dummy_sign_placed = 0
                            
                              redir => signs
                                silent execute "sign place buffer=" . bufnr
                              redir END
                            
                              for sign_line in filter(split(signs, '\n')[2:], 'v:val =~# "="')
                                " Typical sign line:  line=88 id=1234 name=GitGutterLineAdded
                                " We assume splitting is faster than a regexp.
                                let components  = split(sign_line)
                                let name        = split(components[2], '=')[1]
                                if name =~# 'GitGutterDummy'
                                  let dummy_sign_placed = 1
                                else
                                  let line_number = str2nr(split(components[0], '=')[1])
                                  if name =~# 'GitGutter'
                                    let id = str2nr(split(components[1], '=')[1])
                                    " Remove orphaned signs (signs placed on lines which have been deleted).
                                    " (When a line is deleted its sign lingers.  Subsequent lines' signs'
                                    " line numbers are decremented appropriately.)
                                    if has_key(gitgutter_signs, line_number)
                                      execute "sign unplace" gitgutter_signs[line_number].id
                                    endif
                                    let gitgutter_signs[line_number] = {'id': id, 'name': name}
                                  else
                                    call add(other_signs, line_number)
                                  endif
                                end
                              endfor
                            
                              call gitgutter#utility#setbufvar(bufnr, 'dummy_sign', dummy_sign_placed)
                              call gitgutter#utility#setbufvar(bufnr, 'gitgutter_signs', gitgutter_signs)
                              call gitgutter#utility#setbufvar(bufnr, 'other_signs', other_signs)
                            endfunction
                            
                            
                            " Returns a list of [<id (number)>, ...]
                            " Sets `s:remove_all_old_signs` as a side-effect.
    1              0.000002 function! gitgutter#sign#obsolete_gitgutter_signs_to_remove(new_gitgutter_signs_line_numbers) abort
                              let bufnr = gitgutter#utility#bufnr()
                              let signs_to_remove = []  " list of [<id (number)>, ...]
                              let remove_all_signs = 1
                              let old_gitgutter_signs = gitgutter#utility#getbufvar(bufnr, 'gitgutter_signs')
                              for line_number in keys(old_gitgutter_signs)
                                if index(a:new_gitgutter_signs_line_numbers, str2nr(line_number)) == -1
                                  call add(signs_to_remove, old_gitgutter_signs[line_number].id)
                                else
                                  let remove_all_signs = 0
                                endif
                              endfor
                              let s:remove_all_old_signs = remove_all_signs
                              return signs_to_remove
                            endfunction
                            
                            
    1              0.000002 function! gitgutter#sign#remove_signs(sign_ids, all_signs) abort
                              let bufnr = gitgutter#utility#bufnr()
                              if a:all_signs && s:supports_star && empty(gitgutter#utility#getbufvar(bufnr, 'other_signs'))
                                let dummy_sign_present = gitgutter#utility#getbufvar(bufnr, 'dummy_sign')
                                execute "sign unplace * buffer=" . bufnr
                                if dummy_sign_present
                                  execute "sign place" s:dummy_sign_id "line=" . 9999 "name=GitGutterDummy buffer=" . bufnr
                                endif
                              else
                                for id in a:sign_ids
                                  execute "sign unplace" id
                                endfor
                              endif
                            endfunction
                            
                            
    1              0.000001 function! gitgutter#sign#upsert_new_gitgutter_signs(modified_lines) abort
                              let bufnr = gitgutter#utility#bufnr()
                              let other_signs         = gitgutter#utility#getbufvar(bufnr, 'other_signs')
                              let old_gitgutter_signs = gitgutter#utility#getbufvar(bufnr, 'gitgutter_signs')
                            
                              for line in a:modified_lines
                                let line_number = line[0]  " <number>
                                if index(other_signs, line_number) == -1  " don't clobber others' signs
                                  let name = gitgutter#utility#highlight_name_for_change(line[1])
                                  if !has_key(old_gitgutter_signs, line_number)  " insert
                                    let id = gitgutter#sign#next_sign_id()
                                    execute "sign place" id "line=" . line_number "name=" . name "buffer=" . bufnr
                                  else  " update if sign has changed
                                    let old_sign = old_gitgutter_signs[line_number]
                                    if old_sign.name !=# name
                                      execute "sign place" old_sign.id "name=" . name "buffer=" . bufnr
                                    end
                                  endif
                                endif
                              endfor
                              " At this point b:gitgutter_gitgutter_signs is out of date.
                            endfunction
                            
                            
    1              0.000001 function! gitgutter#sign#next_sign_id() abort
                              let next_id = s:next_sign_id
                              let s:next_sign_id += 1
                              return next_id
                            endfunction
                            
                            
                            " Only for testing.
    1              0.000001 function! gitgutter#sign#reset()
                              let s:next_sign_id  = s:first_sign_id
                            endfunction

FUNCTION  airline#extensions#quickfix#inactive_qf_window()
Called 6 times
Total time:   0.000085
 Self time:   0.000085

count  total (s)   self (s)
    6              0.000056   if getbufvar(a:2.bufnr, '&filetype') is# 'qf' && !empty(airline#util#getwinvar(a:2.winnr, 'quickfix_title', ''))
                                call setwinvar(a:2.winnr, 'airline_section_c', '[%{get(w:, "quickfix_title", "")}] %f %m')
                              endif

FUNCTION  <SNR>34_BufEnterHook()
Called 1 time
Total time:   2.137364
 Self time:   0.000062

count  total (s)   self (s)
    1   0.000054   0.000005     let buf = syntastic#util#fname2buf(a:fname)
    1   0.000023   0.000011     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS, 'autocmd: BufEnter, buffer ' . buf . ' = ' . string(a:fname) . ', &buftype = ' . string(&buftype))
    1              0.000003     if buf > 0 && getbufvar(buf, '&buftype') ==# ''
    1              0.000005         let idx = index(reverse(copy(s:_check_stack)), buf)
    1              0.000001         if idx >= 0
    1              0.000002             if !has('vim_starting')
    1              0.000002                 call remove(s:_check_stack, -idx - 1)
    1   2.137256   0.000015                 call s:UpdateErrors(buf, 1, [])
    1              0.000000             endif
    1              0.000001         elseif &buftype ==# ''
                                        call s:notifiers.refresh(g:SyntasticLoclist.current())
                                    endif
    1              0.000001     elseif &buftype ==# 'quickfix'
                                    " TODO: this is needed because in recent versions of Vim lclose
                                    " can no longer be called from BufWinLeave
                                    " TODO: at this point there is no b:syntastic_loclist
                                    let loclist = filter(copy(getloclist(0)), 'v:val["valid"]')
                                    let owner = str2nr(getbufvar(buf, 'syntastic_owner_buffer'))
                                    let buffers = syntastic#util#unique(map(loclist, 'v:val["bufnr"]') + (owner ? [owner] : []))
                                    if !empty(get(w:, 'syntastic_loclist_set', [])) && !empty(loclist) && empty(filter( buffers, 'syntastic#util#bufIsActive(v:val)' ))
                                        call SyntasticLoclistHide()
                                    endif
                                endif

FUNCTION  syntastic#log#debug()
Called 32 times
Total time:   0.000190
 Self time:   0.000122

count  total (s)   self (s)
   32   0.000158   0.000090     if !s:_isDebugEnabled(a:level)
   32              0.000021         return
                                endif
                            
                                let leader = s:_log_timestamp()
                                call s:_logRedirect(1)
                            
                                if a:0
                                    " filter out dictionary functions
                                    echomsg leader . a:msg . ' ' . strtrans(string(type(a:1) == type({}) || type(a:1) == type([]) ? filter(copy(a:1), 'type(v:val) != type(function("tr"))') : a:1))
                                else
                                    echomsg leader . a:msg
                                endif
                            
                                call s:_logRedirect(0)

FUNCTION  airline#util#exec_funcrefs()
Called 12 times
Total time:   0.006613
 Self time:   0.000673

count  total (s)   self (s)
   60              0.000081     for Fn in a:list
   60   0.006343   0.000403       let code = call(Fn, a:000)
   60              0.000054       if code != 0
   12              0.000009         return code
                                  endif
   48              0.000033     endfor
                                return 0

FUNCTION  gitgutter#utility#command_in_directory_of_file()
Called 1 time
Total time:   0.000021
 Self time:   0.000011

count  total (s)   self (s)
    1   0.000021   0.000011   return 'cd '.gitgutter#utility#shellescape(gitgutter#utility#directory_of_file()).' && '.a:cmd

FUNCTION  gitgutter#process_buffer()
Called 2 times
Total time:   0.005260
 Self time:   0.000344

count  total (s)   self (s)
    2   0.000124   0.000034   call gitgutter#utility#use_known_shell()
                            
    2   0.000069   0.000029   call gitgutter#utility#set_buffer(a:bufnr)
    2   0.000137   0.000025   if gitgutter#utility#is_active()
    1              0.000002     if g:gitgutter_sign_column_always
                                  call gitgutter#sign#add_dummy_sign()
                                endif
    1              0.000000     try
    1              0.000001       if !a:realtime || gitgutter#utility#has_fresh_changes()
    1   0.004534   0.000088         let diff = gitgutter#diff#run_diff(a:realtime || gitgutter#utility#has_unsaved_changes(), 0)
    1              0.000001         if diff != 'async'
                                      call gitgutter#handle_diff(diff)
                                    endif
    1              0.000001       endif
    1              0.000003     catch /diff failed/
                                  call gitgutter#debug#log('diff failed')
                                  call gitgutter#hunk#reset()
                                endtry
    1   0.000025   0.000019     execute "silent doautocmd" s:nomodeline "User GitGutter"
    1              0.000001   else
    1   0.000178   0.000020     call gitgutter#hunk#reset()
    1              0.000002   endif
                            
    2   0.000093   0.000029   call gitgutter#utility#restore_shell()

FUNCTION  <SNR>32__normalise_filetype()
Called 2 times
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    2              0.000008     let ft = get(s:_DEFAULT_FILETYPE_MAP, a:ftalias, a:ftalias)
    2              0.000004     let ft = get(g:syntastic_filetype_map, ft, ft)
    2              0.000006     let ft = substitute(ft, '\m-', '_', 'g')
    2              0.000001     return ft

FUNCTION  gitgutter#sign#remove_signs()
Called 1 time
Total time:   0.000030
 Self time:   0.000020

count  total (s)   self (s)
    1   0.000004   0.000003   let bufnr = gitgutter#utility#bufnr()
    1   0.000009   0.000004   if a:all_signs && s:supports_star && empty(gitgutter#utility#getbufvar(bufnr, 'other_signs'))
    1   0.000007   0.000003     let dummy_sign_present = gitgutter#utility#getbufvar(bufnr, 'dummy_sign')
    1              0.000004     execute "sign unplace * buffer=" . bufnr
    1              0.000001     if dummy_sign_present
                                  execute "sign place" s:dummy_sign_id "line=" . 9999 "name=GitGutterDummy buffer=" . bufnr
                                endif
    1              0.000000   else
                                for id in a:sign_ids
                                  execute "sign unplace" id
                                endfor
                              endif

FUNCTION  <SNR>85_get_seperator()
Called 40 times
Total time:   0.030333
 Self time:   0.000294

count  total (s)   self (s)
   40   0.005996   0.000124   if s:should_change_group(a:prev_group, a:group)
   40   0.024324   0.000157     return s:get_transitioned_seperator(a:self, a:prev_group, a:group, a:side)
                              else
                                return a:side ? a:self._context.left_alt_sep : a:self._context.right_alt_sep
                              endif

FUNCTION  syntastic#log#debugShowOptions()
Called 1 time
Total time:   0.000007
 Self time:   0.000006

count  total (s)   self (s)
    1   0.000006   0.000005     if !s:_isDebugEnabled(a:level)
    1              0.000001         return
                                endif
                            
                                let leader = s:_log_timestamp()
                                call s:_logRedirect(1)
                            
                                let vlist = copy(type(a:names) == type('') ? [a:names] : a:names)
                                let add_shell = index(vlist, 'shell') >= 0 && &shell !=# syntastic#util#var('shell')
                                if !empty(vlist)
                                    call map(vlist, "'&' . v:val . ' = ' . strtrans(string(eval('&' . v:val))) . (s:_is_modified(v:val) ? ' (!)' : '')")
                                    if add_shell
                                        call add(vlist, 'u:shell = ' . strtrans(string(syntastic#util#var('shell'))) . ' (!)')
                                    endif
                                    echomsg leader . join(vlist, ', ')
                                endif
                                call s:_logRedirect(0)

FUNCTION  airline#check_mode()
Called 8 times
Total time:   0.024017
 Self time:   0.001348

count  total (s)   self (s)
    8              0.000059   let context = s:contexts[a:winnr]
                            
    8              0.000049   if get(w:, 'airline_active', 1)
    7              0.000043     let l:m = mode()
    7              0.000027     if l:m ==# "i"
                                  let l:mode = ['insert']
                                elseif l:m ==# "R"
                                  let l:mode = ['replace']
                                elseif l:m =~# '\v(v|V||s|S|)'
                                  let l:mode = ['visual']
                                elseif l:m ==# "t"
                                  let l:mode = ['terminal']
                                else
    7              0.000032       let l:mode = ['normal']
    7              0.000011     endif
    7              0.000067     let w:airline_current_mode = get(g:airline_mode_map, l:m, l:m)
    7              0.000009   else
    1              0.000001     let l:mode = ['inactive']
    1              0.000005     let w:airline_current_mode = get(g:airline_mode_map, '__')
    1              0.000001   endif
                            
    8              0.000048   if g:airline_detect_modified && &modified
                                call add(l:mode, 'modified')
                              endif
                            
    8              0.000026   if g:airline_detect_paste && &paste
                                call add(l:mode, 'paste')
                              endif
                            
    8              0.000069   if g:airline_detect_crypt && exists("+key") && !empty(&key)
                                call add(l:mode, 'crypt')
                              endif
                            
    8              0.000030   if g:airline_detect_spell && &spell
                                call add(l:mode, 'spell')
                              endif
                            
    8              0.000024   if &readonly || ! &modifiable
    6              0.000047     call add(l:mode, 'readonly')
    6              0.000009   endif
                            
    8              0.000058   let mode_string = join(l:mode)
    8              0.000055   if get(w:, 'airline_lastmode', '') != mode_string
    2   0.000340   0.000019     call airline#highlighter#highlight_modified_inactive(context.bufnr)
    2   0.022365   0.000017     call airline#highlighter#highlight(l:mode, context.bufnr)
    2              0.000004     let w:airline_lastmode = mode_string
    2              0.000001   endif
                            
    8              0.000020   return ''

FUNCTION  <SNR>85_section_is_empty()
Called 70 times
Total time:   0.000459
 Self time:   0.000459

count  total (s)   self (s)
   70              0.000058   let start=1
                            
                              " do not check for inactive windows or the tabline
   70              0.000073   if a:self._context.active == 0
   26              0.000016     return 0
                              elseif get(a:self._context, 'tabline', 0)
                                return 0
                              endif
                            
                              " only check, if airline#skip_empty_sections == 1
   44              0.000070   if get(g:, 'airline_skip_empty_sections', 0) == 0
   44              0.000024     return 0
                              endif
                            
                              " only check, if airline#skip_empty_sections == 1
                              if get(w:, 'airline_skip_empty_sections', -1) == 0
                                return 0
                              endif
                              " assume accents sections to be never empty
                              " (avoides, that on startup the mode message becomes empty)
                              if match(a:content, '%#__accent_[^#]*#.*__restore__#') > -1
                                return 0
                              endif
                              if empty(a:content)
                                return 1
                              endif
                              let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              if empty(list)
                                return 0 " no function in statusline text
                              endif
                              while len(list) > 0
                                let expr = list[0]
                                try
                                  " catch all exceptions, just in case
                                  if !empty(eval(expr))
                                    return 0
                                  endif
                                catch
                                  return 0
                                endtry
                                let start += 1
                                let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              endw
                              return 1

FUNCTION  airline#util#append()
Called 14 times
Total time:   0.000081
 Self time:   0.000081

count  total (s)   self (s)
   14              0.000019   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
   14              0.000022   let prefix = s:spc == "\ua0" ? s:spc : s:spc.s:spc
   14              0.000023   return empty(a:text) ? '' : prefix.g:airline_left_alt_sep.s:spc.a:text

FUNCTION  <SNR>86_add_section()
Called 56 times
Total time:   0.002349
 Self time:   0.000917

count  total (s)   self (s)
   56              0.000158     let condition = (a:key is# "warning" || a:key is# "error") && (v:version == 704 && !has("patch1511"))
                                " i have no idea why the warning section needs special treatment, but it's
                                " needed to prevent separators from showing up
   56   0.000313   0.000153     if ((a:key == 'error' || a:key == 'warning') && empty(s:get_section(a:context.winnr, a:key)))
                                  return
                                endif
   56              0.000031     if condition
                                  call a:builder.add_raw('%(')
                                endif
   56   0.001536   0.000264     call a:builder.add_section('airline_'.a:key, s:get_section(a:context.winnr, a:key))
   56              0.000044     if condition
                                  call a:builder.add_raw('%)')
                                endif

FUNCTION  syntastic#c#GetLocList()
Called 1 time
Total time:   2.125049
 Self time:   0.000050

count  total (s)   self (s)
    1              0.000001     try
    1   0.000961   0.000008         let flags = s:_get_cflags(a:filetype, a:subchecker, a:options)
    1              0.000001     catch /\m\C^Syntastic: skip checks$/
                                    return []
                                endtry
                            
    1   0.000039   0.000012     let makeprg = syntastic#util#shexpand(g:syntastic_{a:filetype}_compiler) . ' ' . flags . ' ' . syntastic#util#shexpand('%')
                            
    1   0.000017   0.000005     let errorformat = s:_get_checker_var('g', a:filetype, a:subchecker, 'errorformat', a:options['errorformat'])
                            
    1   0.000015   0.000005     let postprocess = s:_get_checker_var('g', a:filetype, a:subchecker, 'remove_include_errors', 0) ? ['filterForeignErrors'] : []
                            
                                " process makeprg
    1   2.124010   0.000013     return SyntasticMake({ 'makeprg': makeprg, 'errorformat': errorformat, 'postprocess': postprocess })

FUNCTION  <SNR>34_UpdateErrors()
Called 1 time
Total time:   2.137241
 Self time:   0.000139

count  total (s)   self (s)
    1   0.000016   0.000010     call syntastic#log#debugShowVariables(g:_SYNTASTIC_DEBUG_TRACE, 'version')
    1   0.000032   0.000025     call syntastic#log#debugShowOptions(g:_SYNTASTIC_DEBUG_TRACE, g:_SYNTASTIC_SHELL_OPTIONS)
    1   0.000011   0.000007     call syntastic#log#debugDump(g:_SYNTASTIC_DEBUG_VARIABLES)
    1   0.000010   0.000006     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'UpdateErrors' . (a:auto_invoked ? ' (auto)' : '') . ': ' . (len(a:checker_names) ? join(a:checker_names) : 'default checkers'))
                            
    1   0.000019   0.000005     call s:modemap.synch()
                            
    1   0.000074   0.000007     if s:_skip_file(a:buf)
                                    return
                                endif
                            
    1   0.000081   0.000007     let run_checks = !a:auto_invoked || s:modemap.doAutoChecking(a:buf)
    1              0.000001     if run_checks
    1   2.136248   0.000012         call s:CacheErrors(a:buf, a:checker_names)
    1   0.000014   0.000010         call syntastic#util#setLastTick(a:buf)
    1              0.000001     elseif a:auto_invoked
                                    return
                                endif
                            
    1   0.000021   0.000003     let loclist = g:SyntasticLoclist.current(a:buf)
                            
    1              0.000002     if exists('*SyntasticCheckHook')
                                    call SyntasticCheckHook(loclist.getRaw())
                                endif
                            
                                " populate loclist and jump {{{3
    1   0.000010   0.000003     let do_jump = syntastic#util#var('auto_jump') + 0
    1              0.000000     if do_jump == 2
                                    let do_jump = loclist.getFirstError(1)
                                elseif do_jump == 3
                                    let do_jump = loclist.getFirstError()
                                elseif 0 > do_jump || do_jump > 3
                                    let do_jump = 0
                                endif
                            
    1   0.000008   0.000001     if syntastic#util#var('always_populate_loc_list') || do_jump
    1   0.000046   0.000004         call loclist.setloclist(1)
    1              0.000001         if run_checks && do_jump && !loclist.isEmpty()
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'loclist: jump')
                                        execute 'silent! lrewind ' . do_jump
                            
                                        " XXX: Vim doesn't call autocmd commands in a predictible
                                        " order, which can lead to missing filetype when jumping
                                        " to a new file; the following is a workaround for the
                                        " resulting brain damage
                                        if &filetype ==# ''
                                            silent! filetype detect
                                        endif
                                    endif
    1              0.000000     endif
                                " }}}3
                            
    1   0.000621   0.000009     call s:notifiers.refresh(loclist)

FUNCTION  <SNR>34_ClearCache()
Called 1 time
Total time:   0.000278
 Self time:   0.000016

count  total (s)   self (s)
    1   0.000062   0.000007     let loclist = g:SyntasticLoclist.current(a:buf)
    1   0.000172   0.000005     call s:notifiers.reset(loclist)
    1   0.000044   0.000004     call loclist.destroy()

FUNCTION  <SNR>68_sync_active_winnr()
Called 3 times
Total time:   0.000075
 Self time:   0.000075

count  total (s)   self (s)
    3              0.000043   if exists('#airline') && winnr() != s:active_winnr
                                call airline#update_statusline()
                              endif

FUNCTION  airline#themes#get_highlight()
Called 220 times
Total time:   0.015219
 Self time:   0.000814

count  total (s)   self (s)
  220   0.015176   0.000771   return call('airline#highlighter#get_highlight', [a:group] + a:000)

FUNCTION  <SNR>81_get_array()
Called 514 times
Total time:   0.002593
 Self time:   0.002593

count  total (s)   self (s)
  514              0.001045   let opts=empty(a:opts) ? '' : join(a:opts, ',')
  514              0.001407   return g:airline_gui_mode ==# 'gui' ? [ a:fg, a:bg, '', '', opts ] : [ '', '', a:fg, a:bg, opts ]

FUNCTION  gitgutter#sign#update_signs()
Called 1 time
Total time:   0.000209
 Self time:   0.000047

count  total (s)   self (s)
    1   0.000081   0.000008   call gitgutter#sign#find_current_signs()
                            
    1              0.000003   let new_gitgutter_signs_line_numbers = map(copy(a:modified_lines), 'v:val[0]')
    1   0.000037   0.000011   let obsolete_signs = gitgutter#sign#obsolete_gitgutter_signs_to_remove(new_gitgutter_signs_line_numbers)
                            
    1              0.000002   let flicker_possible = s:remove_all_old_signs && !empty(a:modified_lines)
    1              0.000001   if flicker_possible
                                call gitgutter#sign#add_dummy_sign()
                              endif
                            
    1   0.000037   0.000007   call gitgutter#sign#remove_signs(obsolete_signs, s:remove_all_old_signs)
    1   0.000041   0.000008   call gitgutter#sign#upsert_new_gitgutter_signs(a:modified_lines)
                            
    1              0.000001   if flicker_possible
                                call gitgutter#sign#remove_dummy_sign(0)
                              endif

FUNCTION  syntastic#util#shescape()
Called 8 times
Total time:   0.000052
 Self time:   0.000052

count  total (s)   self (s)
    8              0.000051     return a:string =~# '\m^[A-Za-z0-9_/.-]\+$' ? a:string : shellescape(a:string)

FUNCTION  <SNR>85_should_change_group()
Called 40 times
Total time:   0.005872
 Self time:   0.000563

count  total (s)   self (s)
   40              0.000053   if a:group1 == a:group2
                                return 0
                              endif
   40   0.002906   0.000131   let color1 = airline#highlighter#get_highlight(a:group1)
   40   0.002643   0.000109   let color2 = airline#highlighter#get_highlight(a:group2)
   40              0.000035   if g:airline_gui_mode ==# 'gui'
                                return color1[1] != color2[1] || color1[0] != color2[0]
                              else
   40              0.000093     return color1[3] != color2[3] || color1[2] != color2[2]
                              endif

FUNCTION  gitgutter#utility#is_file_buffer()
Called 3 times
Total time:   0.000032
 Self time:   0.000032

count  total (s)   self (s)
    3              0.000028   return empty(getbufvar(s:bufnr, '&buftype'))

FUNCTION  <SNR>34__skip_file()
Called 2 times
Total time:   0.000122
 Self time:   0.000076

count  total (s)   self (s)
    2              0.000003     let fname = bufname(a:buf)
    2   0.000109   0.000063     let skip = s:_is_quitting(a:buf) || getbufvar(a:buf, 'syntastic_skip_checks') || (getbufvar(a:buf, '&buftype') !=# '') || !filereadable(fname) || getwinvar(0, '&diff') || getwinvar(0, '&previewwindow') || s:_ignore_file(fname) || fnamemodify(fname, ':e') =~? g:syntastic_ignore_extensions
    2              0.000001     if skip
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, '_skip_file: skipping checks')
                                endif
    2              0.000002     return skip

FUNCTION  airline#highlighter#add_accent()
Called 4 times
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    4              0.000007   let s:accents[a:accent] = 1

FUNCTION  airline#extensions#default#apply()
Called 12 times
Total time:   0.003884
 Self time:   0.000564

count  total (s)   self (s)
   12              0.000029   let winnr = a:context.winnr
   12              0.000021   let active = a:context.active
                            
   12   0.000152   0.000103   if airline#util#getwinvar(winnr, 'airline_render_left', active || (!active && !g:airline_inactive_collapse))
   10   0.001681   0.000156     call s:build_sections(a:builder, a:context, s:layout[0])
   10              0.000003   else
    2   0.000053   0.000006     let text = s:get_section(winnr, 'c')
    2              0.000002     if empty(text)
                                  let text = ' %f%m '
                                endif
    2   0.000014   0.000010     call a:builder.add_section('airline_c'.(a:context.bufnr), text)
    2              0.000000   endif
                            
   12   0.000391   0.000064   call a:builder.split(s:get_section(winnr, 'gutter', '', ''))
                            
   12   0.000053   0.000030   if airline#util#getwinvar(winnr, 'airline_render_right', 1)
    6   0.001369   0.000024     call s:build_sections(a:builder, a:context, s:layout[1])
    6              0.000002   endif
                            
   12              0.000010   return 1

FUNCTION  gitgutter#sign#find_current_signs()
Called 1 time
Total time:   0.000073
 Self time:   0.000053

count  total (s)   self (s)
    1   0.000004   0.000003   let bufnr = gitgutter#utility#bufnr()
    1              0.000002   let gitgutter_signs = {}  " <line_number (string)>: {'id': <id (number)>, 'name': <name (string)>}
    1              0.000001   let other_signs = []      " [<line_number (number),...]
    1              0.000001   let dummy_sign_placed = 0
                            
    1              0.000002   redir => signs
    1              0.000008     silent execute "sign place buffer=" . bufnr
    1              0.000002   redir END
                            
    1              0.000007   for sign_line in filter(split(signs, '\n')[2:], 'v:val =~# "="')
                                " Typical sign line:  line=88 id=1234 name=GitGutterLineAdded
                                " We assume splitting is faster than a regexp.
                                let components  = split(sign_line)
                                let name        = split(components[2], '=')[1]
                                if name =~# 'GitGutterDummy'
                                  let dummy_sign_placed = 1
                                else
                                  let line_number = str2nr(split(components[0], '=')[1])
                                  if name =~# 'GitGutter'
                                    let id = str2nr(split(components[1], '=')[1])
                                    " Remove orphaned signs (signs placed on lines which have been deleted).
                                    " (When a line is deleted its sign lingers.  Subsequent lines' signs'
                                    " line numbers are decremented appropriately.)
                                    if has_key(gitgutter_signs, line_number)
                                      execute "sign unplace" gitgutter_signs[line_number].id
                                    endif
                                    let gitgutter_signs[line_number] = {'id': id, 'name': name}
                                  else
                                    call add(other_signs, line_number)
                                  endif
                                end
                              endfor
                            
    1   0.000012   0.000004   call gitgutter#utility#setbufvar(bufnr, 'dummy_sign', dummy_sign_placed)
    1   0.000009   0.000003   call gitgutter#utility#setbufvar(bufnr, 'gitgutter_signs', gitgutter_signs)
    1   0.000008   0.000003   call gitgutter#utility#setbufvar(bufnr, 'other_signs', other_signs)

FUNCTION  <SNR>75_check_mixed_indent_file()
Called 1 time
Total time:   0.000057
 Self time:   0.000057

count  total (s)   self (s)
    1              0.000003   let c_like_langs = get(g:, 'airline#extensions#c_like_langs', [ 'c', 'cpp', 'cuda', 'go', 'javascript', 'ld', 'php' ])
    1              0.000008   if index(c_like_langs, &ft) > -1
                                " for C-like languages: allow /** */ comment style with one space before the '*'
    1              0.000001     let head_spc = '\v(^ +\*@!)'
    1              0.000000   else
                                let head_spc = '\v(^ +)'
                              endif
    1              0.000011   let indent_tabs = search('\v(^\t+)', 'nw')
    1              0.000026   let indent_spc  = search(head_spc, 'nw')
    1              0.000001   if indent_tabs > 0 && indent_spc > 0
                                return printf("%d:%d", indent_tabs, indent_spc)
                              else
    1              0.000000     return ''
                              endif

FUNCTION  airline#parts#filetype()
Called 2 times
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    2              0.000007   return winwidth(0) < 90 && strlen(&filetype) > 3 ? matchstr(&filetype, '...'). (&encoding is? 'utf-8' ? '' : '>') : &filetype

FUNCTION  airline#extensions#netrw#apply()
Called 6 times
Total time:   0.000101
 Self time:   0.000101

count  total (s)   self (s)
    6              0.000030   if &ft == 'netrw'
                                let spc = g:airline_symbols.space
                            
                                call a:1.add_section('airline_a', spc.'netrw'.spc)
                                if exists('*airline#extensions#branch#get_head')
                                  call a:1.add_section('airline_b', spc.'%{airline#extensions#branch#get_head()}'.spc)
                                endif
                                call a:1.add_section('airline_c', spc.'%f'.spc)
                                call a:1.split()
                                call a:1.add_section('airline_y', spc.'%{airline#extensions#netrw#sortstring()}'.spc)
                                return 1
                              endif

FUNCTION  airline#parts#iminsert()
Called 2 times
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    2              0.000003   if g:airline_detect_iminsert && &iminsert && exists('b:keymap_name')
                                return toupper(b:keymap_name)
                              endif
    2              0.000001   return ''

FUNCTION  <SNR>81_get_syn()
Called 1028 times
Total time:   0.016998
 Self time:   0.016998

count  total (s)   self (s)
 1028              0.001680   if !exists("g:airline_gui_mode")
                                let g:airline_gui_mode = airline#init#gui_mode()
                              endif
 1028              0.000747   let color = ''
 1028              0.001913   if hlexists(a:group)
  900              0.002965     let color = synIDattr(synIDtrans(hlID(a:group)), a:what, g:airline_gui_mode)
  900              0.000386   endif
 1028              0.001348   if empty(color) || color == -1
                                " should always exists
  154              0.000489     let color = synIDattr(synIDtrans(hlID('Normal')), a:what, g:airline_gui_mode)
                                " however, just in case
  154              0.000168     if empty(color) || color == -1
  154              0.000121       let color = 'NONE'
  154              0.000051     endif
  154              0.000063   endif
 1028              0.000708   return color

FUNCTION  airline#extensions#term#apply()
Called 6 times
Total time:   0.000063
 Self time:   0.000063

count  total (s)   self (s)
    6              0.000008   if &buftype == 'terminal'
                                let spc = g:airline_symbols.space
                            
                                call a:1.add_section('airline_a', spc.'TERMINAL'.spc)
                                call a:1.add_section('airline_b', '')
                                call a:1.add_section('airline_c', spc.'%f')
                                call a:1.split()
                                call a:1.add_section('airline_y', '')
                                call a:1.add_section('airline_z', spc.airline#section#create_right(['linenr', 'maxlinenr']))
                                return 1
                              endif

FUNCTION  gitgutter#utility#use_known_shell()
Called 2 times
Total time:   0.000090
 Self time:   0.000090

count  total (s)   self (s)
    2              0.000011   if has('unix')
    2              0.000010     if &shell !=# 'sh'
    2              0.000010       let s:shell = &shell
    2              0.000008       let s:shellcmdflag = &shellcmdflag
    2              0.000005       let s:shellredir = &shellredir
    2              0.000014       let &shell = 'sh'
    2              0.000012       set shellcmdflag=-c
    2              0.000008       set shellredir=>%s\ 2>&1
    2              0.000003     endif
    2              0.000003   endif

FUNCTION  syntastic#util#Slash()
Called 3 times
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    3              0.000008     return (!exists('+shellslash') || &shellslash) ? '/' : '\'

FUNCTION  <SNR>73_get_hunks_gitgutter()
Called 2 times
Total time:   0.000060
 Self time:   0.000019

count  total (s)   self (s)
    2   0.000016   0.000008   if !get(g:, 'gitgutter_enabled', 0) || s:is_branch_empty()
                                return ''
                              endif
    2   0.000041   0.000008   return GitGutterGetHunkSummary()

FUNCTION  <SNR>85_get_prev_group()
Called 70 times
Total time:   0.000539
 Self time:   0.000539

count  total (s)   self (s)
   70              0.000094   let x = a:i - 1
   76              0.000067   while x >= 0
   64              0.000101     let group = a:sections[x][0]
   64              0.000096     if group != '' && group != '|'
   58              0.000052       return group
                                endif
    6              0.000005     let x = x - 1
    6              0.000001   endwhile
   12              0.000007   return ''

FUNCTION  10()
Called 1 time
Total time:   0.000072
 Self time:   0.000008

count  total (s)   self (s)
    1   0.000008   0.000003     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'autoloclist: refresh')
    1   0.000064   0.000005     call g:SyntasticAutoloclistNotifier.AutoToggle(a:loclist)

FUNCTION  11()
Called 1 time
Total time:   0.000059
 Self time:   0.000039

count  total (s)   self (s)
    1   0.000006   0.000002     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'autoloclist: toggle')
    1   0.000009   0.000003     let auto_loc_list = syntastic#util#var('auto_loc_list')
    1   0.000003   0.000002     if !a:loclist.isEmpty()
                                    if auto_loc_list == 1 || auto_loc_list == 3
                                        call a:loclist.show()
                                    endif
                                else
    1              0.000003         if (auto_loc_list == 1 || auto_loc_list == 2) && !empty(get(w:, 'syntastic_loclist_set', []))
    1              0.000000             try
                                            " Vim 7.4.2200 or later
    1              0.000004                 let title = get(getloclist(0, { 'title': 1 }), 'title', ':SyntasticCheck ')
    1              0.000001             catch /\m^Vim\%((\a\+)\)\=:E\%(118\|731\)/
                                            let title = ':SyntasticCheck '
                                        endtry
                            
    1              0.000002             if strpart(title, 0, 16) ==# ':SyntasticCheck '
                                            " TODO: this will close the loc list window if one was opened
                                            " by something other than syntastic
    1   0.000014   0.000005                 call SyntasticLoclistHide()
                            
    1              0.000001                 try
                                                " Vim 7.4.2200 or later
    1              0.000003                     call setloclist(0, [], 'r', { 'title': '' })
    1              0.000001                 catch /\m^Vim\%((\a\+)\)\=:E\%(118\|731\)/
                                                " do nothing
                                            endtry
    1              0.000001                 let w:syntastic_loclist_set = []
    1              0.000001             endif
    1              0.000000         endif
    1              0.000001     endif

FUNCTION  <SNR>34__ignore_file()
Called 2 times
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
    2              0.000013     let fname = fnamemodify(a:filename, ':p')
    2              0.000004     for pattern in g:syntastic_ignore_files
                                    if fname =~# pattern
                                        return 1
                                    endif
                                endfor
    2              0.000002     return 0

FUNCTION  13()
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000004     return has('balloon_eval') && syntastic#util#var('enable_balloons')

FUNCTION  15()
Called 1 time
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    1              0.000002     let b:syntastic_private_balloons = {}
    1              0.000003     if has('balloon_eval')
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'balloons: reset')
                                    unlet! b:syntastic_private_balloons
                                    set noballooneval
                                endif

FUNCTION  16()
Called 24 times
Total time:   0.001366
 Self time:   0.001366

count  total (s)   self (s)
   24              0.000164     let newObj = copy(self)
                            
   24              0.000047     let newObj._filetype = a:args['filetype']
   24              0.000038     let newObj._name = a:args['name']
                            
   24              0.000017     if a:0
                                    " redirected checker
    8              0.000024         let newObj._exec_default = get(a:args, 'exec', a:1['_exec_default'])
                            
    8              0.000013         let filetype = a:1['_filetype']
    8              0.000010         let name = a:1['_name']
    8              0.000018         let prefix = 'SyntaxCheckers_' . filetype . '_' . name . '_'
                            
    8              0.000039         if exists('g:syntastic_' . filetype . '_' . name . '_sort') && !exists('g:syntastic_' . newObj._filetype . '_' . newObj._name . '_sort')
    4              0.000024             let g:syntastic_{newObj._filetype}_{newObj._name}_sort = g:syntastic_{filetype}_{name}_sort
    4              0.000000         endif
                            
    8              0.000012         if has_key(a:args, 'enable')
                                        let newObj._enable = a:args['enable']
                                    elseif has_key(a:1, '_enable')
                                        let newObj._enable = a:1['_enable']
                                    endif
    8              0.000006     else
   16              0.000043         let newObj._exec_default = get(a:args, 'exec', newObj._name)
   16              0.000018         if newObj._exec_default ==# ''
                                        let newObj._exec_default = '<dummy>'
                                    endif
   16              0.000039         let prefix = 'SyntaxCheckers_' . newObj._filetype . '_' . newObj._name . '_'
                            
   16              0.000024         if has_key(a:args, 'enable')
                                        let newObj._enable = a:args['enable']
                                    endif
   16              0.000006     endif
                            
   24              0.000074     let newObj._locListFunc = function(prefix . 'GetLocList')
                            
   24              0.000059     if exists('*' . prefix . 'IsAvailable')
    3              0.000009         let newObj._isAvailableFunc = function(prefix . 'IsAvailable')
    3              0.000001     else
   21              0.000067         let newObj._isAvailableFunc = function('s:_isAvailableDefault')
   21              0.000009     endif
                            
   24              0.000066     if exists('*' . prefix . 'GetHighlightRegex')
    2              0.000004         let newObj._highlightRegexFunc = function(prefix . 'GetHighlightRegex')
    2              0.000002     endif
                            
   24              0.000021     return newObj

FUNCTION  17()
Called 25 times
Total time:   0.000032
 Self time:   0.000032

count  total (s)   self (s)
   25              0.000026     return self._filetype

FUNCTION  19()
Called 3 times
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    3              0.000006     return self._filetype . '/' . self._name

FUNCTION  syntastic#util#stamp()
Called 2 times
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
    2              0.000022     return split( split(reltimestr(reltime(g:_SYNTASTIC_START)))[0], '\.' )

FUNCTION  100()
Called 1 time
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    1              0.000004     if exists('g:syntastic_' . a:filetype . '_checkers') && type(g:syntastic_{a:filetype}_checkers) != type([])
                            
                                    unlet! g:syntastic_{a:filetype}_checkers
                                    call syntastic#log#error('variable g:syntastic_' . a:filetype . '_checkers has to be a list of strings')
                                endif
                            
    1              0.000004     if exists('g:syntastic_' . a:filetype . '_checker') && !exists('g:syntastic_' . a:filetype . '_checkers') && type(g:syntastic_{a:filetype}_checker) == type('')
                            
                                    let g:syntastic_{a:filetype}_checkers = [g:syntastic_{a:filetype}_checker]
                                    call syntastic#log#oneTimeWarn('variable g:syntastic_' . a:filetype . '_checker is deprecated')
                                endif

FUNCTION  102()
Called 2 times
Total time:   0.000035
 Self time:   0.000019

count  total (s)   self (s)
    2   0.000035   0.000019     return has('signs') && syntastic#util#var('enable_signs')

FUNCTION  103()
Called 1 time
Total time:   0.000170
 Self time:   0.000031

count  total (s)   self (s)
    1   0.000012   0.000004     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'signs: refresh')
                            
    1   0.000011   0.000005     let old_signs = copy(self._bufSignIds())
    1   0.000012   0.000001     if self.enabled()
    1              0.000001         if !s:setup_done
    1   0.000079   0.000003             call self._setup()
    1              0.000002             let s:setup_done = 1
    1              0.000001             lockvar s:setup_done
    1              0.000000         endif
                            
    1   0.000035   0.000006         call self._signErrors(a:loclist)
    1              0.000001     endif
    1   0.000013   0.000004     call self._removeSigns(old_signs)

FUNCTION  104()
Called 1 time
Total time:   0.000076
 Self time:   0.000076

count  total (s)   self (s)
    1              0.000002     if has('signs')
    1              0.000009         if !hlexists('SyntasticErrorSign')
    1              0.000006             highlight link SyntasticErrorSign error
    1              0.000000         endif
    1              0.000003         if !hlexists('SyntasticWarningSign')
    1              0.000003             highlight link SyntasticWarningSign todo
    1              0.000000         endif
    1              0.000003         if !hlexists('SyntasticStyleErrorSign')
    1              0.000002             highlight link SyntasticStyleErrorSign SyntasticErrorSign
    1              0.000001         endif
    1              0.000002         if !hlexists('SyntasticStyleWarningSign')
    1              0.000002             highlight link SyntasticStyleWarningSign SyntasticWarningSign
    1              0.000001         endif
    1              0.000002         if !hlexists('SyntasticStyleErrorLine')
    1              0.000011             highlight link SyntasticStyleErrorLine SyntasticErrorLine
    1              0.000000         endif
    1              0.000003         if !hlexists('SyntasticStyleWarningLine')
    1              0.000003             highlight link SyntasticStyleWarningLine SyntasticWarningLine
    1              0.000000         endif
                            
                                    " define the signs used to display syntax and style errors/warns
    1              0.000008         execute 'sign define SyntasticError text=' . g:syntastic_error_symbol . ' texthl=SyntasticErrorSign linehl=SyntasticErrorLine'
    1              0.000004         execute 'sign define SyntasticWarning text=' . g:syntastic_warning_symbol . ' texthl=SyntasticWarningSign linehl=SyntasticWarningLine'
    1              0.000004         execute 'sign define SyntasticStyleError text=' . g:syntastic_style_error_symbol . ' texthl=SyntasticStyleErrorSign linehl=SyntasticStyleErrorLine'
    1              0.000004         execute 'sign define SyntasticStyleWarning text=' . g:syntastic_style_warning_symbol . ' texthl=SyntasticStyleWarningSign linehl=SyntasticStyleWarningLine'
    1              0.000001     endif

FUNCTION  105()
Called 1 time
Total time:   0.000029
 Self time:   0.000027

count  total (s)   self (s)
    1              0.000001     let loclist = a:loclist
    1   0.000004   0.000002     if !loclist.isEmpty()
                            
                                    let buf = bufnr('')
                                    if !bufloaded(buf)
                                        " signs can be placed only in loaded buffers
                                        return
                                    endif
                            
                                    " errors come first, so that they are not masked by warnings
                                    let issues = copy(loclist.errors())
                                    call extend(issues, loclist.warnings())
                                    call filter(issues, 'v:val["bufnr"] == buf')
                                    let seen = {}
                            
                                    for i in issues
                                        if i['lnum'] > 0 && !has_key(seen, i['lnum'])
                                            let seen[i['lnum']] = 1
                            
                                            let sign_severity = i['type'] ==? 'W' ? 'Warning' : 'Error'
                                            let sign_subtype = get(i, 'subtype', '')
                                            let sign_type = 'Syntastic' . sign_subtype . sign_severity
                            
                                            execute 'sign place ' . s:next_sign_id . ' line=' . i['lnum'] . ' name=' . sign_type . ' buffer=' . i['bufnr']
                                            call add(self._bufSignIds(), s:next_sign_id)
                                            let s:next_sign_id += 1
                                        endif
                                    endfor
                                endif

FUNCTION  106()
Called 1 time
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    1              0.000002     if has('signs')
    1              0.000003         for s in reverse(copy(a:ids))
                                        execute 'sign unplace ' . s
                                        call remove(self._bufSignIds(), index(self._bufSignIds(), s))
                                    endfor
    1              0.000001     endif

FUNCTION  107()
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000002     if !exists('b:syntastic_private_sign_ids')
    1              0.000002         let b:syntastic_private_sign_ids = []
    1              0.000000     endif
    1              0.000001     return b:syntastic_private_sign_ids

FUNCTION  108()
Called 1 time
Total time:   0.000106
 Self time:   0.000080

count  total (s)   self (s)
    1              0.000005     let l:prependWorkingDir = 0
                            
    1   0.000051   0.000025     if nerdtree#runningWindows()
                                    let l:prependWorkingDir = a:pathStr !~# '^.:\(\\\|\/\)' && a:pathStr !~# '^\(\\\\\|\/\/\)'
                                else
    1              0.000014         let l:prependWorkingDir = a:pathStr !~# '^/'
    1              0.000002     endif
                            
    1              0.000005     let l:result = a:pathStr
                            
    1              0.000004     if l:prependWorkingDir
                                    let l:result = getcwd() . s:Path.Slash() . a:pathStr
                                endif
                            
    1              0.000003     return l:result

FUNCTION  gitgutter#utility#shellescape()
Called 4 times
Total time:   0.000072
 Self time:   0.000054

count  total (s)   self (s)
    4              0.000033   if a:arg =~ '^[A-Za-z0-9_/.-]\+$'
    3              0.000003     return a:arg
                              elseif &shell =~# 'cmd' || gitgutter#utility#using_xolox_shell()
                                return '"' . substitute(substitute(a:arg, '"', '""', 'g'), '%', '"%"', 'g') . '"'
                              else
    1              0.000002     return shellescape(a:arg)
                              endif

FUNCTION  313()
Called 1 time
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
    1              0.000011     let newObj = copy(self)
    1              0.000006     let newObj._flags = {}
    1              0.000003     return newObj

FUNCTION  319()
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000002     if g:NERDTreeQuitOnOpen && s:NERDTree.IsOpen()
                                    call s:NERDTree.Close()
                                endif

FUNCTION  airline#extensions#po#apply()
Called 6 times
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
    6              0.000020   if &ft ==# 'po'
                                call airline#extensions#prepend_to_section('z', '%{airline#extensions#po#stats()}')
                                autocmd airline BufWritePost * unlet! b:airline_po_stats
                              endif

FUNCTION  <SNR>52_activateFileNode()
Called 1 time
Total time:   2.200367
 Self time:   0.000024

count  total (s)   self (s)
    1   2.200367   0.000024     call a:node.activate({'reuse': 'all', 'where': 'p'})

FUNCTION  20()
Called 1 time
Total time:   0.000029
 Self time:   0.000013

count  total (s)   self (s)
    1              0.000000     if a:0
                                    let self._exec = a:1
                                else
    1              0.000001         let suffix = self._name . '_exec'
    1   0.000025   0.000009         let self._exec = expand( syntastic#util#var(self._filetype . '_' . suffix, syntastic#util#var(suffix, self._exec_default)), 1 )
    1              0.000000     endif

FUNCTION  21()
Called 2 times
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    2              0.000002     return self._exec

FUNCTION  23()
Called 1 time
Total time:   2.125688
 Self time:   0.000082

count  total (s)   self (s)
    1              0.000002     let checker_start = reltime()
    1   0.000004   0.000002     let name = self.getCName()
                            
    1              0.000002     if has_key(self, '_enable')
                                    let status = syntastic#util#var(self._enable, -1)
                                    if type(status) != type(0)
                                        call syntastic#log#error('checker ' . name . ': invalid value ' . strtrans(string(status)) . ' for g:syntastic_' . self._enable . '; try 0 or 1 instead')
                                        return []
                                    endif
                                    if status < 0
                                        call syntastic#log#error('checker ' . name . ': checks disabled for security reasons; ' . 'set g:syntastic_' . self._enable . ' to 1 to override')
                                    endif
                                    if status <= 0
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getLocList: checker ' . name . ' enabled but not forced')
                                        return []
                                    else
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getLocList: checker ' . name . ' forced')
                                    endif
                                endif
                            
    1              0.000001     try
    1   2.125541   0.000009         let list = self._locListFunc()
    1              0.000002         if self._exec !=# ''
    1   0.000011   0.000006             call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getLocList: checker ' . name . ' returned ' . v:shell_error)
    1              0.000001         endif
    1              0.000001     catch /\m\C^Syntastic: checker error$/
                                    let list = []
                                    if self._exec !=# ''
                                        call syntastic#log#error('checker ' . name . ' returned abnormal status ' . v:shell_error)
                                    else
                                        call syntastic#log#error('checker ' . name . ' aborted')
                                    endif
                                endtry
    1   0.000014   0.000006     call self._populateHighlightRegexes(list)
    1   0.000009   0.000005     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, name . ' raw:', list)
    1   0.000055   0.000004     call self._quietMessages(list)
    1   0.000018   0.000014     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getLocList: checker ' . name . ' run in ' . split(reltimestr(reltime(checker_start)))[0] . 's')
    1              0.000001     return list

FUNCTION  24()
Called 1 time
Total time:   2.125737
 Self time:   0.000015

count  total (s)   self (s)
    1   2.125736   0.000014     return g:SyntasticLoclist.New(self.getLocListRaw())

FUNCTION  27()
Called 1 time
Total time:   0.000022
 Self time:   0.000011

count  total (s)   self (s)
    1   0.000004   0.000002     let leader = self.getCName() . ': '
    1              0.000001     if a:0
    1   0.000014   0.000005         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, leader . a:msg, a:1)
    1              0.000000     else
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, leader . a:msg)
                                endif

FUNCTION  29()
Called 1 time
Total time:   0.000103
 Self time:   0.000020

count  total (s)   self (s)
    1   0.000033   0.000004     call self.syncExec()
                            
    1              0.000002     if !has_key(self, '_available')
    1              0.000001         let self._available = {}
    1              0.000000     endif
    1              0.000001     if !has_key(self._available, self._exec)
    1   0.000063   0.000009         let self._available[self._exec] = self._isAvailableFunc()
    1              0.000000     endif
                            
    1              0.000001     return self._available[self._exec]

FUNCTION  syntastic#util#findFileInParent()
Called 1 time
Total time:   0.000060
 Self time:   0.000060

count  total (s)   self (s)
    1              0.000003     let old_suffixesadd = &suffixesadd
    1              0.000005     let &suffixesadd = ''
    1              0.000046     let file = findfile(a:what, escape(a:where, ' ,') . ';')
    1              0.000003     let &suffixesadd = old_suffixesadd
    1              0.000001     return file

FUNCTION  322()
Called 1 time
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    1              0.000014     return exists("b:NERDTree")

FUNCTION  33()
Called 1 time
Total time:   0.000051
 Self time:   0.000029

count  total (s)   self (s)
                                " wildcard quiet_messages
    1   0.000013   0.000003     let quiet_filters = copy(syntastic#util#var('quiet_messages', {}))
    1              0.000002     if type(quiet_filters) != type({})
                                    call syntastic#log#warn('ignoring invalid syntastic_quiet_messages')
                                    unlet quiet_filters
                                    let quiet_filters = {}
                                endif
                            
                                " per checker quiet_messages
    1              0.000003     let name = self._filetype . '_' . self._name
    1              0.000000     try
    1   0.000012   0.000005         call extend( quiet_filters, copy(syntastic#util#var(name . '_quiet_messages', {})), 'force' )
    1              0.000001     catch /\m^Vim\%((\a\+)\)\=:E712/
                                    call syntastic#log#warn('ignoring invalid syntastic_' . name . '_quiet_messages')
                                endtry
                            
    1   0.000007   0.000002     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'quiet_messages filter:', quiet_filters)
                            
    1              0.000002     if !empty(quiet_filters)
                                    call syntastic#util#dictFilter(a:errors, quiet_filters)
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'filtered by quiet_messages:', a:errors)
                                endif

FUNCTION  34()
Called 1 time
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    1              0.000001     if has_key(self, '_highlightRegexFunc')
                                    for e in a:errors
                                        if e['valid']
                                            let term = self._highlightRegexFunc(e)
                                            if term !=# ''
                                                let e['hl'] = term
                                            endif
                                        endif
                                    endfor
                                endif

FUNCTION  37()
Called 2 times
Total time:   0.000017
 Self time:   0.000005

count  total (s)   self (s)
    2   0.000017   0.000005     return syntastic#util#var('echo_current_error')

FUNCTION  38()
Called 1 time
Total time:   0.000019
 Self time:   0.000010

count  total (s)   self (s)
    1   0.000012   0.000003     if self.enabled() && !a:loclist.isEmpty()
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'cursor: refresh')
                                    let b:syntastic_private_messages = copy(a:loclist.messages(bufnr('')))
                                    let b:syntastic_private_line = -1
                                    let b:syntastic_cursor_columns = a:loclist.getCursorColumns()
                                    autocmd! syntastic CursorMoved
                                    autocmd syntastic CursorMoved * call SyntasticRefreshCursor()
                                endif

FUNCTION  39()
Called 1 time
Total time:   0.000013
 Self time:   0.000008

count  total (s)   self (s)
    1   0.000007   0.000002     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'cursor: reset')
    1              0.000003     autocmd! syntastic CursorMoved
    1              0.000002     unlet! b:syntastic_private_messages
    1              0.000001     let b:syntastic_private_line = -1

FUNCTION  <SNR>123__get_checker_var()
Called 7 times
Total time:   0.000079
 Self time:   0.000079

count  total (s)   self (s)
    7              0.000011     let prefix = a:scope . ':' . 'syntastic_'
    7              0.000025     if exists(prefix . a:filetype . '_' . a:subchecker . '_' . a:name)
                                    return {a:scope}:syntastic_{a:filetype}_{a:subchecker}_{a:name}
                                elseif exists(prefix . a:filetype . '_' . a:name)
    1              0.000004         return {a:scope}:syntastic_{a:filetype}_{a:name}
                                else
    6              0.000006         return a:default
                                endif

FUNCTION  <SNR>81_exec_separator()
Called 110 times
Total time:   0.031107
 Self time:   0.002601

count  total (s)   self (s)
  110              0.000139   if pumvisible()
                                return
                              endif
  110   0.008211   0.000365   let l:from = airline#themes#get_highlight(a:from.a:suffix)
  110   0.007706   0.000333   let l:to = airline#themes#get_highlight(a:to.a:suffix)
  110              0.000225   let group = a:from.'_to_'.a:to.a:suffix
  110              0.000086   if a:inverse
   46              0.000164     let colors = [ l:from[1], l:to[1], l:from[3], l:to[3] ]
   46              0.000022   else
   64              0.000219     let colors = [ l:to[1], l:from[1], l:to[3], l:from[3] ]
   64              0.000027   endif
  110              0.000198   let a:dict[group] = colors
  110   0.013681   0.000394   call airline#highlighter#exec(group, colors)

FUNCTION  121()
Called 1 time
Total time:   0.000065
 Self time:   0.000048

count  total (s)   self (s)
    1   0.000027   0.000010     if nerdtree#runningWindows()
                                    if a:fullpath =~ '^\(\\\\\|\/\/\)'
                                        "For network shares, the 'drive' consists of the first two parts of the path, i.e. \\boxname\share
                                        let self.drive = substitute(a:fullpath, '^\(\(\\\\\|\/\/\)[^\\\/]*\(\\\|\/\)[^\\\/]*\).*', '\1', '')
                                        let self.drive = substitute(self.drive, '/', '\', "g")
                                    else
                                        let self.drive = substitute(a:fullpath, '\(^[a-zA-Z]:\).*', '\1', '')
                                    endif
                                else
    1              0.000007         let self.drive = ''
    1              0.000002     endif
                            

FUNCTION  126()
Called 1 time
Total time:   0.000045
 Self time:   0.000045

count  total (s)   self (s)
    1              0.000008     if empty(self.pathSegments)
                                    return ''
                                endif
    1              0.000010     let toReturn = self.pathSegments[-1]
    1              0.000007     if a:dirSlash && self.isDirectory
                                    let toReturn = toReturn . '/'
                                endif
    1              0.000005     return toReturn

FUNCTION  330()
Called 1 time
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    1              0.000010     return self._type == "window"

FUNCTION  41()
Called 2 times
Total time:   0.000020
 Self time:   0.000006

count  total (s)   self (s)
    2   0.000020   0.000006     return s:has_highlighting && syntastic#util#var('enable_highlighting')

FUNCTION  42()
Called 1 time
Total time:   0.000059
 Self time:   0.000030

count  total (s)   self (s)
    1   0.000010   0.000001     if self.enabled()
    1   0.000010   0.000004         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'highlighting: refresh')
    1   0.000014   0.000002         call self._reset()
    1              0.000001         let buf = bufnr('')
    1   0.000006   0.000004         let issues = filter(a:loclist.copyRaw(), 'v:val["bufnr"] == buf')
    1              0.000001         for item in issues
                                        let group = 'Syntastic' . get(item, 'subtype', '') . ( item['type'] ==? 'E' ? 'Error' : 'Warning' )
                            
                                        " The function `Syntastic_{filetype}_{checker}_GetHighlightRegex` is
                                        " used to override default highlighting.
                                        if has_key(item, 'hl')
                                            call matchadd(group, '\%' . item['lnum'] . 'l' . item['hl'])
                                        elseif get(item, 'col', 0)
                                            if get(item, 'vcol', 0)
                                                let lastcol = virtcol([item['lnum'], '$'])
                                                let coltype = 'v'
                                            else
                                                let lastcol = col([item['lnum'], '$'])
                                                let coltype = 'c'
                                            endif
                                            let lcol = min([lastcol, item['col']])
                            
                                            call matchadd(group, '\%' . item['lnum'] . 'l\%' . lcol . coltype)
                                        endif
                                    endfor
    1              0.000000     endif

FUNCTION  43()
Called 1 time
Total time:   0.000026
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000001     if s:has_highlighting
    1   0.000008   0.000003         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'highlighting: reset')
    1   0.000017   0.000003         call self._reset()
    1              0.000000     endif

FUNCTION  45()
Called 2 times
Total time:   0.000026
 Self time:   0.000026

count  total (s)   self (s)
    4              0.000010     for match in getmatches()
    2              0.000006         if stridx(match['group'], 'Syntastic') == 0
                                        call matchdelete(match['id'])
                                    endif
    2              0.000001     endfor

FUNCTION  46()
Called 3 times
Total time:   0.000085
 Self time:   0.000085

count  total (s)   self (s)
    3              0.000034     let newObj = copy(self)
                            
    3              0.000012     let llist = filter(copy(a:rawLoclist), 'v:val["valid"]')
                            
    3              0.000004     for e in llist
                                    if get(e, 'type', '') ==# ''
                                        let e['type'] = 'E'
                                    endif
                                endfor
                            
    3              0.000006     let newObj._rawLoclist = llist
    3              0.000003     let newObj._name = ''
    3              0.000004     let newObj._owner = bufnr('')
    3              0.000002     let newObj._sorted = 0
    3              0.000005     let newObj._columns = g:syntastic_cursor_columns
                            
    3              0.000003     return newObj

FUNCTION  47()
Called 6 times
Total time:   0.000141
 Self time:   0.000086

count  total (s)   self (s)
    6              0.000013     let buf = a:0 ? a:1 : bufnr('')
    6   0.000052   0.000026     let loclist = syntastic#util#getbufvar(buf, 'syntastic_loclist', {})
    6              0.000017     if type(loclist) != type({}) || empty(loclist)
    1              0.000001         unlet! loclist
    1   0.000035   0.000006         let loclist = g:SyntasticLoclist.New([])
    1              0.000001     endif
    6              0.000001     return loclist

FUNCTION  <SNR>123__init()
Called 1 time
Total time:   0.000144
 Self time:   0.000047

count  total (s)   self (s)
    1              0.000001     let s:handlers = []
    1              0.000002     let s:cflags = {}
                            
    1   0.000018   0.000008     call s:_registerHandler('\m\<cairo',       's:_checkPackage', ['cairo', 'cairo'])
    1   0.000011   0.000003     call s:_registerHandler('\m\<freetype',    's:_checkPackage', ['freetype', 'freetype2', 'freetype'])
    1   0.000011   0.000004     call s:_registerHandler('\m\<glade',       's:_checkPackage', ['glade', 'libglade-2.0', 'libglade'])
    1   0.000009   0.000002     call s:_registerHandler('\m\<glib',        's:_checkPackage', ['glib', 'glib-2.0', 'glib'])
    1   0.000010   0.000003     call s:_registerHandler('\m\<gtk',         's:_checkPackage', ['gtk', 'gtk+-2.0', 'gtk+', 'glib-2.0', 'glib'])
    1   0.000009   0.000002     call s:_registerHandler('\m\<libsoup',     's:_checkPackage', ['libsoup', 'libsoup-2.4', 'libsoup-2.2'])
    1   0.000009   0.000003     call s:_registerHandler('\m\<libxml',      's:_checkPackage', ['libxml', 'libxml-2.0', 'libxml'])
    1   0.000009   0.000003     call s:_registerHandler('\m\<pango',       's:_checkPackage', ['pango', 'pango'])
    1   0.000008   0.000002     call s:_registerHandler('\m\<SDL',         's:_checkPackage', ['sdl', 'sdl'])
    1   0.000009   0.000003     call s:_registerHandler('\m\<opengl',      's:_checkPackage', ['opengl', 'gl'])
    1   0.000009   0.000002     call s:_registerHandler('\m\<webkit',      's:_checkPackage', ['webkit', 'webkit-1.0'])
                            
    1   0.000008   0.000002     call s:_registerHandler('\m\<php\.h\>',    's:_checkPhp',    [])
    1   0.000010   0.000003     call s:_registerHandler('\m\<Python\.h\>', 's:_checkPython', [])
    1   0.000009   0.000002     call s:_registerHandler('\m\<ruby',        's:_checkRuby',   [])

FUNCTION  138()
Called 3 times
Total time:   0.001302
 Self time:   0.000044

count  total (s)   self (s)
    3   0.001301   0.000043     return self.str() ==# a:path.str()

FUNCTION  139()
Called 1 time
Total time:   0.001027
 Self time:   0.000121

count  total (s)   self (s)
    1              0.000061     let l:newPath = copy(self)
                            
    1   0.000911   0.000027     call l:newPath.readInfoFromDisk(s:Path.AbsolutePathFor(a:pathStr))
                            
    1              0.000006     let l:newPath.cachedDisplayString = ''
    1   0.000043   0.000021     let l:newPath.flagSet = g:NERDTreeFlagSet.New()
                            
    1              0.000003     return l:newPath

FUNCTION  340()
Called 1 time
Total time:   0.002186
 Self time:   0.000324

count  total (s)   self (s)
    1              0.000011     let line = getline(a:ln)
                            
    1   0.000120   0.000015     let rootLine = self.getRootLineNum()
                            
    1              0.000004     if a:ln == rootLine
                                    return self.nerdtree.root.path
                                endif
                            
    1   0.000017   0.000013     if line ==# s:UI.UpDirLine()
                                    return self.nerdtree.root.path.getParent()
                                endif
                            
    1              0.000003     if a:ln < rootLine
                                    return {}
                                endif
                            
    1   0.000099   0.000013     let indent = self._indentLevelFor(line)
                            
                                " remove the tree parts and the leading space
    1   0.000168   0.000017     let curFile = self._stripMarkup(line)
                            
    1              0.000003     let dir = ""
    1              0.000004     let lnum = a:ln
    2              0.000008     while lnum > 0
    2              0.000010         let lnum = lnum - 1
    2              0.000013         let curLine = getline(lnum)
    2   0.000224   0.000022         let curLineStripped = self._stripMarkup(curLine)
                            
                                    " have we reached the top of the tree?
    2              0.000007         if lnum == rootLine
    1   0.000241   0.000023             let dir = self.nerdtree.root.path.str({'format': 'UI'}) . dir
    1              0.000002             break
                                    endif
    1              0.000013         if curLineStripped =~# '/$'
    1   0.000079   0.000010             let lpindent = self._indentLevelFor(curLine)
    1              0.000004             if lpindent < indent
                                            let indent = indent - 1
                            
                                            let dir = substitute (curLineStripped,'^\\', "", "") . dir
                                            continue
                                        endif
    1              0.000002         endif
    1              0.000003     endwhile
    1              0.000009     let curFile = self.nerdtree.root.path.drive . dir . curFile
    1   0.001044   0.000017     let toReturn = g:NERDTreePath.New(curFile)
    1              0.000003     return toReturn

FUNCTION  342()
Called 1 time
Total time:   0.000105
 Self time:   0.000105

count  total (s)   self (s)
    1              0.000005     let rootLine = 1
    4              0.000059     while getline(rootLine) !~# '^\(/\|<\)'
    3              0.000019         let rootLine = rootLine + 1
    3              0.000007     endwhile
    1              0.000004     return rootLine

FUNCTION  347()
Called 2 times
Total time:   0.000155
 Self time:   0.000149

count  total (s)   self (s)
                                " have to do this work around because match() returns bytes, not chars
    2              0.000055     let numLeadBytes = match(a:line, '\M\[^ '.g:NERDTreeDirArrowExpandable.g:NERDTreeDirArrowCollapsible.']')
                                " The next line is a backward-compatible workaround for strchars(a:line(0:numLeadBytes-1]). strchars() is in 7.3+
    2              0.000057     let leadChars = len(split(a:line[0:numLeadBytes-1], '\zs'))
                            
    2   0.000034   0.000028     return leadChars / s:UI.IndentWid()

FUNCTION  348()
Called 2 times
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    2              0.000005     return 2

FUNCTION  gitgutter#diff#parse_diff()
Called 1 time
Total time:   0.000038
 Self time:   0.000022

count  total (s)   self (s)
    1              0.000001   let hunks = []
    2              0.000005   for line in split(a:diff, '\n')
    1   0.000023   0.000007     let hunk_info = gitgutter#diff#parse_hunk(line)
    1              0.000001     if len(hunk_info) == 4
                                  call add(hunks, hunk_info)
                                endif
    1              0.000001   endfor
    1              0.000001   return hunks

FUNCTION  50()
Called 5 times
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    5              0.000007     return empty(self._rawLoclist)

FUNCTION  51()
Called 1 time
Total time:   0.000023
 Self time:   0.000010

count  total (s)   self (s)
    1              0.000002     if !exists('self._stamp')
                                    let self._stamp = []
                                    return 0
                                endif
    1   0.000019   0.000006     return syntastic#util#compareLexi(self._stamp, a:stamp) > 0

FUNCTION  52()
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    1              0.000001     return copy(self._rawLoclist)

FUNCTION  53()
Called 1 time
Total time:   0.000001
 Self time:   0.000001

count  total (s)   self (s)
    1              0.000001     return self._rawLoclist

FUNCTION  56()
Called 4 times
Total time:   0.000162
 Self time:   0.000162

count  total (s)   self (s)
    4              0.000008     if !exists('self._stl_format')
    1              0.000002         let self._stl_format = ''
    1              0.000000     endif
    4              0.000005     if !exists('self._stl_flag')
    1              0.000001         let self._stl_flag = ''
    1              0.000001     endif
                            
    4              0.000006     if g:syntastic_stl_format !=# self._stl_format
    4              0.000004         let self._stl_format = g:syntastic_stl_format
                            
    4              0.000006         if !empty(self._rawLoclist)
                                        let errors = self.errors()
                                        let warnings = self.warnings()
                            
                                        let num_errors = len(errors)
                                        let num_warnings = len(warnings)
                                        let num_issues = len(self._rawLoclist)
                            
                                        let output = self._stl_format
                            
                                        "hide stuff wrapped in %E(...) unless there are errors
                                        let output = substitute(output, '\m\C%E{\([^}]*\)}', num_errors ? '\1' : '' , 'g')
                            
                                        "hide stuff wrapped in %W(...) unless there are warnings
                                        let output = substitute(output, '\m\C%W{\([^}]*\)}', num_warnings ? '\1' : '' , 'g')
                            
                                        "hide stuff wrapped in %B(...) unless there are both errors and warnings
                                        let output = substitute(output, '\m\C%B{\([^}]*\)}', (num_warnings && num_errors) ? '\1' : '' , 'g')
                            
                                        let flags = { '%':  '%', 't':  num_issues, 'e':  num_errors, 'w':  num_warnings, 'N':  (num_issues ? fnamemodify( bufname(self._rawLoclist[0]['bufnr']), ':t') : ''), 'P':  (num_issues ? fnamemodify( bufname(self._rawLoclist[0]['bufnr']), ':p:~:.') : ''), 'F':  (num_issues ? self._rawLoclist[0]['lnum'] : ''), 'ne': (num_errors ? fnamemodify( bufname(errors[0]['bufnr']), ':t') : ''), 'pe': (num_errors ? fnamemodify( bufname(errors[0]['bufnr']), ':p:~:.') : ''), 'fe': (num_errors ? errors[0]['lnum'] : ''), 'nw': (num_warnings ? fnamemodify( bufname(warnings[0]['bufnr']), ':t') : ''), 'pw': (num_warnings ? fnamemodify( bufname(warnings[0]['bufnr']), ':p:~:.') : ''), 'fw': (num_warnings ? warnings[0]['lnum'] : '') }
                                        let output = substitute(output, '\v\C\%(-?\d*%(\.\d+)?)([npf][ew]|[NPFtew%])', '\=syntastic#util#wformat(submatch(1), flags[submatch(2)])', 'g')
                            
                                        let self._stl_flag = output
                                    else
    4              0.000002             let self._stl_flag = ''
    4              0.000002         endif
    4              0.000000     endif
                            
    4              0.000002     return self._stl_flag

FUNCTION  syntastic#util#rawVar()
Called 16 times
Total time:   0.000056
 Self time:   0.000056

count  total (s)   self (s)
   16              0.000052     return get(b:, a:name, get(g:, a:name, a:0 ? a:1 : ''))

FUNCTION  140()
Called 13 times
Total time:   0.000550
 Self time:   0.000291

count  total (s)   self (s)
                            
   13   0.000346   0.000087     if nerdtree#runningWindows()
                                    if exists('+shellslash') && &shellslash
                                        return '/'
                                    endif
                            
                                    return '\'
                                endif
                            
   13              0.000024     return '/'

FUNCTION  141()
Called 2 times
Total time:   0.000224
 Self time:   0.000224

count  total (s)   self (s)
    2              0.000089     let tmp = resolve(a:path)
    2              0.000129     return tmp =~# '.\+/$' ? substitute(tmp, '/$', '', '') : tmp

FUNCTION  142()
Called 1 time
Total time:   0.000778
 Self time:   0.000388

count  total (s)   self (s)
    1   0.000077   0.000012     call self.extractDriveLetter(a:fullpath)
                            
    1   0.000041   0.000014     let fullpath = s:Path.WinToUnixPath(a:fullpath)
                            
    1              0.000028     if getftype(fullpath) ==# "fifo"
                                    throw "NERDTree.InvalidFiletypeError: Cant handle FIFO files: " . a:fullpath
                                endif
                            
    1              0.000064     let self.pathSegments = filter(split(fullpath, '/'), '!empty(v:val)')
                            
    1              0.000011     let self.isReadOnly = 0
    1              0.000018     if isdirectory(a:fullpath)
                                    let self.isDirectory = 1
                                elseif filereadable(a:fullpath)
    1              0.000007         let self.isDirectory = 0
    1              0.000022         let self.isReadOnly = filewritable(a:fullpath) ==# 0
    1              0.000002     else
                                    throw "NERDTree.InvalidArgumentsError: Invalid path = " . a:fullpath
                                endif
                            
    1              0.000004     let self.isExecutable = 0
    1              0.000003     if !self.isDirectory
    1              0.000017         let self.isExecutable = getfperm(a:fullpath) =~# 'x'
    1              0.000002     endif
                            
                                "grab the last part of the path (minus the trailing slash)
    1   0.000067   0.000022     let lastPathComponent = self.getLastPathComponent(0)
                            
                                "get the path to the new node with the parent dir fully resolved
    1   0.000185   0.000042     let hardPath = s:Path.Resolve(self.strTrunk()) . '/' . lastPathComponent
                            
                                "if  the last part of the path is a symlink then flag it as such
    1   0.000134   0.000024     let self.isSymLink = (s:Path.Resolve(hardPath) != hardPath)
    1              0.000004     if self.isSymLink
                                    let self.symLinkDest = s:Path.Resolve(fullpath)
                            
                                    "if the link is a dir then slap a / on the end of its dest
                                    if isdirectory(self.symLinkDest)
                            
                                        "we always wanna treat MS windows shortcuts as files for
                                        "simplicity
                                        if hardPath !~# '\.lnk$'
                            
                                            let self.symLinkDest = self.symLinkDest . '/'
                                        endif
                                    endif
                                endif

FUNCTION  146()
Called 15 times
Total time:   0.002917
 Self time:   0.001446

count  total (s)   self (s)
   15              0.000074     let options = a:0 ? a:1 : {}
   15              0.000041     let toReturn = ""
                            
   15              0.000066     if has_key(options, 'format')
    2              0.000007         let format = options['format']
    2              0.000008         if has_key(self, '_strFor' . format)
    2   0.000092   0.000060             exec 'let toReturn = self._strFor' . format . '()'
    2              0.000003         else
                                        throw 'NERDTree.UnknownFormatError: unknown format "'. format .'"'
                                    endif
    2              0.000002     else
   13   0.001312   0.000101         let toReturn = self._str()
   13              0.000020     endif
                            
   15   0.000241   0.000129     if nerdtree#has_opt(options, 'escape')
                                    let toReturn = shellescape(toReturn)
                                endif
                            
   15              0.000064     if has_key(options, 'truncateTo')
                                    let limit = options['truncateTo']
                                    if len(toReturn) > limit-1
                                        let toReturn = toReturn[(len(toReturn)-limit+1):]
                                        if len(split(toReturn, '/')) > 1
                                            let toReturn = '</' . join(split(toReturn, '/')[1:], '/') . '/'
                                        else
                                            let toReturn = '<' . toReturn
                                        endif
                                    endif
                                endif
                            
   15              0.000042     return toReturn

FUNCTION  147()
Called 1 time
Total time:   0.000032
 Self time:   0.000032

count  total (s)   self (s)
    1              0.000013     let toReturn = '/' . join(self.pathSegments, '/')
    1              0.000006     if self.isDirectory && toReturn != '/'
    1              0.000005         let toReturn  = toReturn . '/'
    1              0.000002     endif
    1              0.000003     return toReturn

FUNCTION  149()
Called 1 time
Total time:   0.000085
 Self time:   0.000020

count  total (s)   self (s)
                            
                                " Make the path relative to the current working directory, if possible.
    1   0.000067   0.000006     let l:result = fnamemodify(self.str(), ':.')
                            
                                " On Windows, the drive letter may be removed by "fnamemodify()".  Add it
                                " back, if necessary.
    1   0.000007   0.000003     if nerdtree#runningWindows() && l:result[0] == s:Path.Slash()
                                    let l:result = self.drive . l:result
                                endif
                            
    1              0.000005     let l:result = fnameescape(l:result)
                            
    1              0.000001     if empty(l:result)
                                    let l:result = '.'
                                endif
                            
    1              0.000001     return l:result

FUNCTION  gitgutter#diff#process_hunks()
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000001   let modified_lines = []
    1              0.000002   for hunk in a:hunks
                                call extend(modified_lines, gitgutter#diff#process_hunk(hunk))
                              endfor
    1              0.000001   return modified_lines

FUNCTION  18()
Called 24 times
Total time:   0.000026
 Self time:   0.000026

count  total (s)   self (s)
   24              0.000018     return self._name

FUNCTION  351()
Called 3 times
Total time:   0.000040
 Self time:   0.000040

count  total (s)   self (s)
    3              0.000037     return '^\(['.g:NERDTreeDirArrowExpandable.g:NERDTreeDirArrowCollapsible.'] \| \+['.g:NERDTreeDirArrowExpandable.g:NERDTreeDirArrowCollapsible.'] \| \+\)'

FUNCTION  356()
Called 3 times
Total time:   0.000353
 Self time:   0.000313

count  total (s)   self (s)
    3              0.000013     let line = a:line
                                " remove the tree parts and the leading space
    3   0.000150   0.000110     let line = substitute (line, g:NERDTreeUI.MarkupReg(),"","")
                            
                                " strip off any read only flag
    3              0.000043     let line = substitute (line, ' \['.g:NERDTreeGlyphReadOnly.'\]', "","")
                            
                                " strip off any bookmark flags
    3              0.000029     let line = substitute (line, ' {[^}]*}', "","")
                            
                                " strip off any executable flags
    3              0.000030     let line = substitute (line, '*\ze\($\| \)', "","")
                            
                                " strip off any generic flags
    3              0.000025     let line = substitute (line, '\[[^]]*\]', "","")
                            
    3              0.000028     let line = substitute (line,' -> .*',"","") " remove link to
                            
    3              0.000010     return line

FUNCTION  gitgutter#utility#filename()
Called 2 times
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    2              0.000005   return fnamemodify(s:file, ':t')

FUNCTION  <SNR>98_buffer_exec()
Called 1 time
Total time:   0.000774
 Self time:   0.000023

count  total (s)   self (s)
    1   0.000006   0.000003   let current_buffer = gitgutter#utility#bufnr()
    1   0.000015   0.000003   call gitgutter#utility#set_buffer(a:buffer)
                            
    1   0.000054   0.000003   if gitgutter#utility#is_active()
    1   0.000689   0.000009     call a:fn()
    1              0.000000   endif
                            
    1   0.000009   0.000004   call gitgutter#utility#set_buffer(current_buffer)

FUNCTION  61()
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000004     let self._owner = type(a:buffer) == type(0) ? a:buffer : str2nr(a:buffer)

FUNCTION  62()
Called 1 time
Total time:   0.000057
 Self time:   0.000018

count  total (s)   self (s)
    1   0.000018   0.000007     let self._stamp = syntastic#util#stamp()
    2   0.000032   0.000004     for buf in self.getBuffers()
    1              0.000005         call setbufvar(buf, 'syntastic_loclist', self)
    1              0.000000     endfor

FUNCTION  63()
Called 1 time
Total time:   0.000040
 Self time:   0.000010

count  total (s)   self (s)
    2   0.000035   0.000005     for buf in self.getBuffers()
    1              0.000003         call setbufvar(buf, 'syntastic_loclist', {})
    1              0.000000     endfor

FUNCTION  airline#section#create()
Called 4 times
Total time:   0.000456
 Self time:   0.000016

count  total (s)   self (s)
    4   0.000456   0.000016   return s:create(a:parts, 0)

FUNCTION  151()
Called 13 times
Total time:   0.001211
 Self time:   0.000473

count  total (s)   self (s)
   13   0.000649   0.000099     let l:separator = s:Path.Slash()
   13              0.000055     let l:leader = l:separator
                            
   13   0.000264   0.000076     if nerdtree#runningWindows()
                                    let l:leader = self.drive . l:separator
                                endif
                            
   13              0.000142     return l:leader . join(self.pathSegments, l:separator)

FUNCTION  152()
Called 1 time
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
    1              0.000028     return self.drive . '/' . join(self.pathSegments[0:-2], '/')

FUNCTION  153()
Called 1 time
Total time:   0.000494
 Self time:   0.000212

count  total (s)   self (s)
    1   0.000298   0.000016     let str = self.str()
    2              0.000019     for t in range(tabpagenr('$'))
    3              0.000027         for b in tabpagebuflist(t+1)
    2              0.000081             if str == expand('#' . b . ':p')
                                            return t+1
                                        endif
    2              0.000007         endfor
    1              0.000002     endfor
    1              0.000004     return 0

FUNCTION  154()
Called 1 time
Total time:   0.000027
 Self time:   0.000012

count  total (s)   self (s)
    1   0.000022   0.000007     if !nerdtree#runningWindows()
    1              0.000004         return a:pathstr
                                endif
                            
                                let toReturn = a:pathstr
                            
                                "remove the x:\ of the front
                                let toReturn = substitute(toReturn, '^.*:\(\\\|/\)\?', '/', "")
                            
                                "remove the \\ network share from the front
                                let toReturn = substitute(toReturn, '^\(\\\\\|\/\/\)[^\\\/]*\(\\\|\/\)[^\\\/]*\(\\\|\/\)\?', '/', "")
                            
                                "convert all \ chars to /
                                let toReturn = substitute(toReturn, '\', '/', "g")
                            
                                return toReturn

FUNCTION  365()
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000003     return '.. (up a dir)'

FUNCTION  <SNR>75_check_mixed_indent()
Called 1 time
Total time:   0.000237
 Self time:   0.000237

count  total (s)   self (s)
    1              0.000002   let indent_algo = get(g:, 'airline#extensions#whitespace#mixed_indent_algo', 0)
    1              0.000001   if indent_algo == 1
                                " [<tab>]<space><tab>
                                " spaces before or between tabs are not allowed
                                let t_s_t = '(^\t* +\t\s*\S)'
                                " <tab>(<space> x count)
                                " count of spaces at the end of tabs should be less than tabstop value
                                let t_l_s = '(^\t+ {' . &ts . ',}' . '\S)'
                                return search('\v' . t_s_t . '|' . t_l_s, 'nw')
                              elseif indent_algo == 2
                                return search('\v(^\t* +\t\s*\S)', 'nw')
                              else
    1              0.000228     return search('\v(^\t+ +)|(^ +\t+)', 'nw')
                              endif

FUNCTION  71()
Called 1 time
Total time:   0.000042
 Self time:   0.000032

count  total (s)   self (s)
    1              0.000002     if !exists('w:syntastic_loclist_set')
    1              0.000002         let w:syntastic_loclist_set = []
    1              0.000000     endif
    1              0.000003     if a:new || empty(w:syntastic_loclist_set) || w:syntastic_loclist_set != [self._owner, getbufvar(self._owner, 'changedtick')]
    1              0.000002         let replace = !a:new && g:syntastic_reuse_loc_lists && !empty(w:syntastic_loclist_set)
    1   0.000010   0.000004         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'loclist: setloclist ' . (replace ? '(replace)' : '(new)'))
    1   0.000006   0.000005         call setloclist(0, self.getRaw(), replace ? 'r' : ' ')
    1              0.000000         try
                                        " Vim 7.4.2200 or later
    1              0.000003             call setloclist(0, [], 'r', { 'title': ':SyntasticCheck ' . self._name })
    1              0.000000         catch /\m^Vim\%((\a\+)\)\=:E\%(118\|731\)/
                                        " do nothing
                                    endtry
    1   0.000006   0.000003         call syntastic#util#setLastTick(self._owner)
    1              0.000003         let w:syntastic_loclist_set = [self._owner, getbufvar(self._owner, 'syntastic_lasttick')]
    1              0.000000     endif

FUNCTION  74()
Called 1 time
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    1              0.000002     if exists('g:syntastic_mode_map')
                                    let self._mode = get(g:syntastic_mode_map, 'mode', 'active')
                                    let self._activeFiletypes = copy(get(g:syntastic_mode_map, 'active_filetypes', []))
                                    let self._passiveFiletypes = copy(get(g:syntastic_mode_map, 'passive_filetypes', []))
                                else
    1              0.000002         let self._mode = 'active'
    1              0.000002         let self._activeFiletypes = []
    1              0.000001         let self._passiveFiletypes = []
    1              0.000000     endif

FUNCTION  75()
Called 1 time
Total time:   0.000064
 Self time:   0.000021

count  total (s)   self (s)
    1   0.000010   0.000004     let registry = g:SyntasticRegistry.Instance()
    1   0.000036   0.000006     let fts = registry.resolveFiletypes(a:filetype)
                            
    1   0.000004   0.000003     if self.isPassive()
                                    return self._isOneFiletypeActive(fts)
                                else
    1   0.000011   0.000005         return self._noFiletypesArePassive(fts)
                                endif

FUNCTION  76()
Called 1 time
Total time:   0.000074
 Self time:   0.000010

count  total (s)   self (s)
    1              0.000002     let local_mode = getbufvar(a:buf, 'syntastic_mode')
    1              0.000002     if local_mode ==# 'active' || local_mode ==# 'passive'
                                    return local_mode ==# 'active'
                                endif
                            
    1   0.000069   0.000005     return self.allowsAutoChecking(getbufvar(a:buf, '&filetype'))

FUNCTION  77()
Called 1 time
Total time:   0.000001
 Self time:   0.000001

count  total (s)   self (s)
    1              0.000001     return self._mode ==# 'passive'

FUNCTION  airline#highlighter#add_separator()
Called 92 times
Total time:   0.026693
 Self time:   0.000715

count  total (s)   self (s)
   92              0.000305   let s:separators[a:from.a:to] = [a:from, a:to, a:inverse]
   92   0.026364   0.000386   call <sid>exec_separator({}, a:from, a:to, a:inverse, '')

FUNCTION  375()
Called 12 times
Total time:   0.000032
 Self time:   0.000032

count  total (s)   self (s)
   12              0.000031   call add(self._sections, ['|', a:0 ? a:1 : '%='])

FUNCTION  377()
Called 58 times
Total time:   0.000146
 Self time:   0.000146

count  total (s)   self (s)
   58              0.000133   call add(self._sections, [a:group, a:contents])

FUNCTION  379()
Called 12 times
Total time:   0.041443
 Self time:   0.004305

count  total (s)   self (s)
   12              0.000010   let side = 1
   12              0.000009   let line = ''
   12              0.000009   let i = 0
   12              0.000022   let length = len(self._sections)
   12              0.000008   let split = 0
   12              0.000011   let is_empty = 0
   12              0.000015   let prev_group = ''
                            
   82              0.000084   while i < length
   70              0.000128     let section = self._sections[i]
   70              0.000096     let group = section[0]
   70              0.000090     let contents = section[1]
   70              0.000071     let pgroup = prev_group
   70   0.000774   0.000235     let prev_group = s:get_prev_group(self._sections, i)
   70              0.000121     if group ==# 'airline_c' && &buftype ==# 'terminal' && self._context.active
                                  let group = 'airline_term'
                                elseif group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
    4              0.000006       let group = 'airline_c'. self._context.bufnr
    4              0.000007     elseif prev_group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
    4              0.000008       let prev_group = 'airline_c'. self._context.bufnr
    4              0.000001     endif
   70              0.000054     if is_empty
                                  let prev_group = pgroup
                                endif
   70   0.000678   0.000219     let is_empty = s:section_is_empty(self, contents)
                            
   70              0.000047     if is_empty
                                  " need to fix highlighting groups, since we
                                  " have skipped a section, we actually need
                                  " the previous previous group and so the
                                  " seperator goes from the previous previous group
                                  " to the current group
                                  let pgroup = group
                                endif
                            
   70              0.000054     if group == ''
                                  let line .= contents
                                elseif group == '|'
   12              0.000010       let side = 0
   12              0.000014       let line .= contents
   12              0.000009       let split = 1
   12              0.000006     else
   58              0.000048       if prev_group == ''
   12              0.000023         let line .= '%#'.group.'#'
   12              0.000005       elseif split
    6              0.000005         if !is_empty
    6   0.003716   0.000026           let line .= s:get_transitioned_seperator(self, prev_group, group, side)
    6              0.000003         endif
    6              0.000006         let split = 0
    6              0.000005       else
   40              0.000025         if !is_empty
   40   0.030500   0.000167           let line .= s:get_seperator(self, prev_group, group, side)
   40              0.000025         endif
   40              0.000016       endif
   58   0.002453   0.000336       let line .= is_empty ? '' : s:get_accented_line(self, group, contents)
   58              0.000030     endif
                            
   70              0.000100     let i = i + 1
   70              0.000058   endwhile
                            
   12              0.000011   if !self._context.active
                                "let line = substitute(line, '%#airline_c#', '%#airline_c'.self._context.bufnr.'#', '')
    6              0.000174     let line = substitute(line, '%#.\{-}\ze#', '\0_inactive', 'g')
    6              0.000004   endif
   12              0.000015   return line

FUNCTION  82()
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000005     return empty(filter(copy(a:filetypes), 'index(self._passiveFiletypes, v:val) != -1'))

FUNCTION  84()
Called 1 time
Total time:   0.000612
 Self time:   0.000189

count  total (s)   self (s)
    1   0.000025   0.000010     if !syntastic#util#bufIsActive(bufnr('')) || (!a:loclist.isEmpty() && !a:loclist.isNewerThan([]))
                                    " loclist not fully constructed yet
                                    return
                                endif
                            
    1   0.000007   0.000002     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'notifiers: refresh')
    6              0.000008     for type in self._enabled_types
    5              0.000030         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
    5   0.000079   0.000031         if !has_key(g:{class}, 'enabled') || self._notifier[type].enabled()
    4              0.000009             if index(s:_PERSISTENT_NOTIFIERS, type) > -1
                                            " refresh only if loclist has changed since last call
    1              0.000003                 if !exists('b:syntastic_private_' . type . '_stamp')
                                                let b:syntastic_private_{type}_stamp = []
                                            endif
    1   0.000029   0.000006                 if a:loclist.isNewerThan(b:syntastic_private_{type}_stamp) || a:loclist.isEmpty()
    1   0.000178   0.000008                     call self._notifier[type].refresh(a:loclist)
    1   0.000017   0.000005                     let b:syntastic_private_{type}_stamp = syntastic#util#stamp()
    1              0.000001                 endif
    1              0.000000             else
    3   0.000165   0.000015                 call self._notifier[type].refresh(a:loclist)
    3              0.000000             endif
    4              0.000004         endif
    5              0.000001     endfor

FUNCTION  85()
Called 1 time
Total time:   0.000167
 Self time:   0.000112

count  total (s)   self (s)
    1   0.000010   0.000004     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'notifiers: reset')
    6              0.000003     for type in self._enabled_types
    5              0.000029         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
                            
                                    " reset notifiers regardless if they are enabled or not, since
                                    " the user might have disabled them since the last refresh();
                                    " notifiers MUST be prepared to deal with reset() when disabled
    5              0.000014         if has_key(g:{class}, 'reset')
    3   0.000066   0.000017             call self._notifier[type].reset(a:loclist)
    3              0.000000         endif
                            
                                    " also reset stamps
    5              0.000010         if index(s:_PERSISTENT_NOTIFIERS, type) > -1
    2              0.000006             let b:syntastic_private_{type}_stamp = []
    2              0.000001         endif
    5              0.000004     endfor

FUNCTION  87()
Called 25 times
Total time:   0.000167
 Self time:   0.000167

count  total (s)   self (s)
   25              0.000058     if !exists('s:SyntasticRegistryInstance')
                                    let s:SyntasticRegistryInstance = copy(self)
                                    let s:SyntasticRegistryInstance._checkerMap = {}
                                endif
                            
   25              0.000029     return s:SyntasticRegistryInstance

FUNCTION  88()
Called 24 times
Total time:   0.009763
 Self time:   0.000596

count  total (s)   self (s)
   24   0.000255   0.000094     let registry = g:SyntasticRegistry.Instance()
                            
   24              0.000038     if has_key(a:args, 'redirect')
    8              0.000042         let [ft, name] = split(a:args['redirect'], '/')
    8   0.004509   0.000249         call registry._loadCheckersFor(ft, 1)
                            
    8              0.000030         let clone = get(registry._checkerMap[ft], name, {})
    8              0.000013         if empty(clone)
                                        throw 'Syntastic: Checker ' . a:args['redirect'] . ' redirects to unregistered checker ' . ft . '/' . name
                                    endif
                            
    8   0.000537   0.000039         let checker = g:SyntasticChecker.New(a:args, clone)
    8              0.000003     else
   16   0.000924   0.000056         let checker = g:SyntasticChecker.New(a:args)
   16              0.000006     endif
   24   0.000463   0.000069     call registry._registerChecker(checker)

FUNCTION  89()
Called 1 time
Total time:   0.009717
 Self time:   0.000073

count  total (s)   self (s)
    1   0.000020   0.000003     let ftlist = self.resolveFiletypes(a:ftalias)
                            
    1              0.000004     let names = !empty(a:hints_list) ? a:hints_list : exists('b:syntastic_checkers') ? b:syntastic_checkers : []
                            
    1              0.000001     let cnames = []
    1              0.000001     if !empty(names)
                                    for name in names
                                        if name !~# '/'
                                            for ft in ftlist
                                                call add(cnames, ft . '/' . name)
                                            endfor
                                        else
                                            call add(cnames, name)
                                        endif
                                    endfor
                                else
    2              0.000002         for ft in ftlist
    1   0.000022   0.000006             call self._sanityCheck(ft)
    1              0.000007             let defs = exists('g:syntastic_' . ft . '_checkers') ? g:syntastic_{ft}_checkers : get(s:_DEFAULT_CHECKERS, ft, [])
    1              0.000007             call extend(cnames, map(copy(defs), 'stridx(v:val, "/") < 0 ? ft . "/" . v:val : v:val' ))
    1              0.000001         endfor
    1              0.000000     endif
    1   0.000021   0.000003     let cnames = syntastic#util#unique(cnames)
                            
    2   0.000024   0.000009     for ft in syntastic#util#unique(map( copy(cnames), 'v:val[: stridx(v:val, "/")-1]' ))
    1   0.009557   0.000004         call self._loadCheckersFor(ft, 0)
    1              0.000001     endfor
                            
    1   0.000029   0.000004     return self._filterCheckersByName(cnames)

FUNCTION  gitgutter#utility#set_buffer()
Called 4 times
Total time:   0.000057
 Self time:   0.000057

count  total (s)   self (s)
    4              0.000011   let s:bufnr = a:bufnr
    4              0.000043   let s:file = resolve(bufname(a:bufnr))

FUNCTION  syntastic#util#system()
Called 1 time
Total time:   2.123720
 Self time:   0.000000

count  total (s)   self (s)
    1              0.000001     let old_shell = &shell
    1              0.000002     let old_lc_messages = $LC_MESSAGES
    1              0.000001     let old_lc_all = $LC_ALL
                            
    1   0.000013   0.000004     let &shell = syntastic#util#var('shell')
    1              0.000003     let $LC_MESSAGES = 'C'
    1              0.000001     let $LC_ALL = ''
                            
    1              0.000001     let crashed = 0
    1              0.000001     let cmd_start = reltime()
    1              0.000000     try
    1   2.123580   0.000000         let out = system(a:command)
    1              0.000004     catch
                                    let crashed = 1
                                    call syntastic#log#error('exception running system(' . string(a:command) . '): ' . v:exception)
                                    if syntastic#util#isRunningWindows()
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$TMP = ' . string($TMP) . ', $TEMP = ' . string($TEMP))
                                    else
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$TERM = ' . string($TERM))
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$TMPDIR = ' . string($TMPDIR))
                                    endif
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, '$PATH = ' . string($PATH))
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getcwd() = ' . string(getcwd()))
                                    call syntastic#log#debugShowOptions(g:_SYNTASTIC_DEBUG_TRACE, g:_SYNTASTIC_SHELL_OPTIONS)
                                    let out = ''
                                endtry
    1              0.000030     let cmd_time = split(reltimestr(reltime(cmd_start)))[0]
                            
    1              0.000005     let $LC_ALL = old_lc_all
    1              0.000002     let $LC_MESSAGES = old_lc_messages
                            
    1              0.000007     let &shell = old_shell
                            
    1              0.000003     if !crashed && exists('g:_SYNTASTIC_DEBUG_TRACE')
    1   0.000024   0.000009         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'system: command run in ' . cmd_time . 's')
    1              0.000001     endif
                            
    1              0.000002     return out

FUNCTION  airline#util#wrap()
Called 24 times
Total time:   0.000148
 Self time:   0.000148

count  total (s)   self (s)
   24              0.000065   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
   24              0.000028   return a:text

FUNCTION  gitgutter#debug#log()
Called 1 time
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
    1              0.000001   if g:gitgutter_log
                                if s:new_log_session && gitgutter#async#available()
                                  if exists('*ch_logfile')
                                    call ch_logfile(s:channel_log, 'w')
                                  endif
                                endif
                            
                                execute 'redir >> '.s:log_file
                                  if s:new_log_session
                                    let s:start = reltime()
                                    silent echo "\n==== start log session ===="
                                  endif
                            
                                  let elapsed = reltimestr(reltime(s:start)).' '
                                  silent echo ''
                                  " callers excluding this function
                                  silent echo elapsed.expand('<sfile>')[:-22].':'
                                  silent echo elapsed.s:format_for_log(a:message)
                                  if a:0 && !empty(a:1)
                                    for msg in a:000
                                      silent echo elapsed.s:format_for_log(msg)
                                    endfor
                                  endif
                                redir END
                            
                                let s:new_log_session = 0
                              endif

FUNCTION  <SNR>13_LoadFTPlugin()
Called 1 time
Total time:   0.001086
 Self time:   0.000514

count  total (s)   self (s)
    1              0.000002     if exists("b:undo_ftplugin")
                                  exe b:undo_ftplugin
                                  unlet! b:undo_ftplugin b:did_ftplugin
                                endif
                            
    1              0.000002     let s = expand("<amatch>")
    1              0.000001     if s != ""
    1              0.000014       if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
                                  endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
    2              0.000005       for name in split(s, '\.')
    1   0.001051   0.000479 	exe 'runtime! ftplugin/' . name . '.vim ftplugin/' . name . '_*.vim ftplugin/' . name . '/*.vim'
    1              0.000001       endfor
    1              0.000001     endif

FUNCTION  176()
Called 1 time
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    1              0.000008     if !exists("s:keyMaps")
                                    let s:keyMaps = []
                                endif
    1              0.000003     return s:keyMaps

FUNCTION  177()
Called 1 time
Total time:   0.000135
 Self time:   0.000119

count  total (s)   self (s)
    8   0.000052   0.000036     for i in s:KeyMap.All()
    8              0.000039          if i.key ==# a:key && i.scope ==# a:scope
    1              0.000002             return i
                                    endif
    7              0.000010     endfor
                                return {}

FUNCTION  <SNR>86_build_sections()
Called 16 times
Total time:   0.002870
 Self time:   0.000521

count  total (s)   self (s)
   76              0.000072   for key in a:keys
   60              0.000111     if (key == 'warning' || key == 'error') && !a:context.active
    4              0.000005       continue
                                endif
   56   0.002521   0.000172     call s:add_section(a:builder, a:context, key)
   56              0.000026   endfor

FUNCTION  94()
Called 2 times
Total time:   0.000047
 Self time:   0.000027

count  total (s)   self (s)
    2   0.000047   0.000027     return map(split( get(g:syntastic_filetype_map, a:ftalias, a:ftalias), '\m\.' ), 's:_normalise_filetype(v:val)')

FUNCTION  96()
Called 24 times
Total time:   0.000394
 Self time:   0.000337

count  total (s)   self (s)
   24   0.000090   0.000059     let ft = a:checker.getFiletype()
   24              0.000042     if !has_key(self._checkerMap, ft)
    2              0.000005         let self._checkerMap[ft] = {}
    2              0.000001     endif
                            
   24   0.000080   0.000054     let name = a:checker.getName()
   24              0.000043     if has_key(self._checkerMap[ft], name)
                                    throw 'Syntastic: Duplicate syntax checker name: ' . ft . '/' . name
                                endif
                            
   24              0.000051     let self._checkerMap[ft][name] = a:checker

FUNCTION  97()
Called 1 time
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    1              0.000003     let sep_idx = stridx(a:cname, '/')
    1              0.000001     if sep_idx > 0
    1              0.000004         let ft = a:cname[: sep_idx-1]
    1              0.000002         let name = a:cname[sep_idx+1 :]
    1              0.000000     else
                                    let ft = &filetype
                                    let name = a:cname
                                endif
    1              0.000003     return get(self._checkerMap[ft], name, {})

FUNCTION  98()
Called 1 time
Total time:   0.000025
 Self time:   0.000010

count  total (s)   self (s)
    1   0.000025   0.000010     return filter( map(copy(a:cnames), 'self._findChecker(v:val)'), '!empty(v:val)' )

FUNCTION  99()
Called 9 times
Total time:   0.016767
 Self time:   0.012603

count  total (s)   self (s)
    9              0.000018     if !a:force && has_key(self._checkerMap, a:filetype)
                                    return
                                endif
                            
    9   0.007407   0.004193     execute 'runtime! syntax_checkers/' . a:filetype . '/*.vim'
                            
    9              0.000022     if !has_key(self._checkerMap, a:filetype)
                                    let self._checkerMap[a:filetype] = {}
                                endif

FUNCTION  <SNR>15_init()
Called 6 times
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    6              0.000010   if s:airline_initialized
    6              0.000008     return
                              endif
                              let s:airline_initialized = 1
                            
                              call airline#extensions#load()
                              call airline#init#sections()
                            
                              let s:theme_in_vimrc = exists('g:airline_theme')
                              if s:theme_in_vimrc
                                try
                                  let palette = g:airline#themes#{g:airline_theme}#palette
                                catch
                                  echom 'Could not resolve airline theme "' . g:airline_theme . '". Themes have been migrated to github.com/vim-airline/vim-airline-themes.'
                                  let g:airline_theme = 'dark'
                                endtry
                                silent call airline#switch_theme(g:airline_theme)
                              else
                                let g:airline_theme = 'dark'
                                silent call s:on_colorscheme_changed()
                              endif
                            
                              silent doautocmd User AirlineAfterInit

FUNCTION  181()
Called 1 time
Total time:   2.200422
 Self time:   0.000055

count  total (s)   self (s)
    1              0.000016     let Callback = function(self.callback)
    1              0.000003     if a:0
    1   2.200395   0.000028         call Callback(a:1)
    1              0.000001     else
                                    call Callback()
                                endif

FUNCTION  182()
Called 1 time
Total time:   2.205260
 Self time:   0.000195

count  total (s)   self (s)
                            
                                "required because clicking the command window below another window still
                                "invokes the <LeftRelease> mapping - but changes the window cursor
                                "is in first
                                "
                                "TODO: remove this check when the vim bug is fixed
    1   0.000039   0.000022     if !g:NERDTree.ExistsForBuf()
                                    return {}
                                endif
                            
    1   0.004579   0.000088     let node = g:NERDTreeFileNode.GetSelected()
    1              0.000007     if !empty(node)
                            
                                    "try file node
    1              0.000004         if !node.path.isDirectory
    1   0.000161   0.000026             let km = s:KeyMap.FindFor(a:key, "FileNode")
    1              0.000004             if !empty(km)
    1   2.200440   0.000018                 return km.invoke(node)
                                        endif
                                    endif
                            
                                    "try dir node
                                    if node.path.isDirectory
                                        let km = s:KeyMap.FindFor(a:key, "DirNode")
                                        if !empty(km)
                                            return km.invoke(node)
                                        endif
                                    endif
                            
                                    "try generic node
                                    let km = s:KeyMap.FindFor(a:key, "Node")
                                    if !empty(km)
                                        return km.invoke(node)
                                    endif
                            
                                endif
                            
                                "try bookmark
                                let bm = g:NERDTreeBookmark.GetSelected()
                                if !empty(bm)
                                    let km = s:KeyMap.FindFor(a:key, "Bookmark")
                                    if !empty(km)
                                        return km.invoke(bm)
                                    endif
                                endif
                            
                                "try all
                                let km = s:KeyMap.FindFor(a:key, "all")
                                if !empty(km)
                                    return km.invoke()
                                endif

FUNCTION  airline#extensions#apply_left_override()
Called 4 times
Total time:   0.000500
 Self time:   0.000044

count  total (s)   self (s)
    4              0.000008   let w:airline_section_a = a:section1
    4              0.000005   let w:airline_section_b = a:section2
    4   0.000477   0.000021   let w:airline_section_c = airline#section#create(['readonly'])
    4              0.000006   let w:airline_render_left = 1
    4              0.000004   let w:airline_render_right = 0

FUNCTION  airline#util#getwinvar()
Called 108 times
Total time:   0.000300
 Self time:   0.000300

count  total (s)   self (s)
  108              0.000276     return getwinvar(a:winnr, a:key, a:def)

FUNCTION  <SNR>86_get_section()
Called 78 times
Total time:   0.001632
 Self time:   0.001448

count  total (s)   self (s)
   78              0.000129   if has_key(s:section_truncate_width, a:key)
   44              0.000088     if winwidth(a:winnr) < s:section_truncate_width[a:key]
    6              0.000002       return ''
                                endif
   38              0.000016   endif
   72              0.000078   let spc = g:airline_symbols.space
   72              0.000180   if !exists('g:airline_section_{a:key}')
                                return ''
                              endif
   72   0.000465   0.000281   let text = airline#util#getwinvar(a:winnr, 'airline_section_'.a:key, g:airline_section_{a:key})
   72              0.000260   let [prefix, suffix] = [get(a:000, 0, '%('.spc), get(a:000, 1, spc.'%)')]
   72              0.000163   return empty(text) ? '' : prefix.text.suffix

FUNCTION  gitgutter#hunk#hunks()
Called 1 time
Total time:   0.000013
 Self time:   0.000005

count  total (s)   self (s)
    1   0.000013   0.000005   return gitgutter#utility#getbufvar(gitgutter#utility#bufnr(), 'hunks', [])

FUNCTION  syntastic#util#getbufvar()
Called 6 times
Total time:   0.000026
 Self time:   0.000026

count  total (s)   self (s)
    6              0.000022     return a:0 ? s:_getbufvar(a:buf, a:name, a:1) : getbufvar(a:buf, a:name)

FUNCTION  <SNR>14_LoadIndent()
Called 1 time
Total time:   0.000145
 Self time:   0.000120

count  total (s)   self (s)
    1              0.000002     if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
                                endif
    1              0.000002     let s = expand("<amatch>")
    1              0.000001     if s != ""
    1              0.000001       if exists("b:did_indent")
                            	unlet b:did_indent
                                  endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
    2              0.000005       for name in split(s, '\.')
    1   0.000125   0.000100 	exe 'runtime! indent/' . name . '.vim'
    1              0.000001       endfor
    1              0.000001     endif

FUNCTION  airline#extensions#syntastic#get()
Called 4 times
Total time:   0.000322
 Self time:   0.000071

count  total (s)   self (s)
    4              0.000008   let _backup = get(g:, 'syntastic_stl_format', '')
    4              0.000008   let is_err = (a:type  is# 'error')
    4              0.000001   if is_err
    2              0.000005     let g:syntastic_stl_format = get(g:, 'airline#extensions#syntastic#stl_format_err', '%E{[%e(#%fe)]}')
    2              0.000000   else
    2              0.000004     let g:syntastic_stl_format = get(g:, 'airline#extensions#syntastic#stl_format_warn', '%W{[%w(#%fw)]}')
    2              0.000000   endif
    4   0.000264   0.000013   let cnt = SyntasticStatuslineFlag()
    4              0.000005   if !empty(_backup)
    4              0.000004     let g:syntastic_stl_format = _backup
    4              0.000003   endif
    4              0.000004   if empty(cnt)
    4              0.000001     return ''
                              else
                                return (is_err ? s:error_symbol : s:warning_symbol).cnt
                              endif

FUNCTION  syntastic#util#isRunningWindows()
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000005     return has('win16') || has('win32') || has('win64')

FUNCTION  gitgutter#utility#restore_shell()
Called 2 times
Total time:   0.000064
 Self time:   0.000064

count  total (s)   self (s)
    2              0.000009   if has('unix')
    2              0.000010     if exists('s:shell')
    2              0.000015       let &shell = s:shell
    2              0.000010       let &shellcmdflag = s:shellcmdflag
    2              0.000010       let &shellredir = s:shellredir
    2              0.000002     endif
    2              0.000003   endif

FUNCTION  <SNR>123__get_include_dirs()
Called 1 time
Total time:   0.000135
 Self time:   0.000050

count  total (s)   self (s)
    1              0.000001     let include_dirs = []
                            
    1              0.000014     if a:filetype =~# '\v^%(c|cpp|objc|objcpp)$' && (!exists('g:syntastic_'.a:filetype.'_no_default_include_dirs') || !g:syntastic_{a:filetype}_no_default_include_dirs)
    1              0.000003         let include_dirs = copy(s:default_includes)
    1              0.000001     endif
                            
    1              0.000002     if exists('g:syntastic_'.a:filetype.'_include_dirs')
                                    call extend(include_dirs, g:syntastic_{a:filetype}_include_dirs)
                                endif
                            
    1   0.000110   0.000025     return join(map(syntastic#util#unique(include_dirs), 'syntastic#util#shescape("-I" . v:val)'))

FUNCTION  airline#extensions#syntastic#get_error()
Called 2 times
Total time:   0.000159
 Self time:   0.000007

count  total (s)   self (s)
    2   0.000159   0.000007   return airline#extensions#syntastic#get('error')

FUNCTION  gitgutter#utility#using_xolox_shell()
Called 1 time
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    1              0.000002   if s:using_xolox_shell == -1
    1              0.000001     if !g:gitgutter_avoid_cmd_prompt_on_windows
                                  let s:using_xolox_shell = 0
                                " Although xolox/vim-shell works on both windows and unix we only want to use
                                " it on windows.
                                elseif has('win32') || has('win64') || has('win32unix')
                                  let s:using_xolox_shell = exists('g:xolox#misc#version') && exists('g:xolox#shell#version')
                                else
    1              0.000002       let s:using_xolox_shell = 0
    1              0.000000     endif
    1              0.000001   endif
    1              0.000001   return s:using_xolox_shell

FUNCTION  218()
Called 1 time
Total time:   0.000456
 Self time:   0.000012

count  total (s)   self (s)
    1   0.000451   0.000007     if a:path.equals(self.path)
    1              0.000003         return self
                                endif
                                return {}

FUNCTION  <SNR>98_build_command()
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000001   if has('unix')
    1              0.000001     return ['sh', '-c', a:cmd]
                              endif
                            
                              if has('win32')
                                return has('nvim') ? ['cmd.exe', '/c', a:cmd] : 'cmd.exe /c '.a:cmd
                              endif
                            
                              throw 'unknown os'

FUNCTION  syntastic#util#var()
Called 16 times
Total time:   0.000128
 Self time:   0.000072

count  total (s)   self (s)
   16   0.000124   0.000068     return call('syntastic#util#rawVar', ['syntastic_' . a:name] + a:000)

FUNCTION  ObsessionStatus()
Called 2 times
Total time:   0.000049
 Self time:   0.000049

count  total (s)   self (s)
    2              0.000006   let args = copy(a:000)
    2              0.000007   let numeric = !empty(v:this_session) + exists('g:this_obsession')
    2              0.000005   if type(get(args, 0, '')) == type(0)
                                if !remove(args, 0)
                                  return ''
                                endif
                              endif
    2              0.000002   if empty(args)
                                let args = ['[$]', '[S]']
                              endif
    2              0.000003   if len(args) == 1 && numeric == 1
                                let fmt = args[0]
                              else
    2              0.000004     let fmt = get(args, 2-numeric, '')
    2              0.000001   endif
    2              0.000010   return substitute(fmt, '%s', get(['', 'Session', 'Obsession'], numeric), 'g')

FUNCTION  syntastic#util#compareLexi()
Called 1 time
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    1              0.000004     for idx in range(max([len(a:a), len(a:b)]))
    1              0.000002         let a_element = str2nr(get(a:a, idx, 0))
    1              0.000003         let b_element = str2nr(get(a:b, idx, 0))
    1              0.000001         if a_element != b_element
    1              0.000001             return a_element > b_element ? 1 : -1
                                    endif
                                endfor
                                " still here, thus everything matched
                                return 0

FUNCTION  <SNR>73_is_branch_empty()
Called 2 times
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    2              0.000007   return exists('*airline#extensions#branch#head') && empty(get(b:, 'airline_head', ''))

FUNCTION  <SNR>80_wrap_accent()
Called 4 times
Total time:   0.000044
 Self time:   0.000036

count  total (s)   self (s)
    4              0.000007   if exists('a:part.accent')
    4   0.000025   0.000017     call airline#highlighter#add_accent(a:part.accent)
    4              0.000009     return '%#__accent_'.(a:part.accent).'#'.a:value.'%#__restore__#'
                              endif
                              return a:value

FUNCTION  syntastic#log#debugShowVariables()
Called 2 times
Total time:   0.000011
 Self time:   0.000008

count  total (s)   self (s)
    2   0.000009   0.000006     if !s:_isDebugEnabled(a:level)
    2              0.000001         return
                                endif
                            
                                let leader = s:_log_timestamp()
                                call s:_logRedirect(1)
                            
                                let vlist = type(a:names) == type('') ? [a:names] : a:names
                                for name in vlist
                                    let msg = s:_format_variable(name)
                                    if msg !=# ''
                                        echomsg leader . msg
                                    endif
                                endfor
                            
                                call s:_logRedirect(0)

FUNCTION  nerdtree#runningWindows()
Called 30 times
Total time:   0.000509
 Self time:   0.000509

count  total (s)   self (s)
   30              0.000491     return has("win16") || has("win32") || has("win64")

FUNCTION  285()
Called 1 time
Total time:   0.001132
 Self time:   0.000432

count  total (s)   self (s)
    1              0.000005     if empty(self._reuse)
                                    return 0
                                endif
                            
                                "check the current tab for the window
    1   0.000521   0.000315     let winnr = bufwinnr('^' . self._path.str() . '$')
    1              0.000007     if winnr != -1
                                    call nerdtree#exec(winnr . "wincmd w")
                                    call self._checkToCloseTree(0)
                                    return 1
                                endif
                            
    1              0.000005     if self._reuse == 'currenttab'
                                    return 0
                                endif
                            
                                "check other tabs
    1   0.000518   0.000024     let tabnr = self._path.tabnr()
    1              0.000005     if tabnr
                                    call self._checkToCloseTree(1)
                                    call nerdtree#exec('normal! ' . tabnr . 'gt')
                                    let winnr = bufwinnr('^' . self._path.str() . '$')
                                    call nerdtree#exec(winnr . "wincmd w")
                                    return 1
                                endif
                            
    1              0.000003     return 0

FUNCTION  <SNR>90_reset_summary()
Called 2 times
Total time:   0.000062
 Self time:   0.000024

count  total (s)   self (s)
    2   0.000060   0.000022   call gitgutter#utility#setbufvar(gitgutter#utility#bufnr(), 'summary', [0,0,0])

FUNCTION  airline#highlighter#highlight()
Called 2 times
Total time:   0.022348
 Self time:   0.002905

count  total (s)   self (s)
    2              0.000004   let bufnr = a:0 ? a:1 : ''
    2              0.000004   let p = g:airline#themes#{g:airline_theme}#palette
                            
                              " draw the base mode, followed by any overrides
    2              0.000013   let mapped = map(a:modes, 'v:val == a:modes[0] ? v:val : a:modes[0]."_".v:val')
    2              0.000004   let suffix = a:modes[0] == 'inactive' ? '_inactive' : ''
    5              0.000006   for mode in mapped
    3              0.000006     if mode == 'inactive' && winnr('$') == 1
                                  " there exist no inactive windows, don't need to create all those
                                  " highlighting groups
                                  continue
                                endif
    3              0.000010     if exists('g:airline#themes#{g:airline_theme}#palette[mode]')
    2              0.000004       let dict = g:airline#themes#{g:airline_theme}#palette[mode]
   36              0.000056       for kvp in items(dict)
   34              0.000054         let mode_colors = kvp[1]
   34              0.000045         let name = kvp[0]
   34              0.000065         if name is# 'airline_c' && !empty(bufnr) && suffix is# '_inactive'
    1              0.000001           let name = 'airline_c'.bufnr
    1              0.000001         endif
   34   0.004714   0.000135         call airline#highlighter#exec(name.suffix, mode_colors)
                            
  102              0.000125         for accent in keys(s:accents)
   68              0.000115           if !has_key(p.accents, accent)
                                        continue
                                      endif
   68              0.000140           let colors = copy(mode_colors)
   68              0.000117           if p.accents[accent][0] != ''
   34              0.000059             let colors[0] = p.accents[accent][0]
   34              0.000017           endif
   68              0.000082           if p.accents[accent][2] != ''
   34              0.000049             let colors[2] = p.accents[accent][2]
   34              0.000015           endif
   68              0.000076           if len(colors) >= 5
   68              0.000138             let colors[4] = get(p.accents[accent], 4, '')
   68              0.000029           else
                                        call add(colors, get(p.accents[accent], 4, ''))
                                      endif
   68   0.010039   0.000304           call airline#highlighter#exec(name.suffix.'_'.accent, colors)
   68              0.000045         endfor
   34              0.000020       endfor
                            
                                  " TODO: optimize this
   20              0.000030       for sep in items(s:separators)
   18   0.005242   0.000113         call <sid>exec_separator(dict, sep[1][0], sep[1][1], sep[1][2], suffix)
   18              0.000013       endfor
    2              0.000002     endif
    3              0.000002   endfor

FUNCTION  airline#parts#ffenc()
Called 2 times
Total time:   0.000062
 Self time:   0.000062

count  total (s)   self (s)
    2              0.000005   let expected = get(g:, 'airline#parts#ffenc#skip_expected_string', '')
    2              0.000003   let bomb     = &l:bomb ? '[BOM]' : ''
    2              0.000025   let ff       = strlen(&ff) ? '['.&ff.']' : ''
    2              0.000013   if expected is# &fenc.bomb.ff
                                return ''
                              else
    2              0.000012     return &fenc.bomb.ff
                              endif

FUNCTION  gitgutter#sign#upsert_new_gitgutter_signs()
Called 1 time
Total time:   0.000033
 Self time:   0.000023

count  total (s)   self (s)
    1   0.000002   0.000001   let bufnr = gitgutter#utility#bufnr()
    1   0.000007   0.000002   let other_signs         = gitgutter#utility#getbufvar(bufnr, 'other_signs')
    1   0.000007   0.000003   let old_gitgutter_signs = gitgutter#utility#getbufvar(bufnr, 'gitgutter_signs')
                            
    1              0.000001   for line in a:modified_lines
                                let line_number = line[0]  " <number>
                                if index(other_signs, line_number) == -1  " don't clobber others' signs
                                  let name = gitgutter#utility#highlight_name_for_change(line[1])
                                  if !has_key(old_gitgutter_signs, line_number)  " insert
                                    let id = gitgutter#sign#next_sign_id()
                                    execute "sign place" id "line=" . line_number "name=" . name "buffer=" . bufnr
                                  else  " update if sign has changed
                                    let old_sign = old_gitgutter_signs[line_number]
                                    if old_sign.name !=# name
                                      execute "sign place" old_sign.id "name=" . name "buffer=" . bufnr
                                    end
                                  endif
                                endif
                              endfor
                              " At this point b:gitgutter_gitgutter_signs is out of date.

FUNCTION  gitgutter#async#available()
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    1              0.000002   return s:available

FUNCTION  gitgutter#diff#parse_hunk()
Called 1 time
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    1              0.000006   let matches = matchlist(a:line, s:hunk_re)
    1              0.000002   if len(matches) > 0
                                let from_line  = str2nr(matches[1])
                                let from_count = (matches[2] == '') ? 1 : str2nr(matches[2])
                                let to_line    = str2nr(matches[3])
                                let to_count   = (matches[4] == '') ? 1 : str2nr(matches[4])
                                return [from_line, from_count, to_line, to_count]
                              else
    1              0.000001     return []
                              end

FUNCTION  airline#parts#get()
Called 4 times
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    4              0.000009   return get(s:parts, a:key, {})

FUNCTION  airline#parts#paste()
Called 2 times
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    2              0.000003   return g:airline_detect_paste && &paste ? g:airline_symbols.paste : ''

FUNCTION  <SNR>85_get_accented_line()
Called 58 times
Total time:   0.002117
 Self time:   0.002117

count  total (s)   self (s)
   58              0.000060   if a:self._context.active
   38              0.000037     let contents = []
   38              0.000231     let content_parts = split(a:contents, '__accent')
   92              0.000098     for cpart in content_parts
   54              0.000366       let accent = matchstr(cpart, '_\zs[^#]*\ze')
   54              0.000103       call add(contents, cpart)
   54              0.000032     endfor
   38              0.000082     let line = join(contents, a:group)
   38              0.000164     let line = substitute(line, '__restore__', a:group, 'g')
   38              0.000019   else
   20              0.000279     let line = substitute(a:contents, '%#__accent[^#]*#', '', 'g')
   20              0.000083     let line = substitute(line, '%#__restore__#', '', 'g')
   20              0.000005   endif
   58              0.000050   return line

FUNCTION  airline#update_statusline()
Called 6 times
Total time:   0.049170
 Self time:   0.000451

count  total (s)   self (s)
    6   0.000066   0.000041   if airline#util#getwinvar(winnr(), 'airline_disabled', 0)
                                return
                              endif
   12              0.000056   for nr in filter(range(1, winnr('$')), 'v:val != winnr()')
    6   0.000039   0.000020     if airline#util#getwinvar(nr, 'airline_disabled', 0)
                                  continue
                                endif
    6              0.000022     call setwinvar(nr, 'airline_active', 0)
    6              0.000028     let context = { 'winnr': nr, 'active': 0, 'bufnr': winbufnr(nr) }
    6   0.016662   0.000057     call s:invoke_funcrefs(context, s:inactive_funcrefs)
    6              0.000004   endfor
                            
    6              0.000012   unlet! w:airline_render_left w:airline_render_right
    6              0.000054   exe 'unlet! ' 'w:airline_section_'. join(s:sections, ' w:airline_section_')
                            
    6              0.000006   let w:airline_active = 1
    6              0.000022   let context = { 'winnr': winnr(), 'active': 1, 'bufnr': winbufnr(winnr()) }
    6   0.032112   0.000042   call s:invoke_funcrefs(context, g:airline_statusline_funcrefs)

FUNCTION  SyntasticLoclistHide()
Called 1 time
Total time:   0.000009
 Self time:   0.000004

count  total (s)   self (s)
    1   0.000007   0.000002     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'loclist: hide')
    1              0.000001     silent! lclose

FUNCTION  gitgutter#sign#obsolete_gitgutter_signs_to_remove()
Called 1 time
Total time:   0.000026
 Self time:   0.000019

count  total (s)   self (s)
    1   0.000003   0.000001   let bufnr = gitgutter#utility#bufnr()
    1              0.000001   let signs_to_remove = []  " list of [<id (number)>, ...]
    1              0.000001   let remove_all_signs = 1
    1   0.000009   0.000004   let old_gitgutter_signs = gitgutter#utility#getbufvar(bufnr, 'gitgutter_signs')
    1              0.000002   for line_number in keys(old_gitgutter_signs)
                                if index(a:new_gitgutter_signs_line_numbers, str2nr(line_number)) == -1
                                  call add(signs_to_remove, old_gitgutter_signs[line_number].id)
                                else
                                  let remove_all_signs = 0
                                endif
                              endfor
    1              0.000001   let s:remove_all_old_signs = remove_all_signs
    1              0.000001   return signs_to_remove

FUNCTION  airline#parts#readonly()
Called 8 times
Total time:   0.000117
 Self time:   0.000117

count  total (s)   self (s)
    8              0.000048   if &readonly && !filereadable(bufname('%'))
                                return '[noperm]'
                              else
    8              0.000031     return &readonly ? g:airline_symbols.readonly : ''
                              endif

FUNCTION  gitgutter#utility#directory_of_file()
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000005   return fnamemodify(s:file, ':h')

FUNCTION  syntastic#util#bufIsActive()
Called 1 time
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
                                " convert to number, or hell breaks loose
    1              0.000003     let buf = str2nr(a:buffer)
                            
    1              0.000002     if !bufloaded(buf) || !buflisted(buf)
                                    return 0
                                endif
                            
                                " get rid of hidden buffers
    1              0.000003     for tab in range(1, tabpagenr('$'))
    1              0.000002         if index(tabpagebuflist(tab), buf) >= 0
    1              0.000001             return 1
                                    endif
                                endfor
                            
                                return 0

FUNCTION  <SNR>5_SynSet()
Called 1 time
Total time:   0.001912
 Self time:   0.000261

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
    1              0.000003   syn clear
    1              0.000002   if exists("b:current_syntax")
                                unlet b:current_syntax
                              endif
                            
    1              0.000002   let s = expand("<amatch>")
    1              0.000001   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
                              elseif s == "OFF"
                                let s = ""
                              endif
                            
    1              0.000000   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.
    2              0.000006     for name in split(s, '\.')
    1   0.001884   0.000233       exe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
    1              0.000001     endfor
    1              0.000000   endif

FUNCTION  gitgutter#utility#setbufvar()
Called 9 times
Total time:   0.000111
 Self time:   0.000111

count  total (s)   self (s)
    9              0.000043   let dict = get(getbufvar(a:buffer, ''), 'gitgutter', {})
    9              0.000029   let dict[a:varname] = a:val
    9              0.000033   call setbufvar(a:buffer, 'gitgutter', dict)

FUNCTION  nerdtree#has_opt()
Called 17 times
Total time:   0.000131
 Self time:   0.000131

count  total (s)   self (s)
   17              0.000123     return has_key(a:options, a:name) && a:options[a:name] == 1

FUNCTION  airline#extensions#obsession#get_status()
Called 2 times
Total time:   0.000061
 Self time:   0.000012

count  total (s)   self (s)
    2   0.000061   0.000012   return ObsessionStatus((g:airline#extensions#obsession#indicator_text . s:spc), '')

FUNCTION  airline#highlighter#exec()
Called 214 times
Total time:   0.027881
 Self time:   0.008720

count  total (s)   self (s)
  214              0.000234   if pumvisible()
                                return
                              endif
  214              0.000219   let colors = a:colors
  214              0.000171   if s:is_win32term
                                let colors[2] = s:gui2cui(get(colors, 0, ''), get(colors, 2, ''))
                                let colors[3] = s:gui2cui(get(colors, 1, ''), get(colors, 3, ''))
                              endif
  214   0.015379   0.000618   let old_hi = airline#highlighter#get_highlight(a:group)
  214              0.000292   if len(colors) == 4
  110              0.000193     call add(colors, '')
  110              0.000045   endif
  214              0.000184   if g:airline_gui_mode ==# 'gui'
                                let new_hi = [colors[0], colors[1], '', '', colors[4]]
                              else
  214              0.000964     let new_hi = ['', '', printf("%s", colors[2]), printf("%s", colors[3]), colors[4]]
  214              0.000093   endif
  214   0.002535   0.000556   let colors = s:CheckDefined(colors)
  214   0.001857   0.000614   if old_hi != new_hi || !s:hl_group_exists(a:group)
   48   0.001804   0.000626     let cmd = printf('hi %s %s %s %s %s %s %s %s', a:group, s:Get(colors, 0, 'guifg='), s:Get(colors, 1, 'guibg='), s:Get(colors, 2, 'ctermfg='), s:Get(colors, 3, 'ctermbg='), s:Get(colors, 4, 'gui='), s:Get(colors, 4, 'cterm='), s:Get(colors, 4, 'term='))
   48              0.000305     exe cmd
   48              0.000094     if has_key(s:hl_groups, a:group)
   48              0.000078       let s:hl_groups[a:group] = colors
   48              0.000018     endif
   48              0.000016   endif

FUNCTION  <SNR>87__isDebugEnabled_smart()
Called 36 times
Total time:   0.000073
 Self time:   0.000073

count  total (s)   self (s)
   36              0.000062     return and(g:syntastic_debug, a:level)

FUNCTION  <SNR>123__registerHandler()
Called 14 times
Total time:   0.000097
 Self time:   0.000097

count  total (s)   self (s)
   14              0.000012     let handler = {}
   14              0.000017     let handler['regex'] = a:regex
   14              0.000030     let handler['func'] = function(a:function)
   14              0.000015     let handler['args'] = a:args
   14              0.000017     call add(s:handlers, handler)

FUNCTION  airline#extensions#whitespace#check()
Called 2 times
Total time:   0.000505
 Self time:   0.000193

count  total (s)   self (s)
    2              0.000004   let max_lines = get(g:, 'airline#extensions#whitespace#max_lines', 20000)
    2              0.000008   if &readonly || !&modifiable || !s:enabled || line('$') > max_lines || get(b:, 'airline_whitespace_disabled', 0)
                                return ''
                              endif
                            
    2              0.000003   if !exists('b:airline_whitespace_check')
    1              0.000002     let b:airline_whitespace_check = ''
    1              0.000004     let checks = get(b:, 'airline_whitespace_checks', get(g:, 'airline#extensions#whitespace#checks', s:default_checks))
                            
    1              0.000001     let trailing = 0
    1              0.000002     if index(checks, 'trailing') > -1
    1              0.000001       try
    1              0.000002         let regexp = get(g:, 'airline#extensions#whitespace#trailing_regexp', '\s$')
    1              0.000030         let trailing = search(regexp, 'nw')
    1              0.000001       catch
                                    echomsg 'airline#whitespace: error occurred evaluating '. regexp
                                    echomsg v:exception
                                    return ''
                                  endtry
    1              0.000000     endif
                            
    1              0.000001     let mixed = 0
    1              0.000001     let check = 'indent'
    1              0.000007     if index(checks, check) > -1 && index(get(s:skip_check_ft, &ft, []), check) < 0
    1   0.000245   0.000008       let mixed = s:check_mixed_indent()
    1              0.000000     endif
                            
    1              0.000001     let mixed_file = ''
    1              0.000001     let check = 'mixed-indent-file'
    1              0.000006     if index(checks, check) > -1 && index(get(s:skip_check_ft, &ft, []), check) < 0
    1   0.000066   0.000009       let mixed_file = s:check_mixed_indent_file()
    1              0.000000     endif
                            
    1              0.000001     let long = 0
    1              0.000002     if index(checks, 'long') > -1 && &tw > 0
                                  let long = search('\%>'.&tw.'v.\+', 'nw')
                                endif
                            
    1              0.000002     if trailing != 0 || mixed != 0 || long != 0 || !empty(mixed_file)
    1              0.000001       let b:airline_whitespace_check = s:symbol
    1              0.000002       if strlen(s:symbol) > 0
    1              0.000001         let space = (g:airline_symbols.space)
    1              0.000001       else
                                    let space = ''
                                  endif
                            
    1              0.000001       if s:show_message
    1              0.000001         if trailing != 0
    1              0.000002           let trailing_fmt = get(g:, 'airline#extensions#whitespace#trailing_format', '[%s]trailing')
    1              0.000005           let b:airline_whitespace_check .= space.printf(trailing_fmt, trailing)
    1              0.000001         endif
    1              0.000000         if mixed != 0
                                      let mixed_indent_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_format', '[%s]mixed-indent')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_fmt, mixed)
                                    endif
    1              0.000001         if long != 0
                                      let long_fmt = get(g:, 'airline#extensions#whitespace#long_format', '[%s]long')
                                      let b:airline_whitespace_check .= space.printf(long_fmt, long)
                                    endif
    1              0.000001         if !empty(mixed_file)
                                      let mixed_indent_file_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_file_format', '[%s]mix-indent-file')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_file_fmt, mixed_file)
                                    endif
    1              0.000000       endif
    1              0.000001     endif
    1              0.000000   endif
    2   0.000026   0.000008   return airline#util#shorten(b:airline_whitespace_check, 120, 9)

FUNCTION  nerdtree#exec()
Called 5 times
Total time:   0.040409
 Self time:   0.000244

count  total (s)   self (s)
    5              0.000052     let old_ei = &ei
    5              0.000069     set ei=BufEnter,BufLeave,VimEnter
    5   0.040237   0.000072     exec a:cmd
    5              0.000046     let &ei = old_ei

FUNCTION  <SNR>75_ws_refresh()
Called 1 time
Total time:   0.000039
 Self time:   0.000039

count  total (s)   self (s)
    1              0.000010   if get(b:, 'airline_ws_changedtick', 0) == b:changedtick
                                return
                              endif
    1              0.000006   unlet! b:airline_whitespace_check
    1              0.000005   if get(g:, 'airline_skip_empty_sections', 0)
                                exe ':AirlineRefresh'
                              endif
    1              0.000007   let b:airline_ws_changedtick = b:changedtick

FUNCTION  <SNR>98_on_stdout_vim()
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000003   call add(self.stdoutbuffer, a:data)

FUNCTION  120()
Called 1 time
Total time:   2.158198
 Self time:   0.001491

count  total (s)   self (s)
    1   2.158197   0.001490     exec "edit " . self.str({'format': 'Edit'})

FUNCTION  gitgutter#utility#not_git_dir()
Called 2 times
Total time:   0.000051
 Self time:   0.000033

count  total (s)   self (s)
    2   0.000049   0.000031   return gitgutter#utility#full_path_to_directory_of_file() !~ '[/\\]\.git\($\|[/\\]\)'

FUNCTION  <SNR>68_is_excluded_window()
Called 12 times
Total time:   0.000548
 Self time:   0.000548

count  total (s)   self (s)
   12              0.000025   for matchft in g:airline_exclude_filetypes
                                if matchft ==# &ft
                                  return 1
                                endif
                              endfor
                            
   48              0.000058   for matchw in g:airline_exclude_filenames
   36              0.000242     if matchstr(expand('%'), matchw) ==# matchw
                                  return 1
                                endif
   36              0.000021   endfor
                            
   12              0.000016   if g:airline_exclude_preview && &previewwindow
                                return 1
                              endif
                            
   12              0.000010   return 0

FUNCTION  gitgutter#utility#full_path_to_directory_of_file()
Called 2 times
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    2              0.000016   return fnamemodify(s:file, ':p:h')

FUNCTION  gitgutter#utility#git_supports_command_line_config_override()
Called 1 time
Total time:   0.003466
 Self time:   0.000059

count  total (s)   self (s)
    1   0.003457   0.000050   call system(g:gitgutter_git_executable.' -c foo.bar=baz --version')
    1              0.000007   return !v:shell_error

FUNCTION  airline#parts#spell()
Called 2 times
Total time:   0.000033
 Self time:   0.000033

count  total (s)   self (s)
    2              0.000016   let spelllang = g:airline_detect_spelllang ? printf(" [%s]", toupper(substitute(&spelllang, ',', '/', 'g'))) : ''
    2              0.000003   if g:airline_detect_spell && &spell
                                if winwidth(0) >= 90
                                  return g:airline_symbols.spell . spelllang
                                elseif winwidth(0) >= 70
                                  return g:airline_symbols.spell
                                else
                                  return split(g:airline_symbols.spell, '\zs')[0]
                                endif
                              endif
    2              0.000001   return ''

FUNCTION  <SNR>98_on_exit_vim()
Called 1 time
Total time:   0.000793
 Self time:   0.000015

count  total (s)   self (s)
    1   0.000791   0.000013   call s:buffer_exec(self.buffer, function('gitgutter#handle_diff', [gitgutter#utility#stringify(self.stdoutbuffer)]))

FUNCTION  gitgutter#hunk#summary()
Called 2 times
Total time:   0.000025
 Self time:   0.000009

count  total (s)   self (s)
    2   0.000025   0.000009   return gitgutter#utility#getbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  <SNR>20_persist()
Called 1 time
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
    1              0.000002   if exists('g:SessionLoad')
                                return ''
                              endif
    1              0.000002   let sessionoptions = &sessionoptions
    1              0.000001   if exists('g:this_obsession')
                                try
                                  set sessionoptions-=blank sessionoptions-=options sessionoptions+=tabpages
                                  execute 'mksession! '.fnameescape(g:this_obsession)
                                  let body = readfile(g:this_obsession)
                                  call insert(body, 'let g:this_session = v:this_session', -3)
                                  call insert(body, 'let g:this_obsession = v:this_session', -3)
                                  call insert(body, 'let g:this_obsession_status = 2', -3)
                                  if type(get(g:, 'obsession_append')) == type([])
                                    for line in g:obsession_append
                                      call insert(body, line, -3)
                                    endfor
                                  endif
                                  call writefile(body, g:this_obsession)
                                  let g:this_session = g:this_obsession
                                  if exists('#User#Obsession')
                                    try
                                      let [save_mls, &modelines] = [&mls, 0]
                                      doautocmd User Obsession
                                    finally
                                      let &mls = save_mls
                                    endtry
                                  endif
                                catch
                                  unlet g:this_obsession
                                  let &l:readonly = &l:readonly
                                  return 'echoerr '.string(v:exception)
                                finally
                                  let &sessionoptions = sessionoptions
                                endtry
                              endif
    1              0.000001   return ''

FUNCTION  nerdtree#checkForBrowse()
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000005     if !isdirectory(a:dir)
    1              0.000001         return
                                endif
                            
                                if s:reuseWin(a:dir)
                                    return
                                endif
                            
                                call g:NERDTreeCreator.CreateWindowTree(a:dir)

FUNCTION  gitgutter#utility#bufnr()
Called 13 times
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
   13              0.000021   return s:bufnr

FUNCTION  airline#parts#crypt()
Called 2 times
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    2              0.000008   return g:airline_detect_crypt && exists("+key") && !empty(&key) ? g:airline_symbols.crypt : ''

FUNCTION  210()
Called 1 time
Total time:   2.200343
 Self time:   0.000033

count  total (s)   self (s)
    1   2.200342   0.000032     call self.open(a:0 ? a:1 : {})

FUNCTION  syntastic#log#debugDump()
Called 1 time
Total time:   0.000004
 Self time:   0.000003

count  total (s)   self (s)
    1   0.000003   0.000002     if !s:_isDebugEnabled(a:level)
    1              0.000001         return
                                endif
                            
                                call syntastic#log#debugShowVariables( a:level, sort(keys(g:_SYNTASTIC_DEFAULTS)) )

FUNCTION  gitgutter#diff#run_diff()
Called 1 time
Total time:   0.000665
 Self time:   0.000201

count  total (s)   self (s)
                              " Wrap compound commands in parentheses to make Windows happy.
                              " bash doesn't mind the parentheses.
    1              0.000002   let cmd = '('
                            
    1   0.000007   0.000004   let bufnr = gitgutter#utility#bufnr()
    1   0.000024   0.000009   let tracked = gitgutter#utility#getbufvar(bufnr, 'tracked', 0)  " i.e. tracked by git
    1              0.000001   if !tracked
                                " Don't bother trying to realtime-diff an untracked file.
                                " NOTE: perhaps we should pull this guard up to the caller?
    1              0.000001     if a:realtime
                                  throw 'diff failed'
                                else
    1   0.000036   0.000014       let cmd .= g:gitgutter_git_executable.' ls-files --error-unmatch '.gitgutter#utility#shellescape(gitgutter#utility#filename()).' && ('
    1              0.000001     endif
    1              0.000000   endif
                            
    1              0.000001   if a:realtime
                                let blob_name = g:gitgutter_diff_base.':'.gitgutter#utility#shellescape(gitgutter#utility#file_relative_to_repo_root())
                                let blob_file = s:temp_index
                                let buff_file = s:temp_buffer
                                let extension = gitgutter#utility#extension()
                                if !empty(extension)
                                  let blob_file .= '.'.extension
                                  let buff_file .= '.'.extension
                                endif
                                let cmd .= g:gitgutter_git_executable.' show '.blob_name.' > '.blob_file.' && '
                            
                                " Writing the whole buffer resets the '[ and '] marks and also the
                                " 'modified' flag (if &cpoptions includes '+').  These are unwanted
                                " side-effects so we save and restore the values ourselves.
                                let modified      = getbufvar(bufnr, "&mod")
                                let op_mark_start = getpos("'[")
                                let op_mark_end   = getpos("']")
                            
                                let current_buffer = bufnr('')
                                execute 'buffer '.bufnr
                                execute 'keepalt noautocmd silent write!' buff_file
                                execute 'buffer '.current_buffer
                            
                                call setbufvar(bufnr, "&mod", modified)
                                call setpos("'[", op_mark_start)
                                call setpos("']", op_mark_end)
                              endif
                            
    1              0.000002   let cmd .= g:gitgutter_git_executable
    1              0.000001   if s:c_flag
    1              0.000001     let cmd .= ' -c "diff.autorefreshindex=0"'
    1              0.000001     let cmd .= ' -c "diff.noprefix=false"'
    1              0.000001   endif
    1              0.000002   let cmd .= ' diff --no-ext-diff --no-color -U0 '.g:gitgutter_diff_args.' '
                            
    1              0.000001   if a:realtime
                                let cmd .= ' -- '.blob_file.' '.buff_file
                              else
    1   0.000017   0.000004     let cmd .= g:gitgutter_diff_base.' -- '.gitgutter#utility#shellescape(gitgutter#utility#filename())
    1              0.000000   endif
                            
    1              0.000001   if !a:preserve_full_diff && s:grep_available
    1   0.000043   0.000004     let cmd .= ' | '.s:grep_command.' '.gitgutter#utility#shellescape('^@@ ')
    1              0.000001   endif
                            
    1              0.000002   if (!a:preserve_full_diff && s:grep_available) || a:realtime
                                " grep exits with 1 when no matches are found; diff exits with 1 when
                                " differences are found.  However we want to treat non-matches and
                                " differences as non-erroneous behaviour; so we OR the command with one
                                " which always exits with success (0).
    1              0.000002     let cmd .= ' || exit 0'
    1              0.000000   endif
                            
    1              0.000003   let cmd .= ')'
                            
    1              0.000001   if !tracked
    1              0.000001     let cmd .= ')'
    1              0.000000   endif
                            
    1   0.000031   0.000010   let cmd = gitgutter#utility#command_in_directory_of_file(cmd)
                            
    1   0.000204   0.000068   if g:gitgutter_async && gitgutter#async#available() && !a:preserve_full_diff
    1   0.000242   0.000027     call gitgutter#async#execute(cmd)
    1              0.000003     return 'async'
                            
                              else
                                let diff = gitgutter#utility#system(cmd)
                            
                                if gitgutter#utility#shell_error()
                                  " A shell error indicates the file is not tracked by git (unless something bizarre is going on).
                                  throw 'diff failed'
                                endif
                            
                                return diff
                              endif

FUNCTION  <SNR>123__get_cflags()
Called 1 time
Total time:   0.000953
 Self time:   0.000096

count  total (s)   self (s)
                                " determine whether to parse header files as well
    1              0.000013     if has_key(a:opts, 'header_names') && expand('%', 1) =~? a:opts['header_names']
                                    if s:_get_checker_var('g', a:ft, a:ck, 'check_header', 0)
                                        let flags = get(a:opts, 'header_flags', '') . ' -c ' . syntastic#c#NullOutput()
                                    else
                                        " checking headers when check_header is unset: bail out
                                        throw 'Syntastic: skip checks'
                                    endif
                                else
    1              0.000002         let flags = get(a:opts, 'main_flags', '')
    1              0.000000     endif
                            
    1   0.000165   0.000016     let flags .= ' ' . s:_get_checker_var('g', a:ft, a:ck, 'compiler_options', '') . ' ' . s:_get_include_dirs(a:ft)
                            
                                " check if the user manually set some cflags
    1   0.000018   0.000005     let b_cflags = s:_get_checker_var('b', a:ft, a:ck, 'cflags', '')
    1              0.000001     if b_cflags !=# ''
                                    let flags .= ' ' . b_cflags
                                endif
                            
                                " add optional config file parameters
    1   0.000015   0.000005     let config_file = s:_get_checker_var('g', a:ft, a:ck, 'config_file', '.syntastic_' . a:ft . '_config')
    1   0.000105   0.000009     let flags .= ' ' . syntastic#c#ReadConfig(config_file)
                            
    1   0.000016   0.000005     if b_cflags ==# '' && (a:ft ==# 'c' || a:ft ==# 'cpp') && !s:_get_checker_var('g', a:ft, a:ck, 'no_include_search', 0)
                                    " refresh the include file search if desired
    1   0.000013   0.000004         if s:_get_checker_var('g', a:ft, a:ck, 'auto_refresh_includes', 0)
                                        let flags .= ' ' . s:_search_headers()
                                    else
                                        " search for header includes if not cached already
    1              0.000002             if !exists('b:syntastic_' . a:ft . '_includes')
    1   0.000583   0.000014                 let b:syntastic_{a:ft}_includes = s:_search_headers()
    1              0.000001             endif
    1              0.000003             let flags .= ' ' . b:syntastic_{a:ft}_includes
    1              0.000000         endif
    1              0.000001     endif
                            
    1              0.000001     return flags

FUNCTION  <SNR>81_CheckDefined()
Called 214 times
Total time:   0.001979
 Self time:   0.001979

count  total (s)   self (s)
                              " Checks, whether the definition of the colors is valid and is not empty or NONE
                              " e.g. if the colors would expand to this:
                              " hi airline_c ctermfg=NONE ctermbg=NONE
                              " that means to clear that highlighting group, therefore, fallback to Normal
                              " highlighting group for the cterm values
                            
                              " This only works, if the Normal highlighting group is actually defined, so
                              " return early, if it has been cleared
  214              0.000426   if !exists("g:airline#highlighter#normal_fg_hi")
                                let g:airline#highlighter#normal_fg_hi = synIDattr(synIDtrans(hlID('Normal')), 'fg', 'cterm')
                              endif
  214              0.000409   if empty(g:airline#highlighter#normal_fg_hi) || g:airline#highlighter#normal_fg_hi < 0
  214              0.000177     return a:colors
                              endif
                            
                              for val in a:colors
                                if !empty(val) && val !=# 'NONE'
                                  return a:colors
                                endif
                              endfor
                              " this adds the bold attribute to the term argument of the :hi command,
                              " but at least this makes sure, the group will be defined
                              let fg = g:airline#highlighter#normal_fg_hi
                              let bg = synIDattr(synIDtrans(hlID('Normal')), 'bg', 'cterm')
                              if bg < 0
                                " in case there is no background color defined for Normal
                                let bg = a:colors[3]
                              endif
                              return a:colors[0:1] + [fg, bg] + [a:colors[4]]

FUNCTION  223()
Called 1 time
Total time:   0.004491
 Self time:   0.000067

count  total (s)   self (s)
                            
    1              0.000004     try
    1   0.002207   0.000021         let l:path = b:NERDTree.ui.getPath(line('.'))
                            
    1              0.000006         if empty(l:path)
                                        return {}
                                    endif
                            
    1   0.002255   0.000017         return b:NERDTree.root.findNode(l:path)
                                catch /^NERDTree/
                                    return {}
                                endtry

FUNCTION  227()
Called 1 time
Total time:   2.200310
 Self time:   0.000041

count  total (s)   self (s)
    1              0.000006     let opts = a:0 ? a:1 : {}
    1   0.000147   0.000016     let opener = g:NERDTreeOpener.New(self.path, opts)
    1   2.200155   0.000017     call opener.open(self)

FUNCTION  GitGutterGetHunkSummary()
Called 2 times
Total time:   0.000033
 Self time:   0.000008

count  total (s)   self (s)
    2   0.000033   0.000008   return gitgutter#hunk#summary(winbufnr(0))

FUNCTION  airline#parts#mode()
Called 2 times
Total time:   0.000033
 Self time:   0.000012

count  total (s)   self (s)
    2   0.000033   0.000012   return airline#util#shorten(get(w:, 'airline_current_mode', ''), 79, 1)

FUNCTION  <SNR>34__is_quitting()
Called 2 times
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
    2              0.000003     let quitting = 0
    2              0.000004     if exists('w:syntastic_wid')
                                    let key = a:buf . '_' . getbufvar(a:buf, 'changetick') . '_' . w:syntastic_wid
                                    let idx = index(s:_quit_pre, key)
                                    if idx >= 0
                                        call remove(s:_quit_pre, idx)
                                        let quitting = 1
                                    endif
                                endif
                            
    2              0.000001     return quitting

FUNCTION  airline#extensions#quickfix#apply()
Called 6 times
Total time:   0.000039
 Self time:   0.000039

count  total (s)   self (s)
    6              0.000010   if &buftype == 'quickfix'
                                let w:airline_section_a = s:get_text()
                                let w:airline_section_b = '%{get(w:, "quickfix_title", "")}'
                                let w:airline_section_c = ''
                                let w:airline_section_x = ''
                              endif

FUNCTION  gitgutter#utility#stringify()
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000003   return join(a:list, "\n")."\n"

FUNCTION  gitgutter#async#execute()
Called 1 time
Total time:   0.000215
 Self time:   0.000210

count  total (s)   self (s)
    1   0.000007   0.000005   let options = {   'stdoutbuffer': [],   'buffer': gitgutter#utility#bufnr() }
    1   0.000010   0.000007   let command = s:build_command(a:cmd)
                            
    1              0.000002   if has('nvim')
                                call jobstart(command, extend(options, {   'on_stdout': function('s:on_stdout_nvim'),   'on_stderr': function('s:on_stderr_nvim'),   'on_exit':   function('s:on_exit_nvim') }))
                              else
    1              0.000181     call job_start(command, {   'out_cb':   function('s:on_stdout_vim', options),   'err_cb':   function('s:on_stderr_vim', options),   'close_cb': function('s:on_exit_vim', options) })
    1              0.000002   endif

FUNCTION  <SNR>60_Highlight_Matching_Pair()
Called 9 times
Total time:   0.001122
 Self time:   0.001122

count  total (s)   self (s)
                              " Remove any previous match.
    9              0.000079   if exists('w:paren_hl_on') && w:paren_hl_on
                                silent! call matchdelete(3)
                                let w:paren_hl_on = 0
                              endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
    9              0.000060   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
                              endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
    9              0.000038   let c_lnum = line('.')
    9              0.000036   let c_col = col('.')
    9              0.000015   let before = 0
                            
    9              0.000035   let text = getline(c_lnum)
    9              0.000180   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
    9              0.000028   if empty(matches)
                                let [c_before, c] = ['', '']
                              else
    9              0.000054     let [c_before, c] = matches[1:2]
    9              0.000010   endif
    9              0.000181   let plist = split(&matchpairs, '.\zs[:,]')
    9              0.000040   let i = index(plist, c)
    9              0.000018   if i < 0
                                " not found, in Insert mode try character before the cursor
    9              0.000037     if c_col > 1 && (mode() == 'i' || mode() == 'R')
                                  let before = strlen(c_before)
                                  let c = c_before
                                  let i = index(plist, c)
                                endif
    9              0.000016     if i < 0
                                  " not found, nothing to do
    9              0.000016       return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
                              if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
                              else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
                              endif
                              if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
                              if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              " Build an expression that detects whether the current cursor position is in
                              " certain syntax types (string, comment, etc.), for use as searchpairpos()'s
                              " skip argument.
                              " We match "escape" for special items, such as lispEscapeSpecial.
                              let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                              " If executing the expression determines that the cursor is currently in
                              " one of the syntax types, then we want searchpairpos() to find the pair
                              " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                              " outside of the syntax types and s_skip should keep its value so we skip any
                              " matching pair inside the syntax types.
                              execute 'if' s_skip '| let s_skip = 0 | endif'
                            
                              " Limit the search to lines visible in the window.
                              let stoplinebottom = line('w$')
                              let stoplinetop = line('w0')
                              if i % 2 == 0
                                let stopline = stoplinebottom
                              else
                                let stopline = stoplinetop
                              endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
                              if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
                                let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
                              endif
                              try
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
                              if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
                              endif
                            
                              " If a match is found setup match highlighting.
                              if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
                                if exists('*matchaddpos')
                                  call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
                                let w:paren_hl_on = 1
                              endif

FUNCTION  <SNR>123__search_headers()
Called 1 time
Total time:   0.000569
 Self time:   0.000566

count  total (s)   self (s)
    1              0.000001     let includes = ''
    1              0.000001     let files = []
    1              0.000000     let found = []
    1              0.000130     let lines = filter(getline(1, 100), 'v:val =~# ''\m^\s*#\s*include''')
                            
                                " search current buffer
    3              0.000004     for line in lines
    2              0.000012         let file = matchstr(line, '\m"\zs\S\+\ze"')
    2              0.000002         if file !=# ''
    1              0.000002             call add(files, file)
    1              0.000001             continue
                                    endif
                            
   15              0.000005         for handler in s:handlers
   14              0.000031             if line =~# handler['regex']
                                            let includes .= call(handler['func'], handler['args'])
                                            call add(found, handler['regex'])
                                            break
                                        endif
   14              0.000009         endfor
    1              0.000000     endfor
                            
                                " search included headers
    2              0.000002     for hfile in files
    1              0.000001         if hfile !=# ''
    1   0.000012   0.000009             let filename = expand('%:p:h', 1) . syntastic#util#Slash() . hfile
                            
    1              0.000001             try
    1              0.000015                 let lines = readfile(filename, '', 100)
    1              0.000001             catch /\m^Vim\%((\a\+)\)\=:E484/
                                            continue
                                        endtry
                            
    1              0.000073             call filter(lines, 'v:val =~# ''\m^\s*#\s*include''')
                            
   15              0.000012             for handler in s:handlers
   14              0.000017                 if index(found, handler['regex']) != -1
                                                continue
                                            endif
                            
   28              0.000010                 for line in lines
   14              0.000028                     if line =~# handler['regex']
                                                    let includes .= call(handler['func'], handler['args'])
                                                    call add(found, handler['regex'])
                                                    break
                                                endif
   14              0.000008                 endfor
   14              0.000001             endfor
    1              0.000001         endif
    1              0.000000     endfor
                            
    1              0.000001     return includes

FUNCTION  syntastic#util#fname2buf()
Called 3 times
Total time:   0.000134
 Self time:   0.000134

count  total (s)   self (s)
    3              0.000007     if exists('+shellslash')
                                    " bufnr() can't cope with backslashes
                                    let old_shellslash = &shellslash
                                    let &shellslash = 1
                                endif
                            
                                " this is a best-effort attempt to escape file patterns (cf. :h file-pattern)
                                " XXX it fails for filenames containing something like \{2,3}
    3              0.000003     let buf = -1
    3              0.000006     for md in [':~:.', ':~', ':p']
    3              0.000003         try
                                        " Older versions of Vim can throw E94 here
    3              0.000061             let buf = bufnr('^' . escape(fnamemodify(a:fname, md), '\*?,{}[') . '$')
    3              0.000003         catch
                                        " catch everything
                                    endtry
    3              0.000004         if buf != -1
    3              0.000002             break
                                    endif
                                endfor
    3              0.000002     if buf == -1
                                    " XXX definitely wrong, but hope is the last thing to die :)
                                    let buf = bufnr(fnamemodify(a:fname, ':p'))
                                endif
                            
    3              0.000003     if exists('+shellslash')
                                    let &shellslash = old_shellslash
                                endif
                            
    3              0.000003     return buf

FUNCTION  244()
Called 2 times
Total time:   0.003046
 Self time:   0.000240

count  total (s)   self (s)
    2   0.000877   0.000019     if a:path.equals(self.path)
                                    return self
                                endif
    2   0.000815   0.000041     if stridx(a:path.str(), self.path.str(), 0) ==# -1
    1              0.000003         return {}
                                endif
                            
    1              0.000004     if self.path.isDirectory
    2              0.000012         for i in self.children
    2   0.000483   0.000027             let retVal = i.findNode(a:path)
    2              0.000009             if retVal != {}
    1              0.000003                 return retVal
                                        endif
    1              0.000003         endfor
                                endif
                                return {}

FUNCTION  <SNR>34__os_name()
Called 2 times
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    2              0.000002     return g:_SYNTASTIC_UNAME

FUNCTION  airline#extensions#wordcount#apply()
Called 6 times
Total time:   0.000127
 Self time:   0.000127

count  total (s)   self (s)
    6              0.000112   if match(&ft, get(g:, 'airline#extensions#wordcount#filetypes')) > -1
                                call airline#extensions#prepend_to_section('z', '%{get(b:, "airline_wordcount", "")}')
                              endif

FUNCTION  gitgutter#utility#has_unsaved_changes()
Called 1 time
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    1              0.000007   return getbufvar(s:bufnr, "&mod")

FUNCTION  <SNR>81_hl_group_exists()
Called 170 times
Total time:   0.001243
 Self time:   0.001243

count  total (s)   self (s)
  170              0.000340   if !hlexists(a:group)
                                return 0
                              elseif empty(synIDattr(hlID(a:group), 'fg'))
    4              0.000004     return 0
                              endif
  166              0.000096   return 1

FUNCTION  syntastic#c#ReadConfig()
Called 1 time
Total time:   0.000096
 Self time:   0.000025

count  total (s)   self (s)
    1   0.000010   0.000004     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, 'ReadConfig: looking for', a:file)
                            
                                " search upwards from the current file's directory
    1   0.000074   0.000014     let config = syntastic#util#findFileInParent(a:file, expand('%:p:h', 1))
    1              0.000001     if config ==# ''
    1   0.000009   0.000004         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, 'ReadConfig: file not found')
    1              0.000001         return ''
                                endif
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, 'ReadConfig: config file:', config)
                                if !filereadable(config)
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, 'ReadConfig: file unreadable')
                                    return ''
                                endif
                            
                                " convert filename into absolute path
                                let filepath = fnamemodify(config, ':p:h')
                            
                                " try to read config file
                                try
                                    let lines = readfile(config)
                                catch /\m^Vim\%((\a\+)\)\=:E48[45]/
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, 'ReadConfig: error reading file')
                                    return ''
                                endtry
                            
                                " filter out empty lines and comments
                                call filter(lines, 'v:val !~# ''\v^(\s*#|$)''')
                            
                                " remove leading and trailing spaces
                                call map(lines, 'substitute(v:val, ''\m^\s\+'', "", "")')
                                call map(lines, 'substitute(v:val, ''\m\s\+$'', "", "")')
                            
                                let parameters = []
                                for line in lines
                                    let matches = matchstr(line, '\m\C^\s*-I\s*\zs.\+')
                                    if matches !=# ''
                                        " this one looks like an absolute path
                                        if match(matches, '\m^\%(/\|\a:\)') != -1
                                            call add(parameters, '-I' . matches)
                                        else
                                            call add(parameters, '-I' . filepath . syntastic#util#Slash() . matches)
                                        endif
                                    else
                                        call add(parameters, line)
                                    endif
                                endfor
                            
                                return join(map(parameters, 'syntastic#util#shescape(v:val)'))

FUNCTION  <SNR>34_CacheErrors()
Called 1 time
Total time:   2.136236
 Self time:   0.000185

count  total (s)   self (s)
    1   0.000011   0.000006     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: ' . (len(a:checker_names) ? join(a:checker_names) : 'default checkers'))
    1   0.000285   0.000007     call s:ClearCache(a:buf)
    1   0.000025   0.000003     let newLoclist = g:SyntasticLoclist.New([])
    1   0.000006   0.000002     call newLoclist.setOwner(a:buf)
                            
    1   0.000057   0.000002     if !s:_skip_file(a:buf)
                                    " debug logging {{{3
    1   0.000008   0.000003         call syntastic#log#debugShowVariables(g:_SYNTASTIC_DEBUG_TRACE, 'aggregate_errors')
    1   0.000014   0.000009         if syntastic#util#isRunningWindows()
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$TMP = ' . string($TMP) . ', $TEMP = ' . string($TEMP))
                                    else
    1   0.000009   0.000005             call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$TERM = ' . string($TERM))
    1   0.000007   0.000003             call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$TMPDIR = ' . string($TMPDIR))
    1              0.000001         endif
    1   0.000009   0.000005         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$PATH = ' . string($PATH))
    1   0.000008   0.000004         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getcwd() = ' . string(getcwd()))
                                    " }}}3
                            
    1   0.009727   0.000010         let clist = s:registry.getCheckers(getbufvar(a:buf, '&filetype'), a:checker_names)
                            
    1   0.000048   0.000015         let aggregate_errors = syntastic#util#var('aggregate_errors') || len(syntastic#util#unique(map(copy(clist), 'v:val.getFiletype()'))) > 1
    1              0.000002         let decorate_errors = aggregate_errors && syntastic#util#var('id_checkers')
    1              0.000002         let sort_aggregated_errors = aggregate_errors && syntastic#util#var('sort_aggregated_errors')
                            
    1              0.000000         let names = []
    1              0.000001         let unavailable_checkers = 0
    2              0.000002         for checker in clist
    1   0.000005   0.000003             let cname = checker.getCName()
    1   0.000105   0.000002             if !checker.isAvailable()
                                            call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: Checker ' . cname . ' is not available')
                                            let unavailable_checkers += 1
                                            continue
                                        endif
                            
    1   0.000008   0.000003             call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: Invoking checker: ' . cname)
                            
    1   2.125743   0.000006             let loclist = checker.getLocList()
                            
    1   0.000005   0.000003             if !loclist.isEmpty()
                                            if decorate_errors
                                                call loclist.decorate(cname)
                                            endif
                                            call add(names, cname)
                                            if checker.wantSort() && !sort_aggregated_errors
                                                call loclist.sort()
                                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'sorted:', loclist)
                                            endif
                            
                                            call newLoclist.extend(loclist)
                            
                                            if !aggregate_errors
                                                break
                                            endif
                                        endif
    1              0.000001         endfor
                            
                                    " set names {{{3
    1              0.000001         if !empty(names)
                                        if len(syntastic#util#unique(map( copy(names), 'substitute(v:val, "\\m/.*", "", "")' ))) == 1
                                            let type = substitute(names[0], '\m/.*', '', '')
                                            let name = join(map( names, 'substitute(v:val, "\\m.\\{-}/", "", "")' ), ', ')
                                            call newLoclist.setName( name . ' ('. type . ')' )
                                        else
                                            " checkers from mixed types
                                            call newLoclist.setName(join(names, ', '))
                                        endif
                                    endif
                                    " }}}3
                            
                                    " issue warning about no active checkers {{{3
    1              0.000002         if len(clist) == unavailable_checkers
                                        if !empty(a:checker_names)
                                            if len(a:checker_names) == 1
                                                call syntastic#log#warn('checker ' . a:checker_names[0] . ' is not available')
                                            else
                                                call syntastic#log#warn('checkers ' . join(a:checker_names, ', ') . ' are not available')
                                            endif
                                        else
                                            call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: no checkers available for ' . &filetype)
                                        endif
                                    endif
                                    " }}}3
                            
    1   0.000009   0.000004         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'aggregated:', newLoclist)
    1              0.000001         if sort_aggregated_errors
                                        call newLoclist.sort()
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'sorted:', newLoclist)
                                    endif
    1              0.000001     endif
                            
    1   0.000061   0.000004     call newLoclist.deploy()

FUNCTION  <SNR>85_get_transitioned_seperator()
Called 46 times
Total time:   0.027857
 Self time:   0.001164

count  total (s)   self (s)
   46              0.000036   let line = ''
   46   0.013533   0.000168   call airline#highlighter#add_separator(a:prev_group, a:group, a:side)
   46              0.000147   if get(a:self._context, 'tabline', 0) && get(g:, 'airline#extensions#tabline#alt_sep', 0) && a:group ==# 'airline_tabsel' && a:side
                                call airline#highlighter#add_separator(a:prev_group, a:group, 0)
                                let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
                                let line .=  a:self._context.right_sep.'%#'.a:group.'#'
                              else
   46   0.013510   0.000182     call airline#highlighter#add_separator(a:prev_group, a:group, a:side)
   46              0.000125     let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
   46              0.000113     let line .= a:side ? a:self._context.left_sep : a:self._context.right_sep
   46              0.000070     let line .= '%#'.a:group.'#'
   46              0.000020   endif
   46              0.000036   return line

FUNCTION  SyntasticMake()
Called 1 time
Total time:   2.123997
 Self time:   0.000245

count  total (s)   self (s)
    1   0.000010   0.000004     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'SyntasticMake: called with options:', a:options)
                            
                                " save options and locale env variables {{{3
    1              0.000001     let old_local_errorformat = &l:errorformat
    1              0.000001     let old_errorformat = &errorformat
    1              0.000003     let old_cwd = getcwd()
                                " }}}3
                            
    1              0.000002     if has_key(a:options, 'errorformat')
    1              0.000006         let &errorformat = a:options['errorformat']
    1              0.000002         set errorformat<
    1              0.000000     endif
                            
    1              0.000001     if has_key(a:options, 'cwd')
                                    execute 'lcd ' . fnameescape(a:options['cwd'])
                                endif
                            
                                " set environment variables {{{3
    1              0.000001     let env_save = {}
    1              0.000002     if has_key(a:options, 'env') && len(a:options['env'])
                                    for key in keys(a:options['env'])
                                        if key =~? '\m^[a-z_][a-z0-9_]*$'
                                            execute 'let env_save[' . string(key) . '] = $' . key
                                            execute 'let $' . key . ' = ' . string(a:options['env'][key])
                                        endif
                                    endfor
                                endif
                                " }}}3
                            
    1   2.123733   0.000013     let err_lines = split(syntastic#util#system(a:options['makeprg']), "\n", 1)
                            
                                " restore environment variables {{{3
    1              0.000002     if len(env_save)
                                    for key in keys(env_save)
                                        execute 'let $' . key . ' = ' . string(env_save[key])
                                    endfor
                                endif
                                " }}}3
                            
    1   0.000010   0.000004     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'checker output:', err_lines)
                            
                                " Does it still make sense to go on?
    1   0.000018   0.000006     let bailout = syntastic#util#var('exit_checks') && has_key(a:options, 'returns') && index(a:options['returns'], v:shell_error) == -1
                            
    1              0.000000     if !bailout
    1              0.000001         if has_key(a:options, 'Preprocess')
                                        let err_lines = call(a:options['Preprocess'], [err_lines])
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'preprocess (external):', err_lines)
                                    elseif has_key(a:options, 'preprocess')
                                        let err_lines = call('syntastic#preprocess#' . a:options['preprocess'], [err_lines])
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'preprocess:', err_lines)
                                    endif
    1              0.000056         noautocmd lgetexpr err_lines
                            
    1              0.000007         let errors = deepcopy(getloclist(0))
                            
    1              0.000002         if has_key(a:options, 'cwd')
                                        execute 'lcd ' . fnameescape(old_cwd)
                                    endif
                            
    1              0.000001         try
    1              0.000011             silent lolder
                                    catch /\m^Vim\%((\a\+)\)\=:E380/
                                        " E380: At bottom of quickfix stack
    1              0.000004             call setloclist(0, [], 'r')
    1              0.000000             try
                                            " Vim 7.4.2200 or later
    1              0.000003                 call setloclist(0, [], 'r', { 'title': '' })
    1              0.000001             catch /\m^Vim\%((\a\+)\)\=:E\%(118\|731\)/
                                            " do nothing
                                        endtry
    1              0.000001         catch /\m^Vim\%((\a\+)\)\=:E776/
                                        " E776: No location list
                                        " do nothing
                                    endtry
    1              0.000000     else
                                    let errors = []
                                endif
                            
                                " restore options {{{3
    1              0.000006     let &errorformat = old_errorformat
    1              0.000002     let &l:errorformat = old_local_errorformat
                                " }}}3
                            
    1   0.000018   0.000016     if !s:_running_windows && (s:_os_name() =~? 'FreeBSD' || s:_os_name() =~? 'OpenBSD')
                                    call syntastic#util#redraw(g:syntastic_full_redraws)
                                endif
                            
    1              0.000001     if bailout
                                    call syntastic#log#ndebug(g:_SYNTASTIC_DEBUG_LOCLIST, 'checker output:', err_lines)
                                    throw 'Syntastic: checker error'
                                endif
                            
    1   0.000009   0.000003     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'raw loclist:', errors)
                            
    1              0.000002     if has_key(a:options, 'defaults')
                                    call s:_add_to_errors(errors, a:options['defaults'])
                                endif
                            
                                " Add subtype info if present.
    1              0.000002     if has_key(a:options, 'subtype')
                                    call s:_add_to_errors(errors, { 'subtype': a:options['subtype'] })
                                endif
                            
    1              0.000002     if has_key(a:options, 'Postprocess') && !empty(a:options['Postprocess'])
                                    for rule in a:options['Postprocess']
                                        let errors = call(rule, [errors])
                                    endfor
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'postprocess (external):', errors)
                                elseif has_key(a:options, 'postprocess') && !empty(a:options['postprocess'])
                                    for rule in a:options['postprocess']
                                        let errors = call('syntastic#postprocess#' . rule, [errors])
                                    endfor
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'postprocess:', errors)
                                endif
                            
    1              0.000002     return errors

FUNCTION  airline#statusline()
Called 8 times
Total time:   0.000282
 Self time:   0.000282

count  total (s)   self (s)
    8              0.000134   if has_key(s:contexts, a:winnr)
    8              0.000118     return '%{airline#check_mode('.a:winnr.')}'.s:contexts[a:winnr].line
                              endif
                            
                              " in rare circumstances this happens...see #276
                              return ''

FUNCTION  gitgutter#hunk#reset()
Called 1 time
Total time:   0.000158
 Self time:   0.000065

count  total (s)   self (s)
    1   0.000087   0.000044   call gitgutter#utility#setbufvar(gitgutter#utility#bufnr(), 'hunks', [])
    1   0.000070   0.000020   call s:reset_summary()

FUNCTION  gitgutter#utility#exists_file()
Called 2 times
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    2              0.000015   return filereadable(s:file)

FUNCTION  syntastic#util#unique()
Called 6 times
Total time:   0.000143
 Self time:   0.000143

count  total (s)   self (s)
    6              0.000008     let seen = {}
    6              0.000006     let uniques = []
   17              0.000013     for e in a:list
   11              0.000020         let k = string(e)
   11              0.000018         if !has_key(seen, k)
   11              0.000013             let seen[k] = 1
   11              0.000017             call add(uniques, e)
   11              0.000004         endif
   11              0.000006     endfor
    6              0.000003     return uniques

FUNCTION  gitgutter#utility#is_active()
Called 3 times
Total time:   0.000163
 Self time:   0.000064

count  total (s)   self (s)
    3   0.000161   0.000062   return g:gitgutter_enabled && !pumvisible() && gitgutter#utility#is_file_buffer() && gitgutter#utility#exists_file() && gitgutter#utility#not_git_dir()

FUNCTION  airline#extensions#apply()
Called 12 times
Total time:   0.001605
 Self time:   0.000557

count  total (s)   self (s)
   12              0.000030   let s:active_winnr = winnr()
                            
   12   0.000620   0.000072   if s:is_excluded_window()
                                return -1
                              endif
                            
   12              0.000018   if &buftype == 'help'
                                call airline#extensions#apply_left_override('Help', '%f')
                                let w:airline_section_x = ''
                                let w:airline_section_y = ''
                                let w:airline_render_right = 1
                              endif
                            
   12              0.000012   if &previewwindow
                                let w:airline_section_a = 'Preview'
                                let w:airline_section_b = ''
                                let w:airline_section_c = bufname(winbufnr(winnr()))
                              endif
                            
   12              0.000085   if has_key(s:filetype_overrides, &ft)
    4              0.000018     let args = s:filetype_overrides[&ft]
    4   0.000526   0.000026     call airline#extensions#apply_left_override(args[0], args[1])
    4              0.000003   endif
                            
   12              0.000037   for item in items(s:filetype_regex_overrides)
                                if match(&ft, item[0]) >= 0
                                  call airline#extensions#apply_left_override(item[1][0], item[1][1])
                                endif
                              endfor

FUNCTION  gitgutter#utility#save_last_seen_change()
Called 1 time
Total time:   0.000011
 Self time:   0.000005

count  total (s)   self (s)
    1   0.000010   0.000004   call gitgutter#utility#setbufvar(s:bufnr, 'last_tick', getbufvar(s:bufnr, 'changedtick'))

FUNCTION  <SNR>81_Get()
Called 336 times
Total time:   0.001178
 Self time:   0.001178

count  total (s)   self (s)
  336              0.000483   let res=get(a:dict, a:key, '')
  336              0.000225   if res is ''
  163              0.000078     return ''
                              else
  173              0.000167     return a:prefix. res
                              endif

FUNCTION  syntastic#util#setLastTick()
Called 2 times
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    2              0.000007     call setbufvar(a:buf, 'syntastic_lasttick', getbufvar(a:buf, 'changedtick'))

FUNCTION  airline#highlighter#get_highlight()
Called 514 times
Total time:   0.034475
 Self time:   0.014884

count  total (s)   self (s)
  514              0.001251   if get(g:, 'airline_highlighting_cache', 0) && has_key(s:hl_groups, a:group)
                                return s:hl_groups[a:group]
                              else
  514   0.010404   0.001465     let fg = s:get_syn(a:group, 'fg')
  514   0.009165   0.001106     let bg = s:get_syn(a:group, 'bg')
  514              0.003718     let reverse = g:airline_gui_mode ==# 'gui' ? synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'gui') : synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'cterm')|| synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'term')
  514              0.001379     let bold = synIDattr(synIDtrans(hlID(a:group)), 'bold')
  514              0.000453     let opts = a:000
  514              0.000327     if bold
   17              0.000019       let opts = ['bold']
   17              0.000005     endif
  514   0.004552   0.001959     let res = reverse ? s:get_array(bg, fg, opts) : s:get_array(fg, bg, opts)
  514              0.000228   endif
  514              0.000887   let s:hl_groups[a:group] = res
  514              0.000325   return res

FUNCTION  SyntaxCheckers_cpp_gcc_GetLocList()
Called 1 time
Total time:   2.125532
 Self time:   0.000079

count  total (s)   self (s)
    1   2.125531   0.000078     return syntastic#c#GetLocList('cpp', 'gcc', { 'errorformat':     '%-G%f:%s:,' .     '%f:%l:%c: %trror: %m,' .     '%f:%l:%c: %tarning: %m,' .     '%f:%l:%c: %m,'.     '%f:%l: %trror: %m,'.     '%f:%l: %tarning: %m,'.     '%f:%l: %m', 'main_flags': '-x c++ -fsyntax-only', 'header_flags': '-x c++', 'header_names': '\m\.\(h\|hpp\|hh\)$' })

FUNCTION  airline#util#shorten()
Called 4 times
Total time:   0.000039
 Self time:   0.000039

count  total (s)   self (s)
    4              0.000010   if winwidth(0) < a:winwidth && len(split(a:text, '\zs')) > a:minwidth
                                if get(a:000, 0, 0)
                                  " shorten from tail
                                  return ''.matchstr(a:text, '.\{'.a:minwidth.'}$')
                                else
                                  " shorten from beginning of string
                                  return matchstr(a:text, '^.\{'.a:minwidth.'}').''
                                endif
                              else
    4              0.000003     return a:text
                              endif

FUNCTION  273()
Called 2 times
Total time:   0.000037
 Self time:   0.000033

count  total (s)   self (s)
    2              0.000005     if self._keepopen
                                    return
                                endif
                            
    2              0.000010     if (a:newtab && self._where == 't') || !a:newtab
    1   0.000008   0.000004         call g:NERDTree.CloseIfQuitOnOpen()
    1              0.000000     endif

FUNCTION  275()
Called 1 time
Total time:   0.040716
 Self time:   0.000126

count  total (s)   self (s)
    1   0.000040   0.000029     if b:NERDTree.isWinTree()
                                    if self._where == 'v'
                                        vsplit
                                    elseif self._where == 'h'
                                        split
                                    elseif self._where == 't'
                                        tabnew
                                    endif
                                else
    1   0.000045   0.000020         call self._checkToCloseTree(1)
                            
    1              0.000003         if self._where == 'v'
                                        call self._newVSplit()
                                    elseif self._where == 'h'
                                        call self._newSplit()
                                    elseif self._where == 't'
                                        tabnew
                                    elseif self._where == 'p'
    1   0.040557   0.000015             call self._previousWindow()
    1              0.000001         endif
                            
    1   0.000017   0.000005         call self._checkToCloseTree(0)
    1              0.000000     endif

FUNCTION  276()
Called 2 times
Total time:   0.031472
 Self time:   0.000094

count  total (s)   self (s)
                                "gotta split if theres only one window (i.e. the NERD tree)
    2              0.000007     if winnr("$") ==# 1
                                    return 0
                                endif
                            
    2              0.000007     let oldwinnr = winnr()
    2   0.020199   0.000028     call nerdtree#exec(a:winnumber . "wincmd p")
    2              0.000010     let specialWindow = getbufvar("%", '&buftype') != '' || getwinvar('%', '&previewwindow')
    2              0.000004     let modified = &modified
    2   0.011217   0.000010     call nerdtree#exec(oldwinnr . "wincmd p")
                            
                                "if its a special window e.g. quickfix or another explorer plugin then we
                                "have to split
    2              0.000003     if specialWindow
                                    return 0
                                endif
                            
    2              0.000002     if &hidden
                                    return 1
                                endif
                            
    2              0.000006     return !modified || self._bufInWindows(winbufnr(a:winnumber)) >= 2

FUNCTION  277()
Called 1 time
Total time:   0.000131
 Self time:   0.000097

count  total (s)   self (s)
    1              0.000025     let l:newOpener = copy(self)
                            
    1   0.000023   0.000012     let l:newOpener._keepopen = nerdtree#has_opt(a:opts, 'keepopen')
    1              0.000006     let l:newOpener._nerdtree = b:NERDTree
    1              0.000005     let l:newOpener._path = a:path
    1              0.000010     let l:newOpener._reuse = has_key(a:opts, 'reuse') ? a:opts['reuse'] : ''
    1   0.000016   0.000008     let l:newOpener._stay = nerdtree#has_opt(a:opts, 'stay')
    1              0.000008     let l:newOpener._where = has_key(a:opts, 'where') ? a:opts['where'] : ''
                            
    1   0.000026   0.000011     call l:newOpener._saveCursorPos()
                            
    1              0.000004     return l:newOpener

FUNCTION  airline#highlighter#highlight_modified_inactive()
Called 2 times
Total time:   0.000321
 Self time:   0.000041

count  total (s)   self (s)
    2              0.000006   if getbufvar(a:bufnr, '&modified')
                                let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c : []
                              else
    2              0.000014     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive.airline_c : []
    2              0.000000   endif
                            
    2              0.000002   if !empty(colors)
    2   0.000290   0.000010     call airline#highlighter#exec('airline_c'.(a:bufnr).'_inactive', colors)
    2              0.000001   endif

FUNCTION  <SNR>77_wordcount_update()
Called 4 times
Total time:   0.000507
 Self time:   0.000507

count  total (s)   self (s)
    4              0.000030   if empty(bufname(''))
                                return
                              endif
    4              0.000282   if match(&ft, get(g:, 'airline#extensions#wordcount#filetypes')) > -1
                                let l:mode = mode()
                                if l:mode ==# 'v' || l:mode ==# 'V' || l:mode ==# 's' || l:mode ==# 'S'
                                  let b:airline_wordcount = airline#extensions#wordcount#formatters#{s:formatter}#format()
                                  let b:airline_change_tick = b:changedtick
                                else
                                  if get(b:, 'airline_wordcount_cache', '') is# '' || b:airline_wordcount_cache isnot# get(b:, 'airline_wordcount', '') || get(b:, 'airline_change_tick', 0) != b:changedtick ||  get(b:, 'airline_winwidth', 0) != winwidth(0)
                                    " cache data
                                    let b:airline_wordcount = airline#extensions#wordcount#formatters#{s:formatter}#format()
                                    let b:airline_wordcount_cache = b:airline_wordcount
                                    let b:airline_change_tick = b:changedtick
                                    let b:airline_winwidth = winwidth(0)
                                  endif
                                endif
                              endif

FUNCTION  airline#extensions#keymap#status()
Called 2 times
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    2              0.000007   if (get(g:, 'airline#extensions#keymap#enabled', 1) && has('keymap'))
    2              0.000007     return printf('%s', (!empty(&keymap) ? (g:airline_symbols.keymap . ' '. &keymap) : ''))
                              else
                                return ''
                              endif

FUNCTION  280()
Called 1 time
Total time:   2.200138
 Self time:   0.000027

count  total (s)   self (s)
                            
    1              0.000004     if self._path.isDirectory
                                    call self._openDirectory(a:target)
                                    return
                                endif
                            
    1   2.200120   0.000009     call self._openFile()

FUNCTION  281()
Called 1 time
Total time:   2.200111
 Self time:   0.000065

count  total (s)   self (s)
                            
    1   0.001147   0.000015     if self._reuseWindow()
                                    return
                                endif
                            
    1   0.040740   0.000024     call self._gotoTargetWin()
                            
    1              0.000001     if self._stay
                                    silent call self._path.edit()
                                    call self._restoreCursorPos()
                                    return
                                endif
                            
    1   2.158211   0.000013     call self._path.edit()

FUNCTION  283()
Called 1 time
Total time:   0.040542
 Self time:   0.000039

count  total (s)   self (s)
    1   0.016812   0.000016     if !self._isWindowUsable(winnr("#")) && self._firstUsableWindow() ==# -1
                                    call self._newSplit()
                                else
    1              0.000001         try
    1   0.014680   0.000004             if !self._isWindowUsable(winnr("#"))
                                            call nerdtree#exec(self._firstUsableWindow() . "wincmd w")
                                        else
    1   0.009035   0.000004                 call nerdtree#exec('wincmd p')
    1              0.000001             endif
    1              0.000001         catch /^Vim\%((\a\+)\)\=:E37/
                                        call g:NERDTree.CursorToTreeWin()
                                        throw "NERDTree.FileAlreadyOpenAndModifiedError: ". self._path.str() ." is already open and modified."
                                    catch /^Vim\%((\a\+)\)\=:/
                                        echo v:exception
                                    endtry
    1              0.000000     endif

FUNCTION  54()
Called 2 times
Total time:   0.000058
 Self time:   0.000017

count  total (s)   self (s)
    2   0.000058   0.000017     return syntastic#util#unique(map(copy(self._rawLoclist), 'str2nr(v:val["bufnr"])') + [self._owner])

FUNCTION  286()
Called 1 time
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    1              0.000008     let self._bufnr = bufnr("")
    1              0.000007     let self._tabnr = tabpagenr()

FUNCTION  SyntaxCheckers_cpp_gcc_IsAvailable()
Called 1 time
Total time:   0.000054
 Self time:   0.000030

count  total (s)   self (s)
    1              0.000002     if !exists('g:syntastic_cpp_compiler')
    1   0.000017   0.000015         let g:syntastic_cpp_compiler = executable(self.getExec()) ? self.getExec() : 'clang++'
    1              0.000001     endif
    1   0.000025   0.000003     call self.log('g:syntastic_cpp_compiler =', g:syntastic_cpp_compiler)
    1              0.000009     return executable(expand(g:syntastic_cpp_compiler, 1))

FUNCTION  nerdtree#ui_glue#invokeKeyMap()
Called 1 time
Total time:   2.205308
 Self time:   0.000048

count  total (s)   self (s)
    1   2.205303   0.000043     call g:NERDTreeKeyMap.Invoke(a:key)

FUNCTION  syntastic#util#shexpand()
Called 2 times
Total time:   0.000027
 Self time:   0.000011

count  total (s)   self (s)
    2   0.000027   0.000011     return syntastic#util#shescape(a:0 ? expand(a:string, a:1) : expand(a:string, 1))

FUNCTION  airline#extensions#hunks#get_hunks()
Called 2 times
Total time:   0.000204
 Self time:   0.000106

count  total (s)   self (s)
    2              0.000004   if !get(w:, 'airline_active', 0)
                                return ''
                              endif
                              " Cache values, so that it isn't called too often
    2              0.000015   if exists("b:airline_hunks") && get(b:,  'airline_changenr', 0) == b:changedtick && winwidth(0) == get(s:, 'airline_winwidth', 0) && get(b:, 'source_func', '') isnot# 's:get_hunks_signify' && get(b:, 'source_func', '') isnot# 's:get_hunks_gitgutter' && get(b:, 'source_func', '') isnot# 's:get_hunks_empty' && get(b:, 'source_func', '') isnot# 's:get_hunks_changes'
                                return b:airline_hunks
                              endif
    2   0.000106   0.000008   let hunks = s:get_hunks()
    2              0.000002   let string = ''
    2              0.000003   if !empty(hunks)
    8              0.000007     for i in [0, 1, 2]
    6              0.000012       if (s:non_zero_only == 0 && winwidth(0) > 100) || hunks[i] > 0
    6              0.000022         let string .= printf('%s%s ', s:hunk_symbols[i], hunks[i])
    6              0.000002       endif
    6              0.000003     endfor
    2              0.000002   endif
    2              0.000002   let b:airline_hunks = string
    2              0.000004   let b:airline_changenr = b:changedtick
    2              0.000002   let s:airline_winwidth = winwidth(0)
    2              0.000002   return string

FUNCTION  <SNR>80_create()
Called 4 times
Total time:   0.000440
 Self time:   0.000386

count  total (s)   self (s)
    4              0.000004   let _ = ''
    8              0.000014   for idx in range(len(a:parts))
    4   0.000026   0.000016     let part = airline#parts#get(a:parts[idx])
    4              0.000004     let val = ''
    4              0.000008     let add_sep = get(l:, 'add_sep', 0)
                            
    4              0.000008     if exists('part.function')
    4              0.000007       let func = (part.function).'()'
    4              0.000004     elseif exists('part.text')
                                  let func = '"'.(part.text).'"'
                                else
                                  if a:append > 0 && idx != 0
                                    let val .= s:spc.g:airline_left_alt_sep.s:spc
                                  endif
                                  if a:append < 0 && idx != 0
                                    let t = ''
                                    if !add_sep
                                      let t = s:spc.g:airline_right_alt_sep.s:spc
                                    endif
                                    let val = t.val
                                  endif
                                  if exists('part.raw')
                                    let _ .= s:wrap_accent(part, val.(part.raw))
                                    continue
                                  else
                                    let _ .= s:wrap_accent(part, val.a:parts[idx])
                                    continue
                                  endif
                                endif
                            
    4              0.000006     let minwidth = get(part, 'minwidth', 0)
                            
    4              0.000004     if a:append > 0 && idx != 0
                                  let partval = printf('%%{airline#util#append(%s,%s)}', func, minwidth)
                                  " will add an extra separator, if minwidth is zero
                                  let add_sep = (minwidth == 0)
                                elseif a:append < 0 && idx != len(a:parts) - 1
                                  let partval = printf('%%{airline#util#prepend(%s,%s)}', func, minwidth)
                                  " will add an extra separator, if minwidth is zero
                                  let add_sep = (minwidth == 0)
                                else
    4              0.000014       let partval = printf('%%{airline#util#wrap(%s,%s)}', func, minwidth)
    4              0.000004       let add_sep = 0
    4              0.000001     endif
                            
    4              0.000008     if exists('part.condition')
                                  let partval = substitute(partval, '{', '\="{".(part.condition)." ? "', '')
                                  let partval = substitute(partval, '}', ' : ""}', '')
                                endif
                            
    4   0.000061   0.000017     let val .= s:wrap_accent(part, partval)
    4              0.000004     let _ .= val
    4              0.000003   endfor
    4              0.000004   return _

FUNCTION  gitgutter#utility#getbufvar()
Called 9 times
Total time:   0.000061
 Self time:   0.000061

count  total (s)   self (s)
    9              0.000026   let dict = get(getbufvar(a:buffer, ''), 'gitgutter', {})
    9              0.000015   if has_key(dict, a:varname)
    8              0.000010     return dict[a:varname]
                              else
    1              0.000001     if a:0
    1              0.000001       return a:1
                                endif
                              endif

FUNCTION  <SNR>73_get_hunks()
Called 2 times
Total time:   0.000098
 Self time:   0.000038

count  total (s)   self (s)
    2              0.000004   if !exists('b:source_func') || get(b:, 'source_func', '') is# 's:get_hunks_empty'
    1              0.000002     if get(g:, 'loaded_signify') && sy#buffer_is_active()
                                  let b:source_func = 's:get_hunks_signify'
                                elseif exists('*GitGutterGetHunkSummary')
    1              0.000001       let b:source_func = 's:get_hunks_gitgutter'
    1              0.000001     elseif exists('*changes#GetStats')
                                  let b:source_func = 's:get_hunks_changes'
                                elseif exists('*quickfixsigns#vcsdiff#GetHunkSummary')
                                  let b:source_func = 'quickfixsigns#vcsdiff#GetHunkSummary'
                                else
                                  let b:source_func = 's:get_hunks_empty'
                                endif
    1              0.000000   endif
    2   0.000072   0.000012   return {b:source_func}()

FUNCTION  SyntasticStatuslineFlag()
Called 4 times
Total time:   0.000251
 Self time:   0.000021

count  total (s)   self (s)
    4   0.000251   0.000021     return g:SyntasticLoclist.current().getStatuslineFlag()

FUNCTION  airline#extensions#syntastic#get_warning()
Called 2 times
Total time:   0.000180
 Self time:   0.000010

count  total (s)   self (s)
    2   0.000179   0.000009   return airline#extensions#syntastic#get('warning')

FUNCTION  <SNR>34_BufReadPostHook()
Called 1 time
Total time:   0.000076
 Self time:   0.000023

count  total (s)   self (s)
    1   0.000049   0.000007     let buf = syntastic#util#fname2buf(a:fname)
    1              0.000001     if g:syntastic_check_on_open && buf > 0
    1   0.000021   0.000010         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS, 'autocmd: BufReadPost, buffer ' . buf . ' = ' . string(a:fname))
    1              0.000002         if index(s:_check_stack, buf) == -1
    1              0.000002             call add(s:_check_stack, buf)
    1              0.000000         endif
    1              0.000001     endif

FUNCTION  <SNR>34_BufWinEnterHook()
Called 1 time
Total time:   0.000078
 Self time:   0.000029

count  total (s)   self (s)
    1   0.000048   0.000005     let buf = syntastic#util#fname2buf(a:fname)
    1   0.000014   0.000008     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS, 'autocmd: BufWinEnter, buffer ' . buf . ' = ' . string(a:fname) . ', &buftype = ' . string(&buftype))
    1              0.000003     if buf > 0 && getbufvar(buf, '&buftype') ==# ''
    1              0.000005         let idx = index(reverse(copy(s:_check_stack)), buf)
    1              0.000002         if idx >= 0 && !has('vim_starting')
                                        call remove(s:_check_stack, -idx - 1)
                                        call s:UpdateErrors(buf, 1, [])
                                    endif
    1              0.000000     endif

FUNCTION  <SNR>15_on_window_changed()
Called 8 times
Total time:   0.049514
 Self time:   0.000326

count  total (s)   self (s)
    8              0.000026   if pumvisible() && (!&previewwindow || g:airline_exclude_preview)
                                return
                              endif
                              " Handle each window only once, since we might come here several times for
                              " different autocommands.
    8              0.000109   let l:key = [bufnr('%'), winnr(), winnr('$'), tabpagenr(), &ft]
    8              0.000065   if get(g:, 'airline_last_window_changed', []) == l:key && &stl is# '%!airline#statusline('.winnr().')' && &ft !~? 'gitcommit'
                                " fugitive is special, it changes names and filetypes several times,
                                " make sure the caching does not get into its way
    2              0.000002     return
                              endif
    6              0.000014   let g:airline_last_window_changed = l:key
    6   0.000051   0.000033   call s:init()
    6   0.049202   0.000032   call airline#update_statusline()

FUNCTION  <SNR>70_invoke_funcrefs()
Called 12 times
Total time:   0.048675
 Self time:   0.000384

count  total (s)   self (s)
   12   0.000302   0.000067   let builder = airline#builder#new(a:context)
   12   0.006731   0.000118   let err = airline#util#exec_funcrefs(a:funcrefs + s:core_funcrefs, builder, a:context)
   12              0.000011   if err == 1
   12   0.041500   0.000057     let a:context.line = builder.build()
   12              0.000040     let s:contexts[a:context.winnr] = a:context
   12              0.000079     call setwinvar(a:context.winnr, '&statusline', '%!airline#statusline('.a:context.winnr.')')
   12              0.000003   endif

FUNCTION  gitgutter#handle_diff()
Called 1 time
Total time:   0.000680
 Self time:   0.000144

count  total (s)   self (s)
    1   0.000156   0.000047   call gitgutter#debug#log(a:diff)
                            
    1   0.000017   0.000007   call gitgutter#utility#setbufvar(gitgutter#utility#bufnr(), 'tracked', 1)
                            
    1   0.000082   0.000015   call gitgutter#hunk#set_hunks(gitgutter#diff#parse_diff(a:diff))
    1   0.000029   0.000010   let modified_lines = gitgutter#diff#process_hunks(gitgutter#hunk#hunks())
                            
    1              0.000002   if len(modified_lines) > g:gitgutter_max_signs
                                call gitgutter#utility#warn_once('exceeded maximum number of signs (configured by g:gitgutter_max_signs).', 'max_signs')
                                call gitgutter#sign#clear_signs()
                                return
                              endif
                            
    1              0.000002   if g:gitgutter_signs || g:gitgutter_highlight_lines
    1   0.000369   0.000049     call gitgutter#sign#update_signs(modified_lines)
    1              0.000001   endif
                            
    1   0.000018   0.000007   call gitgutter#utility#save_last_seen_change()

FUNCTION  gitgutter#hunk#set_hunks()
Called 1 time
Total time:   0.000029
 Self time:   0.000007

count  total (s)   self (s)
    1   0.000013   0.000003   call gitgutter#utility#setbufvar(gitgutter#utility#bufnr(), 'hunks', a:hunks)
    1   0.000016   0.000004   call s:reset_summary()

FUNCTION  airline#builder#new()
Called 12 times
Total time:   0.000235
 Self time:   0.000235

count  total (s)   self (s)
   12              0.000054   let builder = copy(s:prototype)
   12              0.000027   let builder._context = a:context
   12              0.000016   let builder._sections = []
                            
   12              0.000109   call extend(builder._context, { 'left_sep': g:airline_left_sep, 'left_alt_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_sep, 'right_alt_sep': g:airline_right_alt_sep, }, 'keep')
   12              0.000015   return builder

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
    1   2.205308   0.000048  nerdtree#ui_glue#invokeKeyMap()
    1   2.205260   0.000195  182()
    1   2.200422   0.000055  181()
    1   2.200367   0.000024  <SNR>52_activateFileNode()
    1   2.200343   0.000033  210()
    1   2.200310   0.000041  227()
    1   2.200138   0.000027  280()
    1   2.200111   0.000065  281()
    1   2.158198   0.001491  120()
    1   2.137364   0.000062  <SNR>34_BufEnterHook()
    1   2.137241   0.000139  <SNR>34_UpdateErrors()
    1   2.136236   0.000185  <SNR>34_CacheErrors()
    1   2.125737   0.000015  24()
    1   2.125688   0.000082  23()
    1   2.125532   0.000079  SyntaxCheckers_cpp_gcc_GetLocList()
    1   2.125049   0.000050  syntastic#c#GetLocList()
    1   2.123997   0.000245  SyntasticMake()
    1   2.123720   0.000000  syntastic#util#system()
    8   0.049514   0.000326  <SNR>15_on_window_changed()
    6   0.049170   0.000451  airline#update_statusline()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
 1028              0.016998  <SNR>81_get_syn()
  514   0.034475   0.014884  airline#highlighter#get_highlight()
    9   0.016767   0.012603  99()
  214   0.027881   0.008720  airline#highlighter#exec()
   12   0.041443   0.004305  379()
    2   0.022348   0.002905  airline#highlighter#highlight()
  110   0.031107   0.002601  <SNR>81_exec_separator()
  514              0.002593  <SNR>81_get_array()
   58              0.002117  <SNR>85_get_accented_line()
  214              0.001979  <SNR>81_CheckDefined()
    1   2.158198   0.001491  120()
   78   0.001632   0.001448  <SNR>86_get_section()
   15   0.002917   0.001446  146()
   24              0.001366  16()
    8   0.024017   0.001348  airline#check_mode()
  170              0.001243  <SNR>81_hl_group_exists()
  336              0.001178  <SNR>81_Get()
   46   0.027857   0.001164  <SNR>85_get_transitioned_seperator()
    9              0.001122  <SNR>60_Highlight_Matching_Pair()
   56   0.002349   0.000917  <SNR>86_add_section()

